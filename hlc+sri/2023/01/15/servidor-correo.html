<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Configuración de un servidor de correo en un VPS | sysmaria</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="Configuración de un servidor de correo en un VPS">
<meta property="og:locale" content="en_US">
<meta name="description" content="Introducción">
<meta property="og:description" content="Introducción">
<link rel="canonical" href="/hlc+sri/2023/01/15/servidor-correo.html">
<meta property="og:url" content="/hlc+sri/2023/01/15/servidor-correo.html">
<meta property="og:site_name" content="sysmaria">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-01-15T12:47:17+01:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Configuración de un servidor de correo en un VPS">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-15T12:47:17+01:00","datePublished":"2023-01-15T12:47:17+01:00","description":"Introducción","headline":"Configuración de un servidor de correo en un VPS","mainEntityOfPage":{"@type":"WebPage","@id":"/hlc+sri/2023/01/15/servidor-correo.html"},"url":"/hlc+sri/2023/01/15/servidor-correo.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="sysmaria">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="sysmaria" src="" onerror="this.style.display='none'">
  sysmaria
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/categories.html">CATEGORIAS</a>




</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/assets/images/banners/correo.png)"></div>
        <img class="img-placeholder" src="/assets/images/banners/correo.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Configuración de un servidor de correo en un VPS</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2023-01-15T12:47:17+01:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 15, 2023
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 20 mins</span>
  </p></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="introducción">Introducción</h2>

<p>En este post vamos a configurar un servidor de correos en nuestro VPS. El nombre del servidor será <code class="language-plaintext highlighter-rouge">mail.mariatec.es</code>, que será el nombre que aparecerá en el registro MX.</p>

<h2 id="gestión-de-correos-desde-el-servidor">Gestión de correos desde el servidor</h2>

<p>El envío y recepción se hará desde el servidor a trávés de la herramienta <code class="language-plaintext highlighter-rouge">mail</code>.</p>

<h2 id="gestión-de-correos-desde-el-servidor-1">Gestión de correos desde el servidor</h2>

<h3 id="tarea-1">Tarea 1</h3>

<p>Lo primero que deberemos hacer es realizar un registro DNS en nuestro dominio y añadir un registro <code class="language-plaintext highlighter-rouge">A</code> con el nombre <code class="language-plaintext highlighter-rouge">mail</code> y la IP del servidor.</p>

<p>🔲 mail.mariatec.es     A       82.223.1.72</p>

<p>Y agregamos un registro SPF para evitar que nuestro servidor sea utilizado como servidor de spam.</p>

<p>🔲 mariatec.es     SPF     “v=spf1 ip4:82.223.1.72 -all”</p>

<p><img src="/assets/images/correo/correo/1.png" alt="1"></p>

<p>Abrimos el puerto 25 en el cortafuegos del servidor y configuramos el registro PTR con el fqdn de nuestro VPS.</p>

<p><img src="/assets/images/correo/correo/2.png" alt="2"></p>

<p>Una vez terminado esto, nos conectamos a nuestro VPS y comentamos con la configuración:</p>

<ul>
  <li>
    <p>Instalamos postfix y bsd-mailx</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  apt <span class="nb">install </span>postfix bsd-mailx
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>NOTA</strong>: Recuerda que al instalar postfix te pedirá que configures el servidor de correo. En nuestro caso, seleccionamos la opción <code class="language-plaintext highlighter-rouge">Internet Site</code> y el nombre del dominio será <code class="language-plaintext highlighter-rouge">mariatec.es</code>.</p>

<ul>
  <li>
    <p>Enviaremos un correo a nuestro correo personal para comprobar que todo funciona correctamente.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">echo</span> <span class="s2">"Hola, esto es una prueba"</span> | mail <span class="nt">-s</span> <span class="s2">"Prueba"</span>
</code></pre></div>    </div>

    <p>Como podemos ver en la siguiente imagen, en el log del correo aparece el correo que hemos enviado y que ha sido recibido correctamente.</p>

    <p><img src="/assets/images/correo/correo/3.png" alt="3"></p>

    <p><img src="/assets/images/correo/correo/4.png" alt="4"></p>
  </li>
</ul>

<h3 id="tarea-2">Tarea 2</h3>

<p>En esta tarea, deberemos cerciorarnos de que podemos recibir correos ennuestro servidor VPS y por ello, vamos a usar el servicio de correo de gmail. Para que esto sea posible, deberemos realizar un nuevo registro MX 10 en nuestro dominio.</p>

<p>🔲 mariatec.es     MX 10    mail.mariatec.es</p>

<p>Para comprobar qeu funciona, accedemos a nuestra cuenta personal de correo y enviamos un correo a nuestro servidor.</p>

<p><img src="/assets/images/correo/correo/4.png" alt="4"></p>

<p>Y desde nuestra consola, nos enviaremos un correo y podemos ver que ha llegado correctamente:</p>

<p><img src="/assets/images/correo/correo/5.png" alt="5"></p>

<p><img src="/assets/images/correo/correo/6.png" alt="6"></p>

<h2 id="uso-de-alias-y-redirecciones">Uso de alias y redirecciones</h2>

<h3 id="tarea-3">Tarea 3</h3>

<p>Para completar esta tarea, configuraremos, mediante <code class="language-plaintext highlighter-rouge">cron</code>, un script que nos permita enviar un correo cada minuto con la fecha y hora actual. Para ello, crearemos un script en <code class="language-plaintext highlighter-rouge">/usr/local/bin</code> que se llame <code class="language-plaintext highlighter-rouge">cronmail.sh</code> y que tenga el siguiente contenido:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">"=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_="</span>
<span class="nb">echo</span> <span class="s2">"Fecha y hora actual: </span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_="</span>
<span class="nb">echo</span> <span class="s2">"Uptime: </span><span class="si">$(</span><span class="nb">uptime</span><span class="si">)</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_=_="</span>
<span class="nb">echo</span> <span class="s2">"Estado de los procesos:"</span>
ps
</code></pre></div></div>

<p>Le damos permisos de ejecución y comprobamos que funciona correctamente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x /root/cronmail.sh
<span class="nt">---</span>
bash /root/cronmail.sh
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/7.png" alt="7"></p>

<p>Ahora, crearemos un archivo en <code class="language-plaintext highlighter-rouge">/etc/cron.d</code> que se llame <code class="language-plaintext highlighter-rouge">cronmail</code> y que tenga el siguiente contenido:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">MAILTO</span><span class="o">=</span>root
<span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> root /root/cronmail.sh
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/8.png" alt="8"></p>

<p>Esperamos un minuto y comprobamos que el correo ha llegado correctamente:</p>

<p><img src="/assets/images/correo/correo/9.png" alt="9"></p>

<p>Lo que hemos hecho es crear un script que se ejecuta cada minuto y que envía un correo con la fecha y hora actual, el uptime del servidor y el estado de los procesos.</p>

<p>El paso que viene ahora crear un alias para que los correos que se envíen a <code class="language-plaintext highlighter-rouge">root</code> se envíen a nuestro correo personal.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /etc/aliases
<span class="nt">---</span>
root:   mariajesus
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/10.png" alt="10"></p>

<p>Ejecutamos <code class="language-plaintext highlighter-rouge">newaliases</code> para que se actualice el archivo de alias y comprobamos que funciona correctamente:</p>

<p><img src="/assets/images/correo/correo/11.png" alt="11"></p>

<p><img src="/assets/images/correo/correo/12.png" alt="12"></p>

<p>Por último, creamos una redirección para que los correos que se envíen a <code class="language-plaintext highlighter-rouge">root</code> se envíen a nuestro correo personal.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /home/mariajesus/.forward
<span class="nt">---</span>
correo@gmail.com
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/13.png" alt="13"></p>

<h2 id="para-asegurar-el-envío">Para asegurar el envío</h2>

<h3 id="tarea-4">Tarea 4</h3>

<p>En esta tarea, deberemos configurar el DomainKeys Identified Mail (DKIM) para que los correos que envíe nuestro servidor sean firmados digitalmente. Para ello, instalaremos el paquete <code class="language-plaintext highlighter-rouge">opendkim</code> y <code class="language-plaintext highlighter-rouge">opendkim-tools</code> y crearemos un archivo de configuración en <code class="language-plaintext highlighter-rouge">/etc/opendkim.conf</code> que tenga el siguiente contenido:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>opendkim opendkim-tools <span class="nt">-y</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Domain mariatec.es
Selector dkim2023
KeyFile /etc/dkimkeys/dkim2023.private
<span class="c">#Socket local:/var/opendkim/opendkim.sock</span>
Socket inet:8891@localhost
PidFile /var/opendkim/opendkim.pid
TrustAnchorFile /usr/share/dns/root.key
</code></pre></div></div>

<p>Tras esto, modificaremos el archivo <code class="language-plaintext highlighter-rouge">/etc/default/opendkim</code> para que se ejecute en el puerto 8891 y no en el socket local.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SOCKET</span><span class="o">=</span>inet:8891@localhost
</code></pre></div></div>

<p>Y modificamos el archivo <code class="language-plaintext highlighter-rouge">/etc/postfix/main.cf</code> para señalar el modo de firma de los correos y el puerto en el que se ejecuta el servicio de <code class="language-plaintext highlighter-rouge">opendkim</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>milter_default_action <span class="o">=</span> accept
milter_protocol <span class="o">=</span> 2
smtpd_milters <span class="o">=</span> inet:localhost:8891
non_smtpd_milters <span class="o">=</span> <span class="nv">$smtpd_milters</span>
</code></pre></div></div>

<p>Cuando tengamos todo esto configurado, generamos la clave privada y pública para el selector <code class="language-plaintext highlighter-rouge">dkim2023</code>. También le cambiamos el propietario al usuario <code class="language-plaintext highlighter-rouge">opendkim</code> y reiniciamos los servicios.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/dkimkeys
opendkim-genkey <span class="nt">-s</span> dkim2023 <span class="nt">-d</span> mariatec.es <span class="nt">-b</span> 2048
<span class="nb">chown </span>opendkim:opendkim dkim2023.private dkim2023.txt
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/14.png" alt="14"></p>

<p>Para que postfix pueda usar la clave, deberá tener la siguiente estructura:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dkim2023._domainkey     IN      TXT     <span class="o">(</span> <span class="s2">"v=DKIM1; h=sha256; k=rsa; "</span>
          <span class="s2">"p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3gaVO68xhAlj7yNqNHEPh2zJDF+Mz5Zt9nsb54fElkvjUhAWUc+YiQ2yb+5tSo2EXjZV8LZCogkdKWkJniAmID/ZcyxZZB3XDa7nWpVJGF1JlOPXw+gJonq3Pdii945bIBR91ZcPR9KBL2TUZX0mHs1I1DlyXEALjajI5v2qbUFIVVCM6Kvv2qHB1FKhbkXozOW/ILoQr6unUp"</span>
          <span class="s2">"Y4pFGzgZBkUUWQVTHCJ/J9d2VIjN1lp1Ro3sV788PoU8Mk9piRmyW3+p1hoh6qeTqFv9QekD4jsiWBHuWM7mo3vLBoO4lzMsvcyPuAgaqsy2oEuq3RvtO23mNoqwtA5QmNGrQsBwIDAQAB"</span> <span class="o">)</span>  <span class="p">;</span> <span class="nt">-----</span> DKIM key dkim2023 <span class="k">for </span>mariatec.es
</code></pre></div></div>

<p>Y en el registro TXT del DNS colocaremos la clave pública:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">v</span><span class="o">=</span>DKIM1<span class="p">;</span> <span class="nv">h</span><span class="o">=</span>sha256<span class="p">;</span> <span class="nv">k</span><span class="o">=</span>rsa<span class="p">;</span> <span class="nv">p</span><span class="o">=</span><span class="nv">p</span><span class="o">=</span>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3gaVO68xhAlj7yNqNHEPh2zJDF+Mz5Zt9nsb54fElkvjUhAWUc+YiQ2yb+5tSo2EXjZV8LZCogkdKWkJniAmID/ZcyxZZB3XDa7nWpVJGF1JlOPXw+gJonq3Pdii945bIBR91ZcPR9KBL2TUZX0mHs1I1DlyXEALjajI5v2qbUFIVVCM6Kvv2qHB1FKhbkXozOW/ILoQr6unUp
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/15.png" alt="15"></p>

<p>Reiniciamos los servicios y comprobamos que funciona correctamente.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart opendkim postfix
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat <span class="nt">-tulpn</span> | <span class="nb">grep </span>8891
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/16.png" alt="16"></p>

<p>Como podemos ver en las siguientes capturas, en la cabecera del correo se añade la información de la firma.</p>

<p><img src="/assets/images/correo/correo/17.png" alt="17"></p>

<p>Y en la web de <a href="https://dkimvalidator.com/">dkimvalidator</a> podemos comprobar que la firma es correcta.</p>

<p><img src="/assets/images/correo/correo/18.png" alt="18"></p>

<h2 id="para-luchar-contra-el-spam">Para luchar contra el SPAM</h2>

<h3 id="tarea-5">Tarea 5</h3>

<p>Le ha llegado el turno a la tarea 5. En esta tarea vamos a configurar Postfix para que tenga en cuenta el registro SPF de los correos que recibe. Para ello, vamos a instalar el paquete <code class="language-plaintext highlighter-rouge">postfix-policyd-spf-python</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>postfix-policyd-spf-python <span class="nt">-y</span>
</code></pre></div></div>

<p>Modificaremos el archivo <code class="language-plaintext highlighter-rouge">/etc/postfix/main.cf</code> para que se ejecute el servicio de <code class="language-plaintext highlighter-rouge">policyd-spf</code> y para que se ejecute el servicio de <code class="language-plaintext highlighter-rouge">opendkim</code>. Con la siguiente sentencia le estaremos indicando a postfix para comprobar el SPF de los correos que recibe.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>policy-spf  unix  -       n       n       -       0       spawn
    <span class="nv">user</span><span class="o">=</span>policyd-spf <span class="nv">argv</span><span class="o">=</span>/usr/bin/policyd-spf
</code></pre></div></div>

<p>Reiniciamos el servicio de postfix y comprobamos que funciona correctamente.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart postfix

<span class="nb">tail</span> <span class="nt">-f</span> /var/log/mail.log
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/19.png" alt="19"></p>

<h3 id="tarea-6">Tarea 6</h3>

<p>Le toca el turno a la protección contra el SPAM. Para ello, vamos a instalar el paquete <code class="language-plaintext highlighter-rouge">spamassassin</code> y habilitaremos el servicio.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>spamassassin spamc <span class="nt">-y</span>
<span class="nb">sudo </span>systemctl <span class="nb">enable</span> <span class="nt">--now</span> spamassassin
</code></pre></div></div>

<p>Modificamos el fichero <code class="language-plaintext highlighter-rouge">/etc/default/spamassassin</code> y agregaremos las líneas necesarias para que se actualice la base de datos de spamassassin.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CRON</span><span class="o">=</span>1
</code></pre></div></div>

<p>Y en el fichero <code class="language-plaintext highlighter-rouge">/etc/postfix/master.cf</code> agregaremos la siguiente línea para que el servicio de postfix ejecute el servicio de spamassassin.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smtp      inet  n       -       y       -       -       smtpd
  <span class="nt">-o</span> <span class="nv">content_filter</span><span class="o">=</span>spamassassin
submission inet n       -       y       -       -       smtpd
  <span class="nt">-o</span> <span class="nv">content_filter</span><span class="o">=</span>spamassassin
spamassassin unix -     n       n       -       -       pipe
  <span class="nv">user</span><span class="o">=</span>debian-spamd <span class="nv">argv</span><span class="o">=</span>/usr/bin/spamc <span class="nt">-f</span> <span class="nt">-e</span> /usr/sbin/sendmail <span class="nt">-oi</span> <span class="nt">-f</span> <span class="k">${</span><span class="nv">sender</span><span class="k">}</span> <span class="k">${</span><span class="nv">recipient</span><span class="k">}</span>
</code></pre></div></div>

<p>Y para configurar que los emails que se detecten como SPAM, reciban una etiqueta en el asunto, modificaremos el fichero <code class="language-plaintext highlighter-rouge">/etc/spamassassin/local.cf</code> y descomentamos la siguiente línea.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rewrite_header Subject <span class="k">*****</span>SPAM<span class="k">*****</span>
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/20.png" alt="20"></p>

<p>Reiniciamos los servicios y comprobamos que funciona correctamente.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart postfix spamassassin
</code></pre></div></div>

<p>Comprobaremos que funciona, enviando un correo a nuestro email en nuestro VPS y comprobando que se ha etiquetado como SPAM. Por ello, usaremos <a href="https://spamassassin.apache.org/gtube/">The GTUBE</a> para enviar un correo que se detecte como SPAM.</p>

<p>Comprobando que el email se ha etiquetado como SPAM, miraremos también el log de mail para comprobar que se ha ejecutado el servicio de spamassassin.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tail</span> <span class="nt">-f</span> /var/log/mail.log <span class="nt">-n</span> 26
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/21.png" alt="21"></p>

<h3 id="tarea-7">Tarea 7</h3>

<p>Nuestro servidor de correo deberá tener antivirus que se encargue de detectar y eliminar los virus que se encuentren en los correos que recibe. Para ello, vamos a instalar el paquete <code class="language-plaintext highlighter-rouge">clamav</code> y habilitaremos el servicio.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>clamsmtp clamav-daemon arc arj bzip2 cabextract lzop nomarch p7zip pax tnef unrar-free unzip <span class="nt">-y</span>

systemctl <span class="nb">enable</span> <span class="nt">--now</span> clamav-daemon
</code></pre></div></div>

<p>El siguiente paso el fichero <code class="language-plaintext highlighter-rouge">/etc/postfix/master.cf</code> y agregaremos la siguiente línea para que el servicio de postfix ejecute el servicio de clamav.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scan unix -       -       n       -       16       smtp
  <span class="nt">-o</span> <span class="nv">smtp_data_done_timeout</span><span class="o">=</span>1200
  <span class="nt">-o</span> <span class="nv">smtp_send_xforward_command</span><span class="o">=</span><span class="nb">yes</span>
  <span class="nt">-o</span> <span class="nv">disable_dns_lookups</span><span class="o">=</span><span class="nb">yes
</span>127.0.0.1:10025 inet n       -       n       -       16       smtpd
  <span class="nt">-o</span> <span class="nv">content_filter</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">local_recipient_maps</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">relay_recipient_maps</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_restriction_classes</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_client_restrictions</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_helo_restrictions</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_sender_restrictions</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_recipient_restrictions</span><span class="o">=</span>permit_mynetworks,reject
  <span class="nt">-o</span> <span class="nv">mynetworks_style</span><span class="o">=</span>host
  <span class="nt">-o</span> <span class="nv">smtpd_authorized_xforward_hosts</span><span class="o">=</span>127.0.0.0/8
</code></pre></div></div>

<p>Y en el fichero <code class="language-plaintext highlighter-rouge">/etc/postfix/main.cf</code> y le indicamos el socket que usará el servicio de clamav.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>content_filter <span class="o">=</span> scan:127.0.0.1:10026
</code></pre></div></div>

<p>Reconfiguramos <code class="language-plaintext highlighter-rouge">clamav-daemon</code> de forma que le indiquemos los hilos de procesador que usará y el resto de parámetros.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpkg-reconfigure clamav-daemon
</code></pre></div></div>

<p>Y reiniciamos los servicios.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart postfix clamav-daemon
</code></pre></div></div>

<p><strong>NOTA</strong> : Será normal que <code class="language-plaintext highlighter-rouge">ClamAV</code> tarde un poco en arrancar, ya que tiene que actualizar la base de datos de virus.</p>

<p>Para probarlo, enviaremos un correo con <code class="language-plaintext highlighter-rouge">X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*</code> para probar que se detecta como virus.</p>

<p>Comprobando que el email se ha etiquetado como virus, miraremos también el log de mail para comprobar que se ha ejecutado el servicio de clamav.</p>

<p><img src="/assets/images/correo/correo/22.png" alt="22"></p>

<h2 id="gestión-de-correos-desde-un-cliente">Gestión de correos desde un cliente</h2>

<h3 id="tarea-8">Tarea 8</h3>

<p>Aquí vamos a configurar el buzón de los usuarios para que puedan acceder a él desde un cliente de correo. Y para ello, el primer paso es modificar la configuración de <code class="language-plaintext highlighter-rouge">postfix</code>, en el fichero <code class="language-plaintext highlighter-rouge">/etc/postfix/main.cf</code> para que use el buzón <code class="language-plaintext highlighter-rouge">Maildir</code> añadiendo al final del fichero <code class="language-plaintext highlighter-rouge">home_mailbox = Maildir/</code>.</p>

<p>Reiniciamos el servicio de postfix y tras esto, la función <code class="language-plaintext highlighter-rouge">mail</code> dejará de funcionar, ya que no encontrará el buzón <code class="language-plaintext highlighter-rouge">Maildir</code> en el directorio <code class="language-plaintext highlighter-rouge">/var/mail</code>. Para ello, instalaremos <code class="language-plaintext highlighter-rouge">mutt</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>mutt <span class="nt">-y</span>
systemctl restart postfix
</code></pre></div></div>

<p>Y configuramos <code class="language-plaintext highlighter-rouge">mutt</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span><span class="nv">mbox_type</span><span class="o">=</span>Maildir
<span class="nb">set </span><span class="nv">mbox</span><span class="o">=</span><span class="s2">"~/Maildir"</span>
<span class="nb">set </span><span class="nv">folder</span><span class="o">=</span><span class="s2">"~/Maildir"</span>
<span class="nb">set </span><span class="nv">spoolfile</span><span class="o">=</span><span class="s2">"~/Maildir"</span>
<span class="nb">set </span><span class="nv">record</span><span class="o">=</span><span class="s2">"+.Sent"</span>
<span class="nb">set </span><span class="nv">postponed</span><span class="o">=</span><span class="s2">"+.Drafts"</span>
<span class="nb">set </span><span class="nv">mask</span><span class="o">=</span><span class="s2">"!^</span><span class="se">\\</span><span class="s2">.[^.]"</span>
</code></pre></div></div>

<p>Para probar que funciona, enviaremos un correo a nuestro buzón y comprobaremos que se ha recibido correctamente.</p>

<p><img src="/assets/images/correo/correo/23.png" alt="23"></p>

<p><img src="/assets/images/correo/correo/24.png" alt="24"></p>

<p>Realizado esto, podemos decir que tenemos un buzón de correo funcionando correctamente como <code class="language-plaintext highlighter-rouge">Maildir</code> en vez de <code class="language-plaintext highlighter-rouge">mbox</code>.</p>

<h3 id="tarea-9">Tarea 9</h3>

<p>Vamos a configurar el protocolo IMAP instalando el paquete <code class="language-plaintext highlighter-rouge">dovecot-imapd</code> y habilitaremos el servicio.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>dovecot-imapd <span class="nt">-y</span>
systemctl <span class="nb">enable</span> <span class="nt">--now</span> dovecot
netstat <span class="nt">-tulpn</span> | <span class="nb">grep </span>dovecot
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/25.png" alt="25"></p>

<p>Paramos nginx para que no interfiera con el puerto 80.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl stop nginx
</code></pre></div></div>

<p>Y generamos un certificado SSL para el servidor de correo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certbot certonly <span class="nt">--standalone</span> <span class="nt">-d</span> mail.mariatec.es
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/26.png" alt="26"></p>

<p>Modificamos la configuración de <code class="language-plaintext highlighter-rouge">dovecot</code> en el fichero <code class="language-plaintext highlighter-rouge">/etc/dovecot/dovecot.conf</code> para que use el certificado SSL que hemos generado. Una vez configurado, reiniciamos el servicio y también el servicio de nginx.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssl_cert <span class="o">=</span> &lt;/etc/letsencrypt/live/mail.mariatec.es/fullchain.pem
ssl_key <span class="o">=</span> &lt;/etc/letsencrypt/live/mail.mariatec.es/privkey.pem
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/27.png" alt="27"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart dovecot
systemctl restart nginx
</code></pre></div></div>

<p><strong>INCISO</strong>: Vamos a realizar primero la configuración de postfix para que mande correos desde un cliente remoto, ya que si no, no podremos probar el servicio de IMAP. Después de esto, instalaremos un webmail.</p>

<h3 id="tarea-11">Tarea 11</h3>

<p>Los mismos certificados que hemos generado antes para cifrar los emails enviados y recibidos. Para ello, modificamos el fichero <code class="language-plaintext highlighter-rouge">/etc/postfix/main.cf</code> y añadimos las siguientes líneas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>smtpd_tls_cert_file <span class="o">=</span> /etc/letsencrypt/live/mail.mariatec.es/fullchain.pem
smtpd_tls_key_file <span class="o">=</span> /etc/letsencrypt/live/mail.mariatec.es/privkey.pem

smtpd_sasl_auth_enable <span class="o">=</span> <span class="nb">yes
</span>smtpd_sasl_type <span class="o">=</span> dovecot
smtpd_sasl_path <span class="o">=</span> private/auth
smtpd_sasl_authenticated_header <span class="o">=</span> <span class="nb">yes
</span>broken_sasl_auth_clients <span class="o">=</span> <span class="nb">yes</span>
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/28.png" alt="28"></p>

<p>Acto seguido, configuraremos el fichero <code class="language-plaintext highlighter-rouge">master.cf</code> y modificamos la directiva submission para que use el puerto 587 y el fichero <code class="language-plaintext highlighter-rouge">smtpd.conf</code> para que use el puerto 465.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
submission inet n       -       y       -       -       smtpd
  <span class="nt">-o</span> <span class="nv">content_filter</span><span class="o">=</span>spamassassin
  <span class="nt">-o</span> <span class="nv">syslog_name</span><span class="o">=</span>postfix/submission
  <span class="nt">-o</span> <span class="nv">smtpd_tls_security_level</span><span class="o">=</span>encrypt
  <span class="nt">-o</span> <span class="nv">smtpd_sasl_auth_enable</span><span class="o">=</span><span class="nb">yes</span>
  <span class="nt">-o</span> <span class="nv">smtpd_tls_auth_only</span><span class="o">=</span><span class="nb">yes</span>
  <span class="nt">-o</span> <span class="nv">smtpd_reject_unlisted_recipient</span><span class="o">=</span>no
  <span class="nt">-o</span> <span class="nv">smtpd_client_restrictions</span><span class="o">=</span><span class="nv">$mua_client_restrictions</span>
  <span class="nt">-o</span> <span class="nv">smtpd_helo_restrictions</span><span class="o">=</span><span class="nv">$mua_helo_restrictions</span>
  <span class="nt">-o</span> <span class="nv">smtpd_sender_restrictions</span><span class="o">=</span><span class="nv">$mua_sender_restrictions</span>
  <span class="nt">-o</span> <span class="nv">smtpd_recipient_restrictions</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_relay_restrictions</span><span class="o">=</span>permit_sasl_authenticated,reject
  <span class="nt">-o</span> <span class="nv">milter_macro_daemon_name</span><span class="o">=</span>ORIGINATING

smtps     inet  n       -       y       -       -       smtpd
  <span class="nt">-o</span> <span class="nv">syslog_name</span><span class="o">=</span>postfix/smtps
  <span class="nt">-o</span> <span class="nv">smtpd_tls_wrappermode</span><span class="o">=</span><span class="nb">yes</span>
  <span class="nt">-o</span> <span class="nv">smtpd_sasl_auth_enable</span><span class="o">=</span><span class="nb">yes</span>
  <span class="nt">-o</span> <span class="nv">smtpd_reject_unlisted_recipient</span><span class="o">=</span>no
  <span class="nt">-o</span> <span class="nv">smtpd_client_restrictions</span><span class="o">=</span><span class="nv">$mua_client_restrictions</span>
  <span class="nt">-o</span> <span class="nv">smtpd_helo_restrictions</span><span class="o">=</span><span class="nv">$mua_helo_restrictions</span>
  <span class="nt">-o</span> <span class="nv">smtpd_sender_restrictions</span><span class="o">=</span><span class="nv">$mua_sender_restrictions</span>
  <span class="nt">-o</span> <span class="nv">smtpd_recipient_restrictions</span><span class="o">=</span>
  <span class="nt">-o</span> <span class="nv">smtpd_relay_restrictions</span><span class="o">=</span>permit_sasl_authenticated,reject
  <span class="nt">-o</span> <span class="nv">milter_macro_daemon_name</span><span class="o">=</span>ORIGINATING
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/29.png" alt="29"></p>

<p>Ahora, a <code class="language-plaintext highlighter-rouge">dovecot</code>, le indicamos qué debe hacer para autenticarse. Lo haremos en el fichero <code class="language-plaintext highlighter-rouge">/etc/dovecot/conf.d/10-master.conf</code> y añadimos las siguientes líneas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service auth <span class="o">{</span>
  ...
  <span class="c"># Postfix smtp-auth</span>
  unix_listener /var/spool/postfix/private/auth <span class="o">{</span>
    mode <span class="o">=</span> 0666
  <span class="o">}</span>
  ...
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/30.png" alt="30"></p>

<p>Reiniciamos los servicios y comprobamos que todo funciona correctamente. Deberemos abrir los puertos 465 y 993 en el firewall de nuestro VPS.</p>

<p>Para comprobar que funciona correctamente, he usado <code class="language-plaintext highlighter-rouge">Thunderbird</code>, configuramos el correo y comprobamos que funciona correctamente.</p>

<p><img src="/assets/images/correo/correo/31.png" alt="31"></p>

<p>Ya podemos decir que los correos están sincronizados correctamente entre el servidor y el cliente. También probaremos que, desde <code class="language-plaintext highlighter-rouge">Thunderbird</code>, podemos enviar un correo a mi cuenta de gmail y que llega correctamente.</p>

<p><img src="/assets/images/correo/correo/32.png" alt="32"></p>

<p>También vamos a probar que podemos responder al email y que se sincronizan correctamente los emails de mi servidor y los emailsdel cliente de correo.</p>

<p><img src="/assets/images/correo/correo/33.png" alt="33"></p>

<h3 id="tarea-10">Tarea 10</h3>

<p>Ha llegado la hora de instalar un webmail. Para ello, vamos a instalar <code class="language-plaintext highlighter-rouge">Roundcube</code>. Para ello, prepararemos el VPS para que pueda instalar <code class="language-plaintext highlighter-rouge">Roundcube</code> y sus dependencias.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>docker.io
</code></pre></div></div>

<p>Agregaremos un registro CNAME en nuestro DNS para que el dominio <code class="language-plaintext highlighter-rouge">webmail.mariatec.es</code> apunte a la IP del servidor.</p>

<p>🔲 webmail.mariatec.es     CNAME      mariatec.es</p>

<p>Le toca el turno a roundcube y a su configuración, y para eso empezaremos por crear un directorio en el depositaremos los ficheros de configuración de <code class="language-plaintext highlighter-rouge">Roundcube</code> y lo estrenaremos creando el fichero <code class="language-plaintext highlighter-rouge">custom.inc.php</code> que contendrá la configuración de la base de datos.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /root/config-roundcube

nano /root/configs-roundcube/custom.inc.php
</code></pre></div></div>

<p>Dentro del fichero, añadiremos:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?php
<span class="nv">$config</span><span class="o">[</span><span class="s1">'mail_domain'</span><span class="o">]</span> <span class="o">=</span> array<span class="o">(</span>
    <span class="s1">'mail.mariatec.es'</span> <span class="o">=&gt;</span> <span class="s1">'mariatec.es'</span>
<span class="o">)</span><span class="p">;</span>
?&gt;
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/34.png" alt="34"></p>

<p>Echamos a andar el contenedor de docker donde tenemos la aplicación de <code class="language-plaintext highlighter-rouge">Roundcube</code> y le pasamos los parámetros necesarios para que funcione correctamente.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-v</span> /root/config-roundcube/:/var/roundcube/config/ <span class="nt">-e</span> <span class="nv">ROUNDCUBEMAIL_DEFAULT_HOST</span><span class="o">=</span>ssl://mail.mariatec.es <span class="nt">-e</span> <span class="nv">ROUNDCUBEMAIL_SMTP_SERVER</span><span class="o">=</span>ssl://mail.mariatec.es <span class="nt">-e</span> <span class="nv">ROUNDCUBEMAIL_SMTP_PORT</span><span class="o">=</span>465 <span class="nt">-e</span> <span class="nv">ROUNDCUBEMAIL_DEFAULT_PORT</span><span class="o">=</span>993 <span class="nt">-p</span> 8001:80 <span class="nt">-d</span> roundcube/roundcubemail
</code></pre></div></div>

<p>Y en la siguiente imagen podemos ver como el contenedor se ha levantado correctamente.</p>

<p><img src="/assets/images/correo/correo/35.png" alt="35"></p>

<p>Paramos de nuevo <code class="language-plaintext highlighter-rouge">Nginx</code> y creamos un certificado para el dominio <code class="language-plaintext highlighter-rouge">webmail.mariatec.es</code> y lo instalamos en el servidor.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop nginx

certbot certonly <span class="nt">--standalone</span> <span class="nt">-d</span> webmail.mariatec.es
</code></pre></div></div>

<p>Ya terminada toda la configuración anterior, tendremos que crear un VirtualHost para <code class="language-plaintext highlighter-rouge">Nginx</code> que redirija las peticiones a <code class="language-plaintext highlighter-rouge">Roundcube</code> y que esté protegido por <code class="language-plaintext highlighter-rouge">Let's Encrypt</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /etc/nginx/sites-available/webmail.mariatec.es
</code></pre></div></div>

<p>Dentro del fichero, añadiremos:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
        listen 80<span class="p">;</span>
        listen <span class="o">[</span>::]:80<span class="p">;</span>

        server_name webmail.mariatec.es<span class="p">;</span>

        <span class="k">return </span>301 https://<span class="nv">$host$request_uri</span><span class="p">;</span>
<span class="o">}</span>

server <span class="o">{</span>
        listen 443 ssl http2<span class="p">;</span>
        listen <span class="o">[</span>::]:443 ssl http2<span class="p">;</span>

        ssl    on<span class="p">;</span>
        ssl_certificate /etc/letsencrypt/live/webmail.mariatec.es/fullchain.pem<span class="p">;</span>
        ssl_certificate_key     /etc/letsencrypt/live/webmail.mariatec.es/privkey.pem<span class="p">;</span>

        index index.html index.php index.htm index.nginx-debian.html<span class="p">;</span>

        server_name webmail.mariatec.es<span class="p">;</span>

        location / <span class="o">{</span>
                proxy_pass http://localhost:8001<span class="p">;</span>
                include proxy_params<span class="p">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Para que esté habilitado el VirtualHost, tendremos que crear un enlace simbólico en <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-enabled/</code> y reiniciar el servicio de <code class="language-plaintext highlighter-rouge">Nginx</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/webmail.mariatec.es /etc/nginx/sites-enabled/webmail.mariatec.es

systemctl restart nginx
</code></pre></div></div>

<p><img src="/assets/images/correo/correo/36.png" alt="36"></p>

<p>Ahora, ya podemos acceder a <code class="language-plaintext highlighter-rouge">Roundcube</code> desde el navegador.</p>

<p><img src="/assets/images/correo/correo/37.png" alt="37"></p>

<p><img src="/assets/images/correo/correo/38.png" alt="38"></p>

<p>Hacemos una prueba de envío de correo desde <code class="language-plaintext highlighter-rouge">Roundcube</code> y comprobamos que funciona correctamente.</p>

<p><img src="/assets/images/correo/correo/39.png" alt="39"></p>

<p>En gmail podemos verificar que el correo ha llegado correctamente.</p>

<p><img src="/assets/images/correo/correo/40.png" alt="40"></p>

<h3 id="tarea-12">Tarea 12</h3>

<p>En la tarea 10 ya hemos comprobado que ya hemos podido enviar y recibir correos desde el servidor de correo. Ahora, vamos a comprobar que el servidor de correo funciona correctamente y que podemos enviar y recibir correos desde el servidor.</p>

<h2 id="comprobación-final">Comprobación final</h2>

<h3 id="tarea-13">Tarea 13</h3>

<p>Última tarea, comprobación final. Para ello, vamos a comprobar que el servidor de correo funciona correctamente y que podemos enviar y recibir correos desde el servidor. Comprobaremos con un correo generado por <a href="https://www.mail-tester.com/">mail-tester.com</a> y que, con la puntuación que nos da, podemos ver que el servidor de correo funciona correctamente.</p>

<p>Para ello, modificaremos nuestro DNS y añadiremos un registro TXT con el valor que nos da <code class="language-plaintext highlighter-rouge">mail-tester.com</code> y que nos permitirá que el servidor de correo sea verificado por <code class="language-plaintext highlighter-rouge">mail-tester.com</code>.</p>

<p>🔲 _dmarc.mariatec.es     TXT      v=DMARC1; p=none;</p>

<p><img src="/assets/images/correo/correo/41.png" alt="41"></p>

<p><img src="/assets/images/correo/correo/42.png" alt="42"></p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/seguridad/2023/01/13/vpn-d.html" title="VPN sitio a sitio con WireGuard">VPN sitio a sitio con WireGuard...</a><a class="next" href="/hlc+sri/2023/01/21/almacenamiento.html" title="Taller de Almacenamiento - Gestión de pool de almacenamiento lógico en KVM-libvirt">Taller de Almacenamiento - Gestión de...</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/hlc+sri/2022/12/05/escenario.html" title="Taller de Almacenamiento - Gestión de pool de almacenamiento lógico en KVM-libvirt">Escenario en OpenStack</a></li>
<li><a class="post-link" href="/hlc+sri/2023/01/10/correo.html" title="Taller de Almacenamiento - Gestión de pool de almacenamiento lógico en KVM-libvirt">Servidor de correo en los servidores de clase</a></li>
<li><a class="post-link" href="/hlc+sri/2023/02/12/kubernetes-p1.html" title="Taller de Almacenamiento - Gestión de pool de almacenamiento lógico en KVM-libvirt">Despliegue de una aplicación en Kubernetes</a></li>
<li><a class="post-link" href="/asgdb/2022/11/08/interconexion.html" title="Taller de Almacenamiento - Gestión de pool de almacenamiento lógico en KVM-libvirt">Interconexiones de servidores</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">MENÚ 📝</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
