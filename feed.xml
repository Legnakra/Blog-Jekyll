<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-11-08T18:31:37+01:00</updated><id>/feed.xml</id><title type="html">sysmaria</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Apache como proxy inverso</title><link href="/hlc+sri/2022/11/08/proxy.html" rel="alternate" type="text/html" title="Apache como proxy inverso" /><published>2022-11-08T13:11:32+01:00</published><updated>2022-11-08T13:11:32+01:00</updated><id>/hlc+sri/2022/11/08/proxy</id><content type="html" xml:base="/hlc+sri/2022/11/08/proxy.html"><![CDATA[<h2 id="apache-como-proxy-inverso">Apache como proxy inverso</h2>

<p>Apache es un servidor web que se puede utilizar como proxy inverso. En este artículo se explica cómo configurar Apache para que actúe como proxy inverso.</p>

<h2 id="configuración">Configuración</h2>

<p>Lo primero que haremos será aplicar el <a href="https://fp.josedomingo.org/sri2223/3_http/files/ejercicio_proxy.zip">escenario</a> donde encontraremos:</p>

<ul>
  <li>Un escenario vagrant con dos máquinas virtuales:
    <ul>
      <li>Una máquina proxy conectada al exterior y a una red interna.</li>
      <li>Una máquina servidorweb conectada a la red interna.</li>
    </ul>
  </li>
  <li>Una receta ansible para configurar las dos máquinas virtuales del escenario anterior.</li>
</ul>

<p>Lo siguiente será instalar apache en la máquina proxy y configurarla para acceder a las páginas web de la máquina servidorweb. La primera URL es www.app1.org y la segunda es www.app2.org.</p>

<p>Activaremos el módulo proxy y proxy_http de apache:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2enmod proxy
a2enmod proxy_http
</code></pre></div></div>

<p>Y reiniciaremos el servidor web:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart apache2
</code></pre></div></div>

<p>Ahora crearemos un archivo de configuración para cada una de las aplicaciones que queremos que se sirvan a través de apache. En este caso, crearemos dos archivos de configuración: app1.conf y app2.conf. Estos archivos de configuración se guardarán en la ruta /etc/apache2/sites-available.</p>

<p>El contenido de app1.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
        ServerName www.app1.org
        ProxyPass               /       "http://interno.example1.org"
        ProxyPassReverse        /       "http://interno.example1.org"
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Y el contenido de app2.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
        ServerName www.app2.org
        ProxyPass               /       "http://interno.example2.org"
        ProxyPassReverse        /       "http://interno.example2.org"
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Ahora activaremos los archivos de configuración de las aplicaciones:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2ensite app1.conf
a2ensite app2.conf
</code></pre></div></div>

<p>Y reiniciaremos el servidor web:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart apache2
</code></pre></div></div>

<p>Ahora configuraremos el archivo /etc/hosts de la máquina host para que resuelva los nombres de las aplicaciones a las direcciones IP de las máquinas servidorweb. El contenido del archivo /etc/hosts será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.121.63 www.app1.org www.app2.org
</code></pre></div></div>

<p>Ahora configuraremos el archivo /etc/hosts de las máquinas servidorweb para que resuelva los nombres de las aplicaciones a las direcciones IP de la máquina proxy. El contenido del archivo /etc/hosts será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10.0.0.6 interno.example1.org interno.example2.org
</code></pre></div></div>

<p>Ahora, desde la máquina host, accederemos a las aplicaciones a través de la máquina proxy. Para ello, abriremos un navegador web y accederemos a las siguientes URLs:</p>

<p><img src="/assets/images/proxy/1.png" alt="1" /></p>

<p><img src="/assets/images/proxy/2.png" alt="2" /></p>

<h2 id="creamos-un-virtualhost-para-las-dos-aplicaciones">Creamos un virtualhost para las dos aplicaciones</h2>

<p>En vez de crear un virtualhost para cada aplicación, podemos crear un virtualhost para las dos aplicaciones. El contenido del archivo servidor.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
    ServerName www.servidor.org
    &lt;Location "/app1"&gt;
        ProxyPass           "http://interno.example1.org"
        ProxyPassReverse    "http://interno.example1.org"
    &lt;/Location&gt;
    &lt;Location "/app2"&gt;
        ProxyPass           "http://interno.example2.org"
        ProxyPassReverse    "http://interno.example2.org"
    &lt;/Location&gt;
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Ahora activaremos el archivo de configuración de la aplicación:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2ensite servidor.conf
</code></pre></div></div>

<p>Y reiniciaremos el servidor web:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart apache2
</code></pre></div></div>

<p>Cambiaremos el contenido del archivo /etc/hosts de la máquina host para que resuelva el nombre de la aplicación a la dirección IP de la máquina proxy. El contenido del archivo /etc/hosts será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.121.63 www.app1.org www.app2.org www.servidor.org
</code></pre></div></div>

<p>Ahora, desde la máquina host, accederemos a las aplicaciones a través de la máquina proxy. Para ello, abriremos un navegador web y accederemos a las siguientes URLs:</p>

<p><img src="/assets/images/proxy/3.png" alt="3" /></p>

<p><img src="/assets/images/proxy/4.png" alt="4" /></p>]]></content><author><name></name></author><category term="hlc+sri" /><summary type="html"><![CDATA[Apache como proxy inverso]]></summary></entry><entry><title type="html">Introducción a GitHub</title><link href="/python/2022/11/06/github.html" rel="alternate" type="text/html" title="Introducción a GitHub" /><published>2022-11-06T16:45:16+01:00</published><updated>2022-11-06T16:45:16+01:00</updated><id>/python/2022/11/06/github</id><content type="html" xml:base="/python/2022/11/06/github.html"><![CDATA[<h2 id="qué-es-github">¿Qué es GitHub?</h2>
<p>Github es un portal creado para alojar el código de las aplicaciones de cualquier desarrollador, y que fue comprada por Microsoft en junio del 2018. La plataforma está creada para que los desarrolladores suban el código de sus aplicaciones y herramientas, y que como usuario no sólo puedas descargarte la aplicación, sino también entrar a su perfil para leer sobre ella o colaborar con su desarrollo.</p>

<h2 id="introducción-a-github">Introducción a GitHub</h2>

<ol>
  <li>
    <p>Creamos un repositorio en GitHub</p>

    <p><img src="/assets/images/github/1.png" alt="1" /></p>

    <p><img src="/assets/images/github/2.png" alt="2" /></p>
  </li>
  <li>
    <p>Clonamos el repositorio en nuestro ordenador</p>

    <p><img src="/assets/images/github/3.png" alt="3" /></p>
  </li>
  <li>
    <p>Creamos un archivo en nuestro ordenador</p>

    <p><img src="/assets/images/github/4.png" alt="4" /></p>
  </li>
  <li>
    <p>Subimos el archivo al repositorio</p>

    <p><img src="/assets/images/github/5.png" alt="5" /></p>

    <p><img src="/assets/images/github/6.png" alt="6" /></p>
  </li>
</ol>

<h2 id="introducción-a-markdown">Introducción a Markdown</h2>

<p>Markdown es un lenguaje de texto que nos permite escribir de forma sencilla y rápida, y que se convierte en HTML. Es un lenguaje muy utilizado en la creación de blogs, ya que permite escribir de forma rápida y sencilla, y que se convierte en HTML.</p>

<pre>
Aprender la *sintaxis básica* del **lenguaje de marcas** `Markdown` para estructura la información en nuestro documentos.

Para ello, hemos creado este fichero de la siguiente manera:
`touch markdown.md`
`nano markdown.md`

Con este lenguaje de marcas podemos usar:
* Titulo principal.
* Subtítulo.
* Párrafos.
* Listas (ordenadas y desordenadas) como esta y la siguiente.

1. Título.
2. SUbtítulo.
3. Párrafos.
4. Listas.

También podemos incluir un enlace, a una página externa [Debian](https://www.debian.org/index.es.html) o a otro fichero Markdown [aqui](README.md)

Podemos visualizar una imagen

![Icono Markdown](markdown.png)

Y también tablas.
| Elemento | Sintaxis |
| ----------- | ----------- |
| Título | #h1 |
| Código | `code` |
| Enlace | \[titulo]\(enlace) |
</pre>

<p>En mi <a href="https://github.com/Legnakra/Prueba-MariaJesus/blob/main/markdown.md">repositorio</a> podéis encontrar el resultado de este fichero.</p>

<h2 id="ramas-y-uniones">Ramas y uniones</h2>

<p>Las ramas son una forma de trabajar en paralelo en un proyecto, y que nos permite trabajar en diferentes versiones de un mismo proyecto. Las ramas se crean a partir de la rama principal, y se pueden fusionar con la rama principal cuando se considera que la rama ya está lista para ser integrada en el proyecto.</p>

<p>Para crear una rama, podemos hacerlo desde la interfaz de GitHub, o desde la terminal. En mi caso, he creado una rama desde la terminal, y he fusionado la rama con la rama principal.</p>

<ol>
  <li>
    <p>Creamos una rama que se llame primera en tu local, y ejecuta la instrucción necesaria para comprobar que se ha creado.</p>

    <p><img src="/assets/images/github/7.png" alt="7" /></p>
  </li>
  <li>Creamos un nuevo fichero en esta rama y fusiónalo con la principal. ¿Se ha producido conflicto?
    <ul>
      <li>Si, dado que las ramas independientes han editado el mismo fichero, se han realizado una serie de commits que github no puede decidir cuál es la versión que debe elegir y nos alerta de que debemos resolverlo.</li>
    </ul>
  </li>
  <li>
    <p>Borramos la rama primera.</p>

    <p><img src="/assets/images/github/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Creamos una rama que se llame segunda, y modifica un fichero en ella para producir un conflicto al unirlo a la rama principal.</p>

    <p><img src="/assets/images/github/9.png" alt="9" /></p>
  </li>
  <li>
    <p>Solucionamos el conflicto que has creado en el punto anterior y sincronizamos la rama segunda en el remoto.</p>

    <p><img src="/assets/images/github/10.png" alt="10" /></p>

    <p><img src="/assets/images/github/11.png" alt="11" /></p>
  </li>
</ol>

<h2 id="cómo-colaborar-en-un-proyecto-de-software-libre-qué-es-un-pull-request-pr">¿Cómo colaborar en un proyecto de software libre? ¿Qué es un Pull Request (PR)?</h2>

<p>Un Pull Request es una petición de extracción que se realiza a un repositorio de GitHub, y que se utiliza para solicitar que los cambios que se han realizado en una rama sean revisados y fusionados con la rama principal. Los Pull Request se utilizan para colaborar en proyectos de software libre, y para que los desarrolladores puedan revisar los cambios que se han realizado en el código.</p>

<ol>
  <li>
    <p>Nos dirigimos al repositorio en el que queremos hacer el PR, realizamos un fork del mismo.</p>

    <p><code>
 git clone git@github.com:Legnakra/prueba-pr-asir.git
 </code></p>
  </li>
  <li>
    <p>Tomamos el enlace de clonación por vía ssh y lo clonamos en nuestra máquina local. Como para este taller hemos clonado el repositorio de prueba de pr, el comando sería:</p>

    <p><img src="/assets/images/github/12.png" alt="12" /></p>
  </li>
  <li>
    <p>Creamos la nueva rama en la que vamos a realizar los cambios (en mi caso la he llamado maria). Una vez en ella, realizamos los cambios de la siguiente manera:</p>

    <p><code>
 nano mjar.md
 git add mjar.md
 nano README.md
 git commit -am "Ficheros modificados" 
 </code></p>

    <p><img src="/assets/images/github/13.png" alt="13" /></p>
  </li>
  <li>
    <p>Actualizamos los cambios.</p>

    <p><code>
 git push origin maria
 </code></p>

    <p><img src="/assets/images/github/14.png" alt="14" /></p>
  </li>
  <li>
    <p>Y por último, nos dirigimos al repositorio original para solicitar el Pull Request a su propietario y esperamos su validación de cambios, como podemos ver <a href="https://github.com/Legnakra/prueba-pr-asir/tree/main">aquí</a>.</p>
  </li>
</ol>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[¿Qué es GitHub? Github es un portal creado para alojar el código de las aplicaciones de cualquier desarrollador, y que fue comprada por Microsoft en junio del 2018. La plataforma está creada para que los desarrolladores suban el código de sus aplicaciones y herramientas, y que como usuario no sólo puedas descargarte la aplicación, sino también entrar a su perfil para leer sobre ella o colaborar con su desarrollo.]]></summary></entry><entry><title type="html">Virtualización en Linux</title><link href="/hlc+sri/2022/11/06/virtualizaci%C3%B3n.html" rel="alternate" type="text/html" title="Virtualización en Linux" /><published>2022-11-06T13:11:32+01:00</published><updated>2022-11-06T13:11:32+01:00</updated><id>/hlc+sri/2022/11/06/virtualizaci%C3%B3n</id><content type="html" xml:base="/hlc+sri/2022/11/06/virtualizaci%C3%B3n.html"><![CDATA[<h1 id="virtualización">Virtualización</h1>

<ol>
  <li>¿Qué es la virtualización?
    <ul>
      <li>Nos permite ejecutar más de un sistema virtual, y múltiples sistemas operativos y aplicaciones, en un solo servidor, aumentando el rendimiento del hardware disponible e incrementando el tiempo de procesamiento de un equipo, ya que habitualmente se desaprovecha gran parte.</li>
    </ul>
  </li>
  <li>¿Para qué se utiliza la virtualización?
    <ul>
      <li>Aislamiento e independencia de servicios y contenidos.</li>
      <li>Laboratorio de pruebas.</li>
      <li>Virtualización de arquitecturas de las que no se dispone.</li>
      <li>Creación de clúster de máquinas y sistemas distribuidos.</li>
      <li>Herramientas de aprendizajes</li>
    </ul>
  </li>
  <li>Ventajas de la virtualización:
    <ul>
      <li>Aumenta la seguridad.</li>
      <li>Reduce los costes.</li>
      <li>Mayor aprovechamiento de los recursos.</li>
      <li>Migración en vivo.</li>
      <li>Ahorro energético.</li>
    </ul>
  </li>
  <li>Desventajas de la virtualización:
    <ul>
      <li>Rendimento.</li>
      <li>Muchos sistemas dependen de un solo equipo.</li>
    </ul>
  </li>
  <li>Conceptos de virtualización
    <ul>
      <li>HOST: Es el equipo que ejecuta el sistema operativo y las aplicaciones.</li>
      <li>GUEST: Es el sistema operativo virtualizado.</li>
      <li>Hypervisor: Es el software que permite la virtualización.</li>
    </ul>
  </li>
  <li>Tipos de virtualización
    <ul>
      <li>Emulación: imita la arquitectura de un sistema al completo. Rendimiento bajo. Ejemplo: QEMU.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>
    <p>Virtualización de hardware: simula un hardware suficiente para permitir que un sistema operativo se ejecute de forma aislada. Rendimiento medio. Hipervisor de tipo 1. Ejemplo: VMware.</p>
  </li>
  <li>
    <p>Virtualización completa: El hipervisor simula un hardware suficiente para permitir que un sistema operativo no adaptado se ejecute de forma aislada. HyperVisor de tipo 2. Ejemplo: VirtualBox.</p>
  </li>
  <li>
    <p>Virtualización parcial: El hipervisor ofrece un interfaz especial para acceder a los recursos. Ejemplo: Xen.</p>
  </li>
  <li>
    <p>Virtualización ligera: también llamada virtualización basada en contenedores. Sobre el núcleo del sistema operativo se ejecuta una capa de virtualización que permite que existan múltiples instancias aisladas de espacios de usuario (contenedor). Ejemplo: Docker.</p>
    <ul>
      <li>Tipos:
        <ul>
          <li>Contenedores de Sistemas: El uso que se hace de ellos es muy similar al que hacemos sobre una máquina virtual: se accede a ellos (normalmente por ssh), se instalan servicios, se actualizan, ejecutan un conjunto de procesos, . . . Ejemplo: LXC(Linux Container).</li>
          <li>Contenedores de Aplicación: Se suelen usar para el despliegue de aplicaciones web Ejemplo: Docker, Podman, . . .</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>¿Qué es un QEMU?
    <ul>
      <li>Es un emulador genérico y de código abierto de máquinas virtuales, permitiendo ejecutar sistemas operativos de una determinada arquitectura en una máquina con otra arquitectura distinta.</li>
    </ul>
  </li>
  <li>¿Que es KVM?
    <ul>
      <li>Es un hipervisor de tipo 1 que permite la virtualización de hardware completo. Es un módulo del núcleo de Linux que que contienen las extensiones de virtualización Intel VT o AMD-V.</li>
    </ul>
  </li>
  <li>¿Qué es un Libvirt?
    <ul>
      <li>Es una biblioteca de software que proporciona una API para la gestión de máquinas virtuales, redes, almacenamiento, etc. Es una capa de abstracción que permite la gestión de máquinas virtuales independientemente del hipervisor que se utilice.</li>
    </ul>
  </li>
  <li>Mecanismos de conexión a Libvirto
    <ul>
      <li>Local no provolegiado: Se conecta a través de un socket Unix. <em>qemu:///session</em></li>
      <li>Remoto: Se conecta a través de un socket Unix. <em>qemu+ssh://user@host/system</em></li>
      <li>Acceso local privilegiado: Se acceden a las máquinas virtuales del sistema. <em>qemu:///session</em></li>
    </ul>
  </li>
  <li>Aplicaciones para usar Libvirt
    <ul>
      <li>virsh: Interfaz de línea de comandos. <em>virsh -c qemu:///session</em></li>
      <li>virt-manager: Es una interfaz gráfica para la gestión de máquinas virtuales. <em>virt-manager -c qemu:///session</em></li>
      <li>virtinst: Es una herramienta para la creación de máquinas virtuales. <em>virt-install -c qemu:///session</em></li>
      <li>virt-viewer: Es una herramienta para la gestión de máquinas virtuales. <em>virt-viewer -c qemu:///session</em></li>
      <li>gnome-boxes: Es una herramienta para la gestión de máquinas virtuales. <em>gnome-boxes -c qemu:///session</em></li>
    </ul>
  </li>
  <li>¿Qué es LXC?
    <ul>
      <li>Es un sistema de contenedores de Linux que permite la creación y gestión de contenedores de Linux. Es un sistema de virtualización ligera que permite la creación de contenedores de Linux.</li>
    </ul>
  </li>
  <li>¿Qué componentes tiene LXC?
    <ul>
      <li>Grupos de control de cgroups: Es un subsistema del núcleo de Linux que permite la gestión de recursos de un grupo de procesos.</li>
      <li>Espacio de nombres namespaces que proporcionan un punto de vista diferente a un proceso (interfaces de red, procesos, usuarios, etc.).</li>
    </ul>
  </li>
  <li>¿A qué pertenecen los contenedores de LXC?
    <ul>
      <li>A los contenedores de sistemas. Su gestión y ciclo de vida es similar al de una máquina virtual tradicional. Está mantenido por Canonical y
la página oficial es linuxcontainers.org.</li>
    </ul>
  </li>
  <li>¿Qué es LXD?
    <ul>
      <li>Es una herramienta de gestión de los contenedores y máquinas virtuales del sistema operativo Linux, desarrollada por Canonical.</li>
    </ul>
  </li>
</ol>

<h2 id="comandos">COMANDOS</h2>

<ol>
  <li>Comandos de virsh
    <ul>
      <li>virsh list: Lista las máquinas virtuales.</li>
      <li>virsh list –all: Lista todas las máquinas virtuales.</li>
      <li>virsh start <nombre>: Inicia una máquina virtual.</nombre></li>
      <li>virsh shutdown <nombre>: Apaga una máquina virtual.</nombre></li>
      <li>virsh destroy <nombre>: Apaga una máquina virtual.</nombre></li>
      <li>virsh undefine <nombre>: Elimina una máquina virtual.</nombre></li>
      <li>virsh define <nombre>: Crea una máquina virtual.</nombre></li>
      <li>virsh edit <nombre>: Edita una máquina virtual.</nombre></li>
      <li>virsh domifaddr <nombre>: Muestra la dirección IP de una máquina virtual.</nombre></li>
      <li>virsh domiflist <nombre>: Muestra las interfaces de red de una máquina virtual.</nombre></li>
      <li>virsh dominfo <nombre>: Muestra información de una máquina virtual.</nombre></li>
      <li>virsh domxml <nombre>: Muestra el XML de una máquina virtual.</nombre></li>
      <li>virsh dumpxml <nombre>: Muestra el XML de una máquina virtual.</nombre></li>
      <li>virsh net-list: Lista las redes virtuales.</li>
      <li>virsh net-start <nombre>: Inicia una red virtual.</nombre></li>
      <li>virsh net-destroy <nombre>: Apaga una red virtual.</nombre></li>
      <li>virsh net-undefine <nombre>: Elimina una red virtual.</nombre></li>
      <li>virsh net-define <nombre>: Crea una red virtual.</nombre></li>
      <li>virsh net-edit <nombre>: Edita una red virtual.</nombre></li>
      <li>virsh net-dumpxml <nombre>: Muestra el XML de una red virtual.</nombre></li>
      <li>virsh net-info <nombre>: Muestra información de una red virtual.</nombre></li>
      <li>virsh net-autostart <nombre>: Inicia una red virtual al arrancar el sistema.</nombre></li>
      <li>virsh net-autostart –disable <nombre>: No inicia una red virtual al arrancar el sistema.</nombre></li>
    </ul>
  </li>
  <li>Comandos de virt-manager
    <ul>
      <li>virt-manager: Inicia la interfaz gráfica de gestión de máquinas virtuales.</li>
      <li>virt-install: Crea una máquina virtual.</li>
      <li>virt-viewer: Gestiona una máquina virtual.</li>
    </ul>
  </li>
  <li>Comandos de LXC
    <ul>
      <li>lxc-list: Lista los contenedores.</li>
      <li>lxc-start: Inicia un contenedor.</li>
      <li>lxc-stop: Apaga un contenedor.</li>
      <li>lxc-destroy: Elimina un contenedor.</li>
      <li>lxc-create: Crea un contenedor.</li>
      <li>lxc-attach: Accede a un contenedor.</li>
      <li>lxc-console: Accede a la consola de un contenedor.</li>
      <li>lxc-info: Muestra información de un contenedor.</li>
    </ul>
  </li>
  <li>Comandos virt
    <ul>
      <li>virt-clone: Clona una máquina virtual.</li>
      <li>virt-install: Crea una máquina virtual.</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="hlc+sri" /><summary type="html"><![CDATA[Virtualización]]></summary></entry><entry><title type="html">Compilar dos2unix partiendo del código fuente</title><link href="/aso/2022/10/12/compilacion-paquete-makefile.html" rel="alternate" type="text/html" title="Compilar dos2unix partiendo del código fuente" /><published>2022-10-12T11:17:16+02:00</published><updated>2022-10-12T11:17:16+02:00</updated><id>/aso/2022/10/12/compilacion-paquete-makefile</id><content type="html" xml:base="/aso/2022/10/12/compilacion-paquete-makefile.html"><![CDATA[<p>Los lenguajes de programación compilados, no necesitan de un intérprete, si no que necesitan compiladores y linkers. Los lenguajes de programación compilados no requieren que exista un programa que los vaya leyendo, interprete, si no que, antes de ejecutarse, deben ser traducidos a un lenguaje que la máquina sea capaz de entender directamente, sin intermediarios. En ese proceso se llama al compilador y al enlazador o linker.</p>

<p>El comando que he seleccionado es dos2unix, un comando que convierte un archivo de texto DOS a formato UNIX.</p>

<h2 id="pasos-de-instalación">Pasos de instalación</h2>

<ol>
  <li>Nos descargamos el código fuente:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt source dos2unix
</code></pre></div>    </div>
  </li>
  <li>Descomprimimos el archivo con extension .orig.tar.xz.
    <ul>
      <li>x: Para extraer el archivo.</li>
      <li>v: Para mostrar la descripción detallada del progreso de la compresión.</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xv dos2unix_7.4.1.orig.tar.gz
</code></pre></div></div>

<p><img src="/images/Makefile/paso1" alt="paso1" /></p>

<p><img src="/images/Makefile/paso2" alt="paso2" /></p>

<ol>
  <li>Nos dirigimos al directorio que hemos descomprimido y ejecutamos lo siguiente:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd dos2unix-7.4.1/
make
</code></pre></div></div>

<p><img src="/images/Makefile/paso2-2" alt="paso2-2" /></p>

<ol>
  <li>Realizamos la instalación con la entrada del comando:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make install
</code></pre></div></div>

<p><img src="/images/Makefile/paso3" alt="paso3" /></p>

<ol>
  <li>Realizamos la comprobación de que el paquete se ha instalado correctamente.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dos2unix --version
whereis dos2unix
</code></pre></div></div>

<p><img src="/images/Makefile/paso4" alt="paso4" /></p>

<p><img src="/images/Makefile/paso5" alt="paso5" /></p>

<h2 id="pasos-de-instalación-1">Pasos de instalación</h2>

<p>Para realizar una desinstalación limpia del paquete deberemos realizar los siguientes pasos</p>

<ol>
  <li>Nos dirigimos al directorio donde se encuentra nuestro fichero Makefile.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd dos2unix-7.4.1/
ls
</code></pre></div>    </div>
  </li>
</ol>

<p><img src="/images/Makefile/paso5-2" alt="paso5-2" /></p>

<ol>
  <li>Desde allí, ejecutamos lo siguiente en nuestra consola y se realizará una desinstalación limpia.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo make uninstall
</code></pre></div></div>

<p><img src="/images/Makefile/paso6" alt="paso6" /></p>

<ol>
  <li>Comprobamos que ciertamente, el paquete ha sido desinstalado de nuestra maquina.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whereis dos2unix
apt policy dos2unix
</code></pre></div>    </div>
  </li>
</ol>

<p><img src="/images/Makefile/paso7" alt="paso7" /></p>]]></content><author><name></name></author><category term="ASO" /><summary type="html"><![CDATA[Los lenguajes de programación compilados, no necesitan de un intérprete, si no que necesitan compiladores y linkers. Los lenguajes de programación compilados no requieren que exista un programa que los vaya leyendo, interprete, si no que, antes de ejecutarse, deben ser traducidos a un lenguaje que la máquina sea capaz de entender directamente, sin intermediarios. En ese proceso se llama al compilador y al enlazador o linker.]]></summary></entry><entry><title type="html">Prueba: Introducción a la implantación de aplicaciones web</title><link href="/prueba/2022/10/10/prueba.html" rel="alternate" type="text/html" title="Prueba: Introducción a la implantación de aplicaciones web" /><published>2022-10-10T13:11:16+02:00</published><updated>2022-10-10T13:11:16+02:00</updated><id>/prueba/2022/10/10/prueba</id><content type="html" xml:base="/prueba/2022/10/10/prueba.html"><![CDATA[<h2 id="nombre-completo">Nombre completo:</h2>
<p>María Jesús Alloza Rodríguez</p>

<p><img src="https://img2.freepng.es/20171220/kre/linux-logo-png-5a3a1fe7d94070.02257309151375869588993545.jpg" alt="imagen" /></p>]]></content><author><name></name></author><category term="prueba" /><summary type="html"><![CDATA[Nombre completo: María Jesús Alloza Rodríguez]]></summary></entry><entry><title type="html">¿Qué diferencia hay entre exploit, vulnerabilidad y payload?</title><link href="/seguridad/2022/10/10/payload.html" rel="alternate" type="text/html" title="¿Qué diferencia hay entre exploit, vulnerabilidad y payload?" /><published>2022-10-10T10:40:32+02:00</published><updated>2022-10-10T10:40:32+02:00</updated><id>/seguridad/2022/10/10/payload</id><content type="html" xml:base="/seguridad/2022/10/10/payload.html"><![CDATA[<p>En seguridad informática es muy habitual confundir estos tres conceptos, y por ello vamos a ver que es un exploit, una vulnerabilidad y un payload.</p>

<p>Debemos tener en cuenta que estos términos son utilizados principalmente cuando realizamos pruebas de penetración o ejercicios de hacking ético. 
¿En qué parte del hacking podemos encontrarnos con estos términos?
Lo vemos en la fase de explotación, es decir, una vez que conocemos las características del sistema que tienen las máquinas a las que queremos acceder, podemos investigar si existen vulnerabilidades para esos sistemas, y en el caso afirmativo, (que de costumbre es que sí) sería el momento de buscar algún exploit para romper dicha vulnerabilidad.</p>

<p>Pero vamos a ver cada uno de ellos y como se interrelacionan</p>

<h2 id="qué-es-un-exploit">¿Qué es un exploit?</h2>

<p>Un exploit es la herramienta(software) con la cual el hacker aprovechará para comprometer, romper y explotar una vulnerabilidad de seguridad del sistema para sus propios fines.</p>

<p>Esto sucede ya que algunos fabricantes suelen tener fallas de seguridad en sus productos, como por el ejemplo el exploit de día cero, denominado así cuando el desarrollador del producto desconoce de una vulnerabilidad que solo el ciberdelincuente conoce.</p>

<p>Los ciberdelincuentes aplican ingeniería inversa para analizar toda la programación de dicho sistema, de este modo pueden detectar algún error de código y explotarlo.</p>

<h3 id="tipos">Tipos</h3>

<ul>
  <li><strong>Exploit remoto</strong>:
Se realizan mediante una conexión víctima con el atacante, todo mediante una red de comunicaciones.
Por ejemplo, una conexión por internet, por lo general este tipo de ataque suele hacerse mediante el envío y la instalación del software malicioso en el dispositivo.</li>
</ul>

<p><img src="https://assets.website-files.com/5ff66329429d880392f6cba2/61c43d47dccfe68a303551d4_exploit%20Preview.png" alt="Exploit" /></p>

<ul>
  <li>
    <p><strong>Exploit local</strong>:
La principal diferencia con el anterior tipo es que se necesita acceso al sistema antes de efectuar un ataque de explotación. Se necesita burlar al sistema para escalar privilegios en el sistema, donde el ciberdelincuente podría controlar al final todo el sistema.</p>
  </li>
  <li>
    <p><strong>Exploit en cliente</strong>:
Para realizar este tipo de ataques suele influir mucho el phishing para poder comprometer la máquina víctima con un exploit.
Esto se realiza principalmente en las estaciones de trabajo de una organización atacando los softwares de ofimática mediante envío de malware por correos electrónicos.
La mayoría de veces suele ser un éxito, ya que algunos cortafuegos o antivirus dan por alto estos ataques, de este modo los ciberdelincuentes empiezan a escalar privilegios hasta obtener el control total del sistema, aquí podemos llegar a la conclusión de que las víctimas dan el acceso.</p>
  </li>
</ul>

<p>Un claro ejemplo explot fue el llamado Eternal Blue, que se aprovechó de la vulnerabilidad en el protocolo SMB en la versión 1, que estaba presente en todos los sistemas operativos de windows, desde su versión 95 al 10. Es capaz de brindarnos control total de una máquina, otorgando la capacidad de ejecutar código a nivel administrador.</p>

<h2 id="qué-es-la-vulnerabilidad">¿Qué es la vulnerabilidad?</h2>

<p><img src="https://netcloudengineering.com/wp-content/uploads/2017/06/vulnerabilidades-ciberseguridad.jpg" alt="vulnerabilidad" /></p>

<p>Una vulnerabilidad  es una debilidad o un error en el código de un sistema que puede ser explotado para obtener acceso no autorizado o realizar acciones no autorizadas en un sistema informático comprometer la seguridad permitiendo a los atacantes ejecutar código, acceder a la memoria de un sistema, instalar malware y robar, destruir o modificar datos confidenciales.</p>

<h3 id="ejemplos-de-vulnerabilidad">Ejemplos de vulnerabilidad</h3>

<ul>
  <li>
    <p><strong>Autenticación rota</strong>:
En la autenticación rota, cada vez que un usuario inicia sesión en su cuenta, se crea una identificación de sesión, y esa identificación de sesión solo se permite para esa cuenta en particular. En caso de que la aplicación web no esté diseñada de forma segura, el atacante puede usar varias técnicas dadas:</p>

    <ul>
      <li>Relleno de credenciales</li>
      <li>Contraseñas sin cifrar</li>
      <li>Tiempos de espera de sesión mal configurados</li>
    </ul>
  </li>
  <li>
    <p><strong>Inyección de SQL</strong>:
Es un tipo de vulnerabilidad en la que un atacante inserta su propio código en un sitio web con el fin acceder a datos protegidos o sensibles.</p>
  </li>
  <li>
    <p><strong>Secuencias de comandos entre sitios:</strong>
Son un tipo de vulnerabilidad de los sitios web, que permite que los atacantes coloquen secuencias de comandos maliciosas en páginas web.</p>
  </li>
</ul>

<p><img src="https://academy.avast.com/hs-fs/hubfs/What_is_scross-site_scripting-1.png?width=600&amp;name=What_is_scross-site_scripting-1.png" alt="Vulnerabilidad" /></p>

<ul>
  <li>
    <p><strong>Falsificación de solicitudes entre sitios</strong>:
Es un ataque contra aplicaciones hospedadas en web en las que una aplicación web malintencionada puede influir en la interacción entre un explorador cliente y una aplicación web que confía en ese explorador.</p>
  </li>
  <li>
    <p><strong>Configuración incorrecta de seguridad</strong>:
Son controles de seguridad que se configuran incorrectamente o se dejan inseguros, lo que pone en riesgo sus sistemas y datos.</p>
  </li>
</ul>

<h2 id="qué-es-el-payload">¿Qué es el payload?</h2>

<p>En informática, un payload es una carga de capacidad en un paquete o en otros medios de transmisión. Dicho término está arraigado en el mundo militar y a veces está asociado con la capacidad de código malicioso con el fin de dañar. Podemos encontrarnos con data payloads o malware payload. Del primero podemos decir que se produce cuando el dato es enviado por un destino de comunicación, y el segundo es un código malicioso que pretende hacer daño al objetivo señalado.</p>

<p><img src="https://esgeeks.com/media/2022/03/Concepto-payload-carga-útil.jpg" alt="payload" /></p>

<h3 id="ejemplos">Ejemplos</h3>

<p>Un ejemplo de <strong>Data pyload</strong> sería a través de un paquete IP. Este puede contener un payload con comandos emitidos por el último usuario, como una solicitud de un contenido web. Aunque, a menudo, consiste en transmitir datos por un servidor en respuesta a un usuario solicitante.  Los límites de los payloads en las PDUs (Protocol Data Unit) son con frecuencia especificados por un protocolo, y el tamaño máximo para un PDU individual raramente cambia.</p>

<p><img src="https://cdn-icons-png.flaticon.com/512/1995/1995756.png" alt="icono" /></p>

<p>El tamaño máximo de payloads por paquetes de IP está limitado por el campo de longitud total (total length) en la cabecera del paquete IP; este campo tiene una longitud de 16 bits, lo que significa que el valor máximo posible es 2¹⁶ y el  valor más alto posible para la longitud del paquete es de 65535, menos del número de bytes que requiere un encabezado de paquete. El MTU para paquetes IP varía por el sistema y la red. La IP original estándar especifica que todos los hosts deben ser capaces de aceptar paquetes tan largos como sean de 576 bytes con los payload data de 512 bytes y los 64 de la cabecera. El valor predeterminado MTU actualmente aceptado para paquetes IPv4 es de 1500 bytes por la compatibilidad con los segmentos Ethernet.</p>

<p>En cuanto a un <strong>payload malicioso</strong> (o malware payload) podemos poner como ejemplo todos aquellos correos electrónicos o incluso SMS que contienen un virus autorreplicante alojado en un enlace. Los atacantes eluden las defensas, mantienen la carga y atacan a la víctima. Esta vía, la de métodos de distribución comprobados, como los emails de suplantación de identidad y los gusanos, pueden adaptarse. Mientras no tenga límites específicos para la capacidad máxima de carga, los actores maliciosos intentarán mantenerlos en un tamaño razonable para evitar ser detectado por herramientas de detección de malware.</p>

<p>Casi ningún tipo de malware puede ser incorporado dentro de un payload con la ayuda de un generador de payload para crear un malware ejecutable. Una vez entregado y ejecutado, el proceso de distribución infecta al sistema objetivo, a menos que haya un sistema de detección de malware. Una carga útil puede contener cualquier tipo de malware, incluido el ransomware, el reclutamiento de botnets u otros tipos de virus o gusanos.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Ya con este contexto, podemos decir que un exploit es un pequeño programa o un pedazo de código que se aprovecha o explota de una vulnerabilidad encontrada, mientras que un payload viene siendo esa acción que queremos hacer una vez que hemos explotado la vulnerabilidad.</p>

<p>Tanto el exploit como el payload son pedazos de código que funcionan en conjunto para un fin, que en este caso, sería explotar la vulnerabilidad encontrada.</p>

<p>Y también cabe decir que dentro del mundo del hacking, existen varias herramientas automatizadas, como lo es Metaexploit, que en la práctica nos ayudan a comprender mucho mejor como funciona este par de términos, ya que no necesariamente un exploit está amarrado a un payload y viceversa. Sino que un exploit puede usar varios payloads a fin de tener una shellcon privilegios, crear usuarios, etc.</p>]]></content><author><name></name></author><category term="seguridad" /><summary type="html"><![CDATA[En seguridad informática es muy habitual confundir estos tres conceptos, y por ello vamos a ver que es un exploit, una vulnerabilidad y un payload.]]></summary></entry><entry><title type="html">Introducción a la programación Python</title><link href="/python/2022/09/29/inicio-python.html" rel="alternate" type="text/html" title="Introducción a la programación Python" /><published>2022-09-29T17:45:16+02:00</published><updated>2022-09-29T17:45:16+02:00</updated><id>/python/2022/09/29/inicio-python</id><content type="html" xml:base="/python/2022/09/29/inicio-python.html"><![CDATA[<h2 id="ejercicio-1">Ejercicio 1</h2>
<p>Diseñar el algoritmo correspondiente a un programa que lea el valor correspondiente a una distancia en millas marinas y las escriba expresadas en metros.</p>

<h3 id="análisis">Análisis:</h3>
<p>Problema: Tenemos que leer una cantidad de millas marinas y calcular su valor en metros.
Entrada: millas(entero).
Salida: metros (entero).</p>
<h3 id="diseño">Diseño:</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Leer distancia_millas (distancia_millas).
2. Convertir millas marinas a metros (distancia_millas*1852).
3. Mostrar el resultado.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Leer distancia_millas (distancia_millas).
distancia_millas = float(input("Distancia en millas marinas: "))

2. Convertir millas marinas a metros (distancia_millas*1852).
metros= distancia_millas*1852

3. Mostrar el resultado en metros.
print("La distancia en metros es de: ",metros, "metros")
</code></pre></div></div>

<h2 id="ejercicio-2">Ejercicio 2</h2>
<p>Escribir un programa que pida al usuario su peso (en kg) y estatura (en metros), calcule el índice de masa corporal y lo almacene en una variable, e imprima por pantalla la frase “Tu índice de masa corporal es…” y el resultado.</p>

<h3 id="análisis-1">Análisis:</h3>
<p>Problema: Tenemos que calcular el IMC (índice de masa corporal) dados el peso (kg) y la estatura (m).
Entrada: peso (entero), estatura (entero).
Salida: imc (entero).</p>

<h3 id="diseño-1">Diseño:</h3>
<p>1.Leer peso (peso) y estatura (estatura).
2.Calcular el IMC (imc = peso/(estatura**2,2).
3.Mostrar el resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.Leer peso (peso) y estatura (estatura).

peso = input("¿Cuál es tu peso?(kg): ")
estatura = input("¿Cuál es tu estatura (metros): ")

2.Calcular el IMC (imc = peso/(estatura**2,2).
imc = round(float(peso)/float(estatura)**2,2)

3.Mostrar el resultado.
print("Tu índice de masa corporal es " + str(imc))
</code></pre></div></div>

<h2 id="ejercicio-3">Ejercicio 3</h2>
<p>Una juguetería tiene mucho éxito en dos de sus productos: payasos y muñecas. Suele hacer venta por correo y la empresa de logística les cobra por peso de cada paquete así que deben calcular el peso de los payasos y muñecas que saldrán en cada paquete a demanda. Cada payaso pesa 112 g y cada muñeca 75 g. Escribir un programa que lea el número de payasos y muñecas vendidos en el último pedido y calcule el peso total del paquete que será enviado. Además se nos pide el precio que se cobra por gramo, , y se nos mostrará el total de dinero que necesitamos para realizar el envío.</p>

<h3 id="análisis-2">Análisis</h3>
<p>Problema: Tenemos que calcular el peso del último pedido de payasos y muñecas, y el precio por gramo
al realizar el envío.
Entrada: payasos (real), muñecas (real), peso_payaso (real), peso_muñeca (real).
Salida:peso_total (real), precio_envío (entero).</p>

<h3 id="diseño-2">Diseño:</h3>
<p>1.Leer cantidad de payasos (payasos)
2.Leer cantidad de muñecas (muñecas)
3.Calcular el peso del pedido (peso_total = peso_payaso<em>payaso + peso_muñeca</em>muñeca)
4.Leer el precio del envío por gramo.
5.Calcular precio del envío.
6.Mostrar el resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
peso_payaso = 112
peso_muñeca = 75

1.Leer cantidad de payasos (payasos)
payasos = int(input("Introduce el número de payasos a enviar: "))

2.Leer cantidad de muñecas (muñecas)
muñecas = int(input("Introduce el número de muñecas a enviar: "))

3.Calcular el peso del pedido (peso_total = peso_payaso*payaso + peso_muñeca*muñeca)
peso_total = peso_payaso * payasos + peso_muñeca * muñecas

4.Leer el precio del envío por gramo.
precio = float(input("El precio por gramo del envío es de: "))

5.Calcular precio del envío.
precio_envio = peso_total * precio

6.Mostrar el resultado.
print("El precio total del envío es de: ",precio_envio,"€." )
</code></pre></div></div>

<h2 id="ejercicio-4">Ejercicio 4</h2>
<p>Diseñar el algoritmo correspondiente a un programa que pida el total de kilómetros recorridos, el precio de la gasolina (por litro), el consumo del coche (litros/100 km) y nos muestre la siguiente información:</p>
<ul>
  <li>El total de litros de gasolina que ha gastado en el trayecto.</li>
  <li>¿Cuánto dinero te ha costado la gasolina?</li>
</ul>

<h3 id="análisis-3">Análisis</h3>
<p>Problema:Tenemos que calcular el consumo de un coche, el consumo en un recorrido con determinados kilómetros y el coste del trayecto.
Entrada:kilometros_recorridos (entero), precio_gasolina (entero), consumo_coche (entero).
Salida: total_litros (entero), consumo_gasolina (entero), gasto_gasolina (entero).</p>

<h3 id="diseño-3">Diseño</h3>
<p>1.Leer kilómetros totales recorridos.
2.Leer precio gasolina.
3.Leer consumo del coche.
4.Calcular litros consumidos en el recorrido.
5.Calcular coste de gasolina en el recorrido.
6.Mostrar resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.Leer kilómetros totales recorridos.
kilometros_recorridos = float(input("Los kilómetros recorridos son: "))

2.Leer precio gasolina.
precio_gasolina = float(input("El precio de la gasolina (por litro) es: "))

3.Leer consumo del coche.
consumo_coche= float(input("El coche consume (litros/100km): "))

4.Calcular litros consumidos en el recorrido.
consumo_gasolina =consumo_coche / 100 * kilometros_recorridos
print("El coche ha gastado en ",kilometros_recorridos," un total de",consumo_gasolina,"litros de gasolina.")

5.Calcular coste de gasolina en el recorrido.
gasto_gasolina = consumo_gasolina*precio_gasolina

6.Mostrar resultado.
print("El gasto total de gasolina es de: ",gasto_gasolina,"€.")
</code></pre></div></div>

<h1 id="ejercicio-5">Ejercicio 5</h1>
<p>Suponiendo que una paella se puede cocinar exclusivamente con arroz y gambas, y que para cada cuatro personas se utiliza medio kilo de arroz y un cuarto de kilo de gambas, escribir un programa que pida por pantalla el número de comensales para la paella, el precio por kilo de los ingredientes y muestre las cantidades de los ingredientes necesarios y el coste de la misma.</p>

<h3 id="análisis-4">Análisis</h3>
<p>Problema:Te pide el número de comensales para calcular el precio por kilo de los ingredientes para una paella, muestre las cantidades y el coste de la misma.
Entrada: comensales (real), cantidad_arroz (entero), cantidad_gambas (entero), precio_gamba(entero),precio_arroz(entero).
Salida:coste_paella (entero).</p>

<h3 id="diseño-4">Diseño</h3>
<p>1.Leer el número de comensales.
2.Calcular ingredientes necesarios para la paella.
3.Leer precios del arroz y las gambas.
4.Calcular el coste total de la paella.
5.Mostrar resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.Leer el número de comensales.
comensales = float(input("El número total de comensales es: "))

2.Calcular ingredientes necesarios para la paella.
cantidad_arroz= comensales* 0.5/4
cantidad_gambas=comensales* 0.25/4
print("Vamos a necesitar ",cantidad_arroz, "gramos de arroz.")
print("Vamos a necesitar ",cantidad_gambas, "gramos de gambas.")

3.Leer precios del arroz y las gambas.
precio_arroz= float(input("El precio del arroz(kg) es de: "))
precio_gamba= float(input("El precio de las gambas(kg) es de: "))

4.Calcular el coste total de la paella.
coste_paella= (cantidad_arroz*precio_arroz)+(cantidad_gambas*precio_gamba)

5.Mostrar resultado.
print("La paella cuesta: ",coste_paella, "€.")
</code></pre></div></div>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[Ejercicio 1 Diseñar el algoritmo correspondiente a un programa que lea el valor correspondiente a una distancia en millas marinas y las escriba expresadas en metros.]]></summary></entry><entry><title type="html">Crear un sitio web estático con Jekyll</title><link href="/jekyll/2022/09/29/origen.html" rel="alternate" type="text/html" title="Crear un sitio web estático con Jekyll" /><published>2022-09-29T17:45:16+02:00</published><updated>2022-09-29T17:45:16+02:00</updated><id>/jekyll/2022/09/29/origen</id><content type="html" xml:base="/jekyll/2022/09/29/origen.html"><![CDATA[<p>En este post hablaremos de como crear un sitio web estático con <strong>Jekyll</strong>, un generador de sitios web estáticos.</p>

<p><img src="https://jekyllrb.com/img/jekyll-og.png" alt="Jekyll" /></p>

<h2 id="ventajas-y-desventajas">Ventajas y desventajas.</h2>
<p>En primer lugar, este tipo de sitios no requieren un hosting con soporte, ya que está compuesto de archivos HTML, CSS, y JavaScript.</p>

<p>Otras ventajas que nos encontramos es su velocodad de carga y el ahorro de costos del hosting, ya que existen servicios gratuitos para ello.</p>

<p>En cuanto a desventajas, nos encontramos que no podemos editar o crear en línea, e incluso no es posible la creación de usuarios.</p>

<h2 id="preparando-el-escenario">Preparando el escenario</h2>
<p>Para ello, vamos a realizar la instalación tanto de <strong>Jekyll</strong> y de <strong>Ruby</strong> de la siguiente manera:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ apt install jekyll
$ apt install jekyll bundler
$ apt install ruby
</code></pre></div></div>

<p>Creamos el directorio, en el que vamos a alojar nuestra web estática</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir /directorio/web
</code></pre></div></div>

<p>Y ejecutamos dentro del directorio web el comando necesario para crear nuestro sitio web estático:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ jekyll new sitio-jekyll
</code></pre></div></div>

<p>Al ejecutar el comando, se nos creará el directorio <code class="language-plaintext highlighter-rouge">sitio-jekyll</code> con la siguiente estructura:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sitio-jekyll/
  _posts/
    2022-09-29-welcome-to-jekyll.markdown
  _config.yml
  about.md
  Gemfile
  index.md
</code></pre></div></div>

<h2 id="para-qué-sirve-lo-que-hemos-creado">¿Para qué sirve lo que hemos creado?</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_posts/</code>: En este directorio se almacenarán los artículos por orden cronológico de nuestro sitio web.</li>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code>: En dicho fichero encontraremos las configuraciones que controlarán la forma en la que se generará la web y los artículos.</li>
  <li><code class="language-plaintext highlighter-rouge">Gemfile</code>: Este fichero aloja las definiciones de las dependencias o librerías adicionales de <strong>Ruby</strong> que necesitaremos para crear el sitio web (lo que sería el <code class="language-plaintext highlighter-rouge">requirements.txt</code>de <strong>Python</strong>).</li>
  <li><code class="language-plaintext highlighter-rouge">.md</code>: Los ficheros que componen el contenido de las páginas y los artículos tienen la extensión <code class="language-plaintext highlighter-rouge">markdown</code>, y luego es <strong>Jekyll</strong> es que se encargade transformar el código <strong>HTML</strong> a la hora de la compilación.</li>
</ul>

<h2 id="ejecutando-el-sitio">Ejecutando el sitio</h2>
<p>Para esto, ejecutaremos en la terminal lo siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /directorio/web/sitio-jekyll
$ bundle exec jekyll serve
</code></pre></div></div>

<p>Tras esto, podremos ver el sitio generado en nuestro navegador, de forma local a la dirección <em>http://localhost:4000/</em></p>

<h2 id="conclusión">Conclusión</h2>
<p>A partir de ciertas herramientas, podemos desplegar una página web de forma estática, con estilo, <strong>CSS</strong>, etc… de forma rápida, sin costes y de forma eficaz.</p>]]></content><author><name></name></author><category term="jekyll" /><summary type="html"><![CDATA[En este post hablaremos de como crear un sitio web estático con Jekyll, un generador de sitios web estáticos.]]></summary></entry><entry><title type="html">Bienvenid@</title><link href="/bienvenida/2022/09/29/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Bienvenid@" /><published>2022-09-29T17:45:16+02:00</published><updated>2022-09-29T17:45:16+02:00</updated><id>/bienvenida/2022/09/29/welcome-to-jekyll</id><content type="html" xml:base="/bienvenida/2022/09/29/welcome-to-jekyll.html"><![CDATA[<p>Bienvenidos SysMaria, mi pequeño blog.</p>

<p>Soy Diplomada en Magisterio con la especialidad de Música y violín.</p>

<p>Siempre me ha llamado la atención el mundo de la tecnología, he «cacharreado» con cualquier aparatejo que caía en mis manos. Después de una larga temporada luchando por una plaza, conseguí entrar en Administración de Sistemas Informáticos en Red (ASIR) en el I.E.S. Gonzalo Nazareno de Dos Hermanas (Sevilla).</p>

<p>Y este será mi espacio, en el que expondré mis prácticas y mis pequeños proyectos personales.</p>

<p>En mi perfil de <a href="https://github.com/Legnakra">GitHub</a> tengo subidos proyectos del primer año e iré añadiendo los de este curso.</p>]]></content><author><name></name></author><category term="bienvenida" /><summary type="html"><![CDATA[Bienvenidos SysMaria, mi pequeño blog.]]></summary></entry><entry><title type="html">Infraestructura como código</title><link href="/sri/2022/09/29/infraestructura.html" rel="alternate" type="text/html" title="Infraestructura como código" /><published>2022-09-29T17:45:16+02:00</published><updated>2022-09-29T17:45:16+02:00</updated><id>/sri/2022/09/29/infraestructura</id><content type="html" xml:base="/sri/2022/09/29/infraestructura.html"><![CDATA[<h2 id="ansible">Ansible</h2>
<h3 id="playbook-sencillo">Playbook sencillo</h3>

<p>Vamos a realizar un pequeño ejemplo de cómo podemos automatizar la instalación de un servidor web en un servidor remoto. Para ello, vamos a utilizar Ansible.</p>

<ol>
  <li>
    <p>Creamos <em>site.yml</em>.</p>

    <p><code></code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - hosts: all
     become: true
     tasks:

 # Actualizamos paquetes
 - name: Actualizamos el sistema
   apt: update_cache=yes upgrade=yes

 # Instalar paquetes
 - name: "Instalar paquetes con apt"
   apt: # Aquí tienes que poner lo necesario para instalar git y apache2
    pkg:
     - git
     - apache2

   # Copia un fichero a la máquina remota
 - name: "Copiar fichero a la máquina remota"
   copy:
     src: files/foo.txt
     dest: /etc
     owner: root
     group: root
     mode: '0644'

   # Copia un template a un fichero
 - name: "Copiar un template a un fichero de la máquina remota"
   template: 
     src: template/index.j2
     dest: /var/www/html/index.html
     owner: www-data
     group: www-data
     mode: 0644
</code></pre></div>    </div>
  </li>
  <li>
    <p>Creamos <em>hosts</em>.
 <code></code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> all:
         children:

           servidores:

             hosts:

               ansible-client: 

                 ansible_ssh_host: 192.168.122.120 

                 ansible_ssh_user: ansible

                 ansible_ssh_private_key_file: /home/maria/.ssh/id_rsa
</code></pre></div>    </div>
  </li>
  <li>
    <p>Creamos <em>index.j2</em>.
 <code></code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     &lt;html lang="es"&gt;
     &lt;head&gt;
       &lt;meta charset="utf-8"&gt;
       &lt;title&gt;Prueba Ansible&lt;/title&gt; 
     &lt;/head&gt;

     &lt;body&gt;
       &lt;h1&gt;Gathering Facts&lt;/h1&gt;
       &lt;p&gt;Este ordenador se llama: &lt;/p&gt;
       &lt;p&gt;SO:   &lt;/p&gt;
       &lt;h1&gt;Variables declaradas por el usuario a nivel de grupo&lt;/h1&gt;
       &lt;p&gt;Nombre de la bd: &lt;/p&gt;
       &lt;p&gt;Usuario de la bd: &lt;/p&gt;
       &lt;h1&gt;Variables declaradas por el usuario a nivel de nodo&lt;/h1&gt;
       &lt;p&gt;IP: &lt;/p&gt;
     &lt;/body&gt;
     &lt;/html&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>Ejectuamos el playbook.
 <code></code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ansible-playbook site.yml -i hosts
</code></pre></div>    </div>

    <p><img src="/assets/images/vag-ans/1.png" alt="1" /></p>
  </li>
  <li>¿Cómo se llama la propiedad que permite que las tareas que ya se han realizado no se vuelvan a ejecutar?
    <ul>
      <li>Idempotencia</li>
    </ul>
  </li>
  <li>
    <p>Captura de pantalla del fichero foo.txt del servidor configurado.</p>

    <p><img src="/assets/images/vag-ans/2.png" alt="2" /></p>
  </li>
  <li>
    <p>Cuando accedemos a la IP del servidor, nos muestra la página web que hemos creado.</p>

    <p><img src="/assets/images/vag-ans/3.png" alt="3" /></p>
  </li>
</ol>

<p>Si queréis el playbook completo, lo tenéis en mi <a href="https://github.com/Legnakra/taller_ansible_vagrant/tree/main/Taller1">repositorio</a>.</p>

<h3 id="playbook-con-roles">Playbook con roles</h3>]]></content><author><name></name></author><category term="sri" /><summary type="html"><![CDATA[Ansible Playbook sencillo]]></summary></entry></feed>