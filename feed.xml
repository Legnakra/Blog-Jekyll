<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-11-15T16:40:23+01:00</updated><id>/feed.xml</id><title type="html">sysmaria</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Instalación de ngix con PHP con vagrant y ansible</title><link href="/hlc+sri/2022/11/13/ansible-nginx.html" rel="alternate" type="text/html" title="Instalación de ngix con PHP con vagrant y ansible" /><published>2022-11-13T16:17:03+01:00</published><updated>2022-11-13T16:17:03+01:00</updated><id>/hlc+sri/2022/11/13/ansible-nginx</id><content type="html" xml:base="/hlc+sri/2022/11/13/ansible-nginx.html"><![CDATA[<p>En esta entrada vamos a realizar una variante de <a href="https://sysmaria.netlify.app/hlc+sri/2022/11/08/proxy.html">este post</a> en el que lo haremos desde por completo con una receta de ansible y sustituyendo apache por nginx.</p>

<h2 id="descripción-del-escenario">Descripción del escenario</h2>

<ol>
  <li>Vamos a utilizar como base la receta de ansible de <a href="https://sysmaria.netlify.app/hlc+sri/2022/11/08/proxy.html">este post</a> y la vamos a modificarla para añadirle las siguientes funcionalidades:
    <ul>
      <li>Instalamos los servicios (con roles diferenciados).</li>
      <li>Copiamos un index en el DocumentRoot y un info.php.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>La receta de ansible debe desactivar los virtualhost que tengamos definidos en otra lista.</li>
</ul>

<ol>
  <li>Configuramos sobre una máquina virtual, un servidor ngix con PHP con dos virtualhost:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">www.pagina1.org</code>, cuyo <em>DocumentRoot</em> es <code class="language-plaintext highlighter-rouge">/srv/www/pagina1.org</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">www.pagina2.org</code>, cuyo <em>DocumentRoot</em> es <code class="language-plaintext highlighter-rouge">/srv/www/pagina2.org</code>.</li>
    </ul>
  </li>
  <li>Una vez configurada la receta, debemos configurar de forma manual las siguientes características:
    <ul>
      <li>Cuando accedamos a <code class="language-plaintext highlighter-rouge">www.pagina1.org</code> se redireccionará a <code class="language-plaintext highlighter-rouge">www.pagina2.org/principal</code>. No se permitirá ver la lista de ficheros.</li>
      <li>Cuando accedamos a `www.pagina1.org/principal se debe mostrar una página web estática.</li>
      <li>Si accedemos a la página <code class="language-plaintext highlighter-rouge">www.pagina2.org/principal/documentos</code> se visualizarán los documentos que tengamos en <code class="language-plaintext highlighter-rouge">/srv/doc</code>. Y se permitirá el listado y el seguimiento de enlaces simbólicos.</li>
      <li>Limitaremos el accero a <code class="language-plaintext highlighter-rouge">www.pagina1.org/principal/secreto</code> con autenticación básica.</li>
    </ul>
  </li>
</ol>

<h2 id="la-receta-de-ansible">La receta de ansible</h2>

<p>Ya ejecutada la receta, y habiendo cambiando el fichero <em>hosts</em> para que apunte a la máquina virtual, podemos comprobar que tenemos instalado el servidor nginx con PHP. Y vamos a realizar las siguientes comprobaciones:</p>

<ol>
  <li>
    <p>Los virtualhost que tenemos definidos en la receta de ansible, están creados y funcionando correctamente.</p>

    <p><img src="/assets/images/nginx/1.png" alt="1" /></p>

    <p><img src="/assets/images/nginx/2.png" alt="2" /></p>

    <p><img src="/assets/images/nginx/3.png" alt="3" /></p>
  </li>
  <li>
    <p>Comprobamos que al acceder a <em>www.pagina1.org</em> se produce la redirección a <em>www.pagina1.org/principal</em>.</p>

    <p>Si lo que queremos es que nginx redireccione a otra página, debemos añadir la siguiente línea en el fichero de configuración del virtualhost:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    server <span class="o">{</span>
     rewrite ^/<span class="nv">$ </span>/principal redirect<span class="p">;</span>

     location / <span class="o">{</span>
         try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
         autoindex off<span class="p">;</span>
         disable_symlinks if_not_owner <span class="nv">from</span><span class="o">=</span><span class="nv">$root</span><span class="p">;</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <p><img src="/assets/images/nginx/4.png" alt="4" /></p>

    <p><img src="/assets/images/nginx/5.png" alt="5" /></p>
  </li>
  <li>
    <p>Si accedemos a la página <em>www.pagina1.org/principal/documentos</em> se visualizarán los documentos que tengamos en <em>/srv/doc</em>. Y no se permitirá el listado y el seguimiento de enlaces simbólicos.</p>

    <ul>
      <li>
        <p>Creamos el directorio y le cambiamos los permisos:</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">mkdir</span> /srv/doc
  <span class="nb">chown </span>www-data:www-data /srv/doc
</code></pre></div>        </div>
      </li>
      <li>
        <p>Creamos un fichero en el directorio <em>/srv/doc</em> y lo enlazamos simbólicamente en el directorio <em>/srv/www/pagina1.org/principal/documentos</em>.</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">echo</span> <span class="s2">"Hola Mundo"</span> <span class="o">&gt;</span> /srv/doc/doc1.txt
</code></pre></div>        </div>
      </li>
      <li>
        <p>Modificamos el fichero <em>pagina1.conf</em> para que liste los ficheros del directorio <em>/srv/doc</em>.</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  location /principal/documentos <span class="o">{</span>
      <span class="nb">alias</span> /srv/doc<span class="p">;</span>
      autoindex on<span class="p">;</span>
  <span class="o">}</span>
</code></pre></div>        </div>
        <p><img src="/assets/images/nginx/6.png" alt="6" /></p>
      </li>
    </ul>

    <p><img src="/assets/images/nginx/7.png" alt="7" /></p>

    <p><img src="/assets/images/nginx/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Limitaremos el acceso a <em>www.pagina1.org/secreto</em> en nginx con autenticación básica.</p>

    <ul>
      <li>
        <p>Creamos un fichero <em>.htpasswd</em> con el usuario y la contraseña que queramos dentro de */secreto.</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  htpasswd <span class="nt">-c</span> <span class="nt">-b</span> <span class="nt">-B</span> /srv/www/pagina1/secreto/.htpasswd maria admin
</code></pre></div>        </div>
      </li>
      <li>
        <p>Modificamos el fichero <em>pagina1.conf</em> para que se aplique la autenticación básica y accederemos al index de <em>www.pagina1.com/secreto</em>.</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  location /secreto <span class="o">{</span>
      auth_basic <span class="s2">"Acceso restringido"</span><span class="p">;</span>
      auth_basic_user_file /srv/www/pagina1/secreto/.htpasswd<span class="p">;</span>
  <span class="o">}</span>
</code></pre></div>        </div>
        <p><img src="/assets/images/nginx/9.png" alt="9" /></p>
      </li>
    </ul>

    <p><img src="/assets/images/nginx/10.png" alt="10" /></p>
  </li>
</ol>

<p>Tras todas las modificaciones, el fichero <em>pagina1.conf</em> quedaría de la siguiente forma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
    listen 80<span class="p">;</span>
        root /srv/www/pagina1<span class="p">;</span>
        index index.php index.html index.htm index.nginx-debian.html<span class="p">;</span>
        server_name pagina1.org www.pagina1.org<span class="p">;</span>

        rewrite ^/<span class="nv">$ </span>/principal redirect<span class="p">;</span>

        error_log /var/log/nginx/error_pagina1.log<span class="p">;</span>
        access_log /var/log/nginx/access_pagina1.log<span class="p">;</span>

        location / <span class="o">{</span>
            try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
            autoindex off<span class="p">;</span>
            disable_symlinks if_not_owner <span class="nv">from</span><span class="o">=</span><span class="nv">$root</span><span class="p">;</span>
        <span class="o">}</span>
       location /principal/documentos <span class="o">{</span>
            autoindex on<span class="p">;</span>
            <span class="nb">alias</span> /srv/doc<span class="p">;</span>
        <span class="o">}</span>

        location /secreto <span class="o">{</span>
            try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
            auth_basic <span class="s2">"Acceso restringido"</span><span class="p">;</span>
            auth_basic_user_file /srv/www/pagina1/secreto/.htpasswd<span class="p">;</span>
        <span class="o">}</span>

        location ~ <span class="se">\.</span>php<span class="nv">$ </span><span class="o">{</span>
                include snippets/fastcgi-php.conf<span class="p">;</span>
                fastcgi_pass unix:/var/run/php/php7.4-fpm.sock<span class="p">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="para-finalizar">Para finalizar</h2>

<p>Como podemos ver el virtualhost <em>www.pagina2.org</em> está activo.</p>

<p><img src="/assets/images/nginx/11.png" alt="11" /></p>

<p>Pero, vamos a cambiar la receta de ansible para desactivar el acceso a la página <em>www.pagina2.org</em> de la siguiente manera:</p>

<ol>
  <li>
    <p>Vamosa modificar el <em>all.yaml</em> para que se desactive.</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">del_virtualhost</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">pagina2</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>En el <em>main.yaml</em> vamos a añadir la siguiente tarea:</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Delete vhost pagina2</span>
   <span class="na">file</span><span class="pi">:</span>
     <span class="na">path</span><span class="pi">:</span> <span class="s">/etc/nginx/sites-enabled/.conf</span>
     <span class="na">state</span><span class="pi">:</span> <span class="s">absent</span>
   <span class="na">with_items</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">"</span>
   <span class="na">notify</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">restart nginx</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Ejecutamos la receta de ansible.</p>

    <p><img src="/assets/images/nginx/12.png" alt="12" /></p>

    <p><img src="/assets/images/nginx/13.png" alt="13" /></p>
  </li>
</ol>

<p>Y como podemos ver, el virtualhost <em>www.pagina2.org</em> ya no está activo.</p>

<p>La receta de ansible la podemos encontrar en el siguiente <a href="https://github.com/Legnakra/Nginx-Ansible">repositorio</a>.</p>]]></content><author><name></name></author><category term="hlc+sri" /><summary type="html"><![CDATA[En esta entrada vamos a realizar una variante de este post en el que lo haremos desde por completo con una receta de ansible y sustituyendo apache por nginx.]]></summary></entry><entry><title type="html">Apache como proxy inverso</title><link href="/hlc+sri/2022/11/08/proxy.html" rel="alternate" type="text/html" title="Apache como proxy inverso" /><published>2022-11-08T13:11:32+01:00</published><updated>2022-11-08T13:11:32+01:00</updated><id>/hlc+sri/2022/11/08/proxy</id><content type="html" xml:base="/hlc+sri/2022/11/08/proxy.html"><![CDATA[<h2 id="apache-como-proxy-inverso">Apache como proxy inverso</h2>

<p>Apache es un servidor web que se puede utilizar como proxy inverso. En este artículo se explica cómo configurar Apache para que actúe como proxy inverso.</p>

<h2 id="configuración">Configuración</h2>

<p>Lo primero que haremos será aplicar el <a href="https://fp.josedomingo.org/sri2223/3_http/files/ejercicio_proxy.zip">escenario</a> donde encontraremos:</p>

<ul>
  <li>Un escenario vagrant con dos máquinas virtuales:
    <ul>
      <li>Una máquina proxy conectada al exterior y a una red interna.</li>
      <li>Una máquina servidorweb conectada a la red interna.</li>
    </ul>
  </li>
  <li>Una receta ansible para configurar las dos máquinas virtuales del escenario anterior.</li>
</ul>

<p>Lo siguiente será instalar apache en la máquina proxy y configurarla para acceder a las páginas web de la máquina servidorweb. La primera URL es www.app1.org y la segunda es www.app2.org.</p>

<p>Activaremos el módulo proxy y proxy_http de apache:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2enmod proxy
a2enmod proxy_http
</code></pre></div></div>

<p>Y reiniciaremos el servidor web:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart apache2
</code></pre></div></div>

<p>Ahora crearemos un archivo de configuración para cada una de las aplicaciones que queremos que se sirvan a través de apache. En este caso, crearemos dos archivos de configuración: app1.conf y app2.conf. Estos archivos de configuración se guardarán en la ruta /etc/apache2/sites-available.</p>

<p>El contenido de app1.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
        ServerName www.app1.org
        ProxyPass               /       "http://interno.example1.org"
        ProxyPassReverse        /       "http://interno.example1.org"
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Y el contenido de app2.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
        ServerName www.app2.org
        ProxyPass               /       "http://interno.example2.org"
        ProxyPassReverse        /       "http://interno.example2.org"
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Ahora activaremos los archivos de configuración de las aplicaciones:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2ensite app1.conf
a2ensite app2.conf
</code></pre></div></div>

<p>Y reiniciaremos el servidor web:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart apache2
</code></pre></div></div>

<p>Ahora configuraremos el archivo /etc/hosts de la máquina host para que resuelva los nombres de las aplicaciones a las direcciones IP de las máquinas servidorweb. El contenido del archivo /etc/hosts será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.121.63 www.app1.org www.app2.org
</code></pre></div></div>

<p>Ahora configuraremos el archivo /etc/hosts de las máquinas servidorweb para que resuelva los nombres de las aplicaciones a las direcciones IP de la máquina proxy. El contenido del archivo /etc/hosts será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10.0.0.6 interno.example1.org interno.example2.org
</code></pre></div></div>

<p>Ahora, desde la máquina host, accederemos a las aplicaciones a través de la máquina proxy. Para ello, abriremos un navegador web y accederemos a las siguientes URLs:</p>

<p><img src="/assets/images/proxy/1.png" alt="1" /></p>

<p><img src="/assets/images/proxy/2.png" alt="2" /></p>

<h2 id="creamos-un-virtualhost-para-las-dos-aplicaciones">Creamos un virtualhost para las dos aplicaciones</h2>

<p>En vez de crear un virtualhost para cada aplicación, podemos crear un virtualhost para las dos aplicaciones. El contenido del archivo servidor.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
    ServerName www.servidor.org
    &lt;Location "/app1"&gt;
        ProxyPass           "http://interno.example1.org"
        ProxyPassReverse    "http://interno.example1.org"
    &lt;/Location&gt;
    &lt;Location "/app2"&gt;
        ProxyPass           "http://interno.example2.org"
        ProxyPassReverse    "http://interno.example2.org"
    &lt;/Location&gt;
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Ahora activaremos el archivo de configuración de la aplicación:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2ensite servidor.conf
</code></pre></div></div>

<p>Y reiniciaremos el servidor web:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart apache2
</code></pre></div></div>

<p>Cambiaremos el contenido del archivo /etc/hosts de la máquina host para que resuelva el nombre de la aplicación a la dirección IP de la máquina proxy. El contenido del archivo /etc/hosts será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.121.63 www.app1.org www.app2.org www.servidor.org
</code></pre></div></div>

<p>Ahora, desde la máquina host, accederemos a las aplicaciones a través de la máquina proxy. Para ello, abriremos un navegador web y accederemos a las siguientes URLs:</p>

<p><img src="/assets/images/proxy/3.png" alt="3" /></p>

<p><img src="/assets/images/proxy/4.png" alt="4" /></p>

<h2 id="modificaciones">Modificaciones</h2>

<p>En el primer escenario, hemos configurado http://www.app1.org/directorio para que se sirva a través de la máquina proxy. Ahora vamos a modificarlo quitando la directiva ProxyPassReverse. El contenido del archivo app1.conf será el siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
        ServerName www.app1.org
        ProxyPass               /       "http://interno.example1.org"
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>Si realizamos una petición HEAD con curl, veremos que cambia Location de la respuesta:</p>

<p><img src="/assets/images/proxy/5.png" alt="5" /></p>

<p><img src="/assets/images/proxy/6.png" alt="6" /></p>

<p>Si ponemos de nuevo la directiva ProxyPassReverse, y queremos comprobar que redirección se realiza, podemos comprobarlo en la cabecera de Location de la respuesta:</p>

<p><img src="/assets/images/proxy/7.png" alt="7" /></p>

<p><img src="/assets/images/proxy/8.png" alt="8" /></p>

<p>Como podemos ver en las siguientes imágenes, también sucede con el virtualhost <em>servidor.conf</em>.</p>

<p>(antes de quitar ProxyPassReverse)
<img src="/assets/images/proxy/9.png" alt="9" /></p>

<p><img src="/assets/images/proxy/10.png" alt="10" /></p>

<p>(despues de quitar ProxyPassReverse)</p>

<p><img src="/assets/images/proxy/11.png" alt="11" /></p>

<p><img src="/assets/images/proxy/12.png" alt="12" /></p>]]></content><author><name></name></author><category term="hlc+sri" /><summary type="html"><![CDATA[Apache como proxy inverso]]></summary></entry><entry><title type="html">Interconexiones de servidores</title><link href="/asgbd/2022/11/08/interconexion.html" rel="alternate" type="text/html" title="Interconexiones de servidores" /><published>2022-11-08T13:11:32+01:00</published><updated>2022-11-08T13:11:32+01:00</updated><id>/asgbd/2022/11/08/interconexion</id><content type="html" xml:base="/asgbd/2022/11/08/interconexion.html"><![CDATA[<p>En esta entrada vamos a configurar servicios gestores de bases de datos para realizar interconexiones entre ellos. Es una práctica habitual en entornos de producción, donde se suele tener un servidor de bases de datos principal y otros servidores de bases de datos secundarios, que se conectan al servidor principal para realizar consultas y actualizaciones de datos.</p>

<p>Decir que para realizar esta documentación las versiones de software que se han utilizado son las siguientes:</p>
<ul>
  <li>Debian 11</li>
  <li>Oracle 19c</li>
  <li>PostgreSQL 13</li>
</ul>

<h2 id="interconexión-entre-dos-servidores-con-oracle-19c">Interconexión entre dos servidores con Oracle 19c</h2>

<p><img src="/assets/images/interconexion/oracle.png" alt="oracle" /></p>

<p>En esta primera parte vamos a realizar una interconexión entre dos servidores con Oracle 19c. Para ello vamos a utilizar el servicio de bases de datos Oracle 19c que tenemos instalado y vamos a crear en cada máquina un usuario, <code class="language-plaintext highlighter-rouge">maria1</code> la máquina <code class="language-plaintext highlighter-rouge">oracle1</code> y <code class="language-plaintext highlighter-rouge">maria2</code> en la máquina <code class="language-plaintext highlighter-rouge">oracle2</code>.</p>

<p>Lo primero que debemos averiguar es la IP de cada una de nuestras máquinas, en mi caso son:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>oracle1: 192.168.122.189
<span class="nt">---</span>
oracle2: 192.168.122.179
</code></pre></div></div>
<p>A continuación, vamos conectarnos con el usuario administrador de oracle en cada una de las máquinas y vamos a crear los usuarios que vamos a utilizar para la interconexión.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle1</span>
<span class="nv">$ </span>sqlplus / as sysdba
SQL&gt; create user maria1 identified by admin<span class="p">;</span>
SQL&gt; grant connect, resource to maria1<span class="p">;</span>
SQL&gt; unlimit tablespace to maria1<span class="p">;</span>
SQL&gt; <span class="nb">exit</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/1.png" alt="1" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle2</span>
<span class="nv">$ </span>sqlplus / as sysdba
SQL&gt; create user maria2 identified by admin<span class="p">;</span>
SQL&gt; grant connect, resource to maria2<span class="p">;</span>
SQL&gt; unlimit tablespace to maria2<span class="p">;</span>
SQL&gt; <span class="nb">exit</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/2.png" alt="2" /></p>

<p>Ya creados los usuarios, también deberemos comprobar que el servicio de escucha de la base de datos está activo en cada una de las máquinas. Para ello, en cada una de las máquinas, ejecutamos el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>lsnrctl status
</code></pre></div></div>
<p>Para asegurarnos de que el servicio está activo, debemos ver la siguiente salida:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tnsping &lt;ip&gt;
</code></pre></div></div>

<p><img src="/assets/images/interconexion/3.png" alt="3" /></p>

<p><img src="/assets/images/interconexion/4.png" alt="4" /></p>

<p>En el caso de que nos aparezca desactivado, lo activamos con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>lsnrctl start
</code></pre></div></div>
<p><img src="/assets/images/interconexion/5.png" alt="5" /></p>

<h3 id="enrutamos-los-servidores">Enrutamos los servidores</h3>

<p>En este paso, vamos a añadirle una entrada a la tabla de enrutamiento de cada una de las máquinas, para que sepan cómo llegar al otro servidor. Para ello, en cada una de las máquinas, modificaremos el fichero tnsnames.ora, que se encuentra en la ruta <code class="language-plaintext highlighter-rouge">$ORACLE_HOME/network/admin/</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle1</span>
ORACLE2 <span class="o">=</span>
    <span class="o">(</span>DESCRIPTION <span class="o">=</span>
        <span class="o">(</span>ADDRESS <span class="o">=</span> <span class="o">(</span>PROTOCOL <span class="o">=</span> TCP<span class="o">)(</span>HOST <span class="o">=</span> 192.168.122.179<span class="o">)(</span>PORT <span class="o">=</span> 1521<span class="o">))</span>
        <span class="o">(</span>CONNECT_DATA <span class="o">=</span>
            <span class="o">(</span>SERVER <span class="o">=</span> DEDICATED<span class="o">)</span>
            <span class="o">(</span>SERVICE_NAME <span class="o">=</span> ORCLCDB<span class="o">)</span>
        <span class="o">)</span>
    <span class="o">)</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/6.png" alt="6" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle2</span>
ORACLE1 <span class="o">=</span>
    <span class="o">(</span>DESCRIPTION <span class="o">=</span>
        <span class="o">(</span>ADDRESS <span class="o">=</span> <span class="o">(</span>PROTOCOL <span class="o">=</span> TCP<span class="o">)(</span>HOST <span class="o">=</span> 192.168.122.189<span class="o">)(</span>PORT <span class="o">=</span> 1521<span class="o">))</span>
        <span class="o">(</span>CONNECT_DATA <span class="o">=</span>
            <span class="o">(</span>SERVER <span class="o">=</span> DEDICATED<span class="o">)</span>
            <span class="o">(</span>SERVICE_NAME <span class="o">=</span> ORCLCDB<span class="o">)</span>
        <span class="o">)</span>
    <span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/images/interconexion/7.png" alt="7" /></p>

<h3 id="creamos-la-base-de-datos">Creamos la base de datos</h3>

<p>Ahora vamos a crear una base de datos en cada una de las máquinas. Para las comprobaciones he optado por el esquema SCOTT, que podéis encontrar <a href="www.github.com/oracle/db-sample-schemas">aquí</a>. La única diferencia, es que el servidor oracle2 no tendrá la tabla empleados, ya que la vamos a crear en el servidor oracle1.</p>

<h3 id="creamos-los-enlaces">Creamos los enlaces</h3>

<p>Ambos servidores ya tienen la base de datos creada, ahora vamos a crear los enlaces entre ellos. Para ello, en la máquina oracle1, vamos a crear el enlace con el usuario maria1 y en la máquina oracle2, vamos a crear el enlace con el usuario maria2.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle1</span>
<span class="nv">$ </span>sqlplus maria1/admin
SQL&gt; CREATE DATABASE LINK interconexion2 CONNECT TO maria2 IDENTIFIED BY admin USING <span class="s1">'ORACLE2'</span><span class="p">;</span>
SQL&gt; <span class="nb">exit</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/8.png" alt="8" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle2</span>
<span class="nv">$ </span>sqlplus maria2/admin
SQL&gt; CREATE DATABASE LINK interconexion1 CONNECT TO maria1 IDENTIFIED BY admin USING <span class="s1">'ORACLE1'</span><span class="p">;</span>
SQL&gt; <span class="nb">exit</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/9.png" alt="9" /></p>

<h3 id="comprobamos-la-conexión">Comprobamos la conexión</h3>

<p>Ahora vamos a comprobar que la conexión entre los dos servidores funciona correctamente. Para ello, vamos a realizar una consulta en la máquina oracle2, que es la que no tiene la tabla empleados, y vamos a ver si podemos acceder a ella.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle1</span>
<span class="nv">$ </span>sqlplus maria1/admin
SQL&gt; SELECT <span class="k">*</span> FROM dept@interconexion2 WHERE dname <span class="o">=</span> <span class="s1">'SALES'</span><span class="p">;</span>
SQL&gt; <span class="nb">exit</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/10.png" alt="10" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle2</span>
<span class="nv">$ </span>sqlplus maria2/admin
SQL&gt; SELECT <span class="k">*</span> FROM emp@interconexion1 WHERE deptno <span class="o">=</span> 20<span class="p">;</span>
SQL&gt; <span class="nb">exit</span>
</code></pre></div></div>
<p><img src="/assets/images/interconexion/11.png" alt="11" /></p>

<h2 id="interconexión-entre-dos-servidores-con-postgresql">Interconexión entre dos servidores con postgresql</h2>

<p><img src="/assets/images/interconexion/postgresql.png" alt="postgresql" /></p>

<p>Ahora le toca el turno a postgresql. Para realizar la interconexión entre dos servidores, vamos a utilizar el mismo esquema que en el caso de oracle, es decir, vamos a crear una base de datos en cada uno de los servidores y vamos a crear un enlace entre ellos.</p>

<p>Lo primero que debemos averiguar es la IP de cada una de nuestras máquinas, en mi caso son:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maria: 192.168.122.167
<span class="nt">---</span>
oracle: 192.168.122.189
</code></pre></div></div>

<h3 id="creamos-la-base-de-datos-1">Creamos la base de datos</h3>
<p>En este caso voy a utilizar el esquema scott de postgresql, que podéis encontrar <a href="">aquí</a>, para de esa forma hacer las mismas consultas que en el caso de oracle.</p>

<h3 id="creamos-los-usuarios">Creamos los usuarios</h3>
<p>A continuación, vamos conectarnos con el usuario administrador de postgres en cada una de las máquinas y vamos a crear los usuarios que vamos a utilizar para la interconexión.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># maria</span>
<span class="nv">$ </span><span class="nb">sudo </span>su - postgres psql
<span class="nv">postgres</span><span class="o">=</span><span class="c"># CREATE USER maria2 WITH PASSWORD 'admin';</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># GRANT CONNECT ON DATABASE scott2 TO maria2;</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># GRANT USAGE ON SCHEMA public TO maria2;</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># GRANT;</span>
EXIT<span class="p">;</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle</span>
<span class="nv">$ </span><span class="nb">sudo </span>su - postgres psql
<span class="nv">postgres</span><span class="o">=</span><span class="c"># CREATE USER maria1 WITH PASSWORD 'admin';</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># GRANT CONNECT ON DATABASE scott TO maria1;</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># GRANT USAGE ON SCHEMA public TO maria1;</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># GRANT;</span>
EXIT<span class="p">;</span>
</code></pre></div></div>

<h3 id="creamos-los-enlaces-1">Creamos los enlaces</h3>

<p>Antes de realizar los enlaces entre las dos máquinas, debemos de cerciorarnos de que el puerto 5432 está abierto en las dos máquinas. Para ello, vamos a comprobar con elsiguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat <span class="nt">-tulpn</span> | <span class="nb">grep </span>5432
</code></pre></div></div>

<p>Si no está abierto, lo abrimos con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw allow 5432/tcp
</code></pre></div></div>

<p>Ahora vamos a crear los enlaces entre las dos máquinas. Para ello realizaremos los siguientes pasos:</p>

<ol>
  <li>Nos conectamos como usuario postgres.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>su - postgres psql
</code></pre></div>    </div>
  </li>
  <li>Nos conectamos a la base de datos:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># maria</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># \c scott2</span>
<span class="nt">---</span>
<span class="c"># oracle</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c"># \c scott</span>
</code></pre></div>    </div>
  </li>
  <li>En las dos máquinas realizamos el mismo comando:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">postgres</span><span class="o">=</span><span class="c"># CREATE EXTENSION dblink;</span>
</code></pre></div>    </div>
  </li>
  <li>Comprobamos que los links están realizados:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">postgres</span><span class="o">=</span><span class="c"># \dx</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="comprobamos-la-conexión-1">Comprobamos la conexión</h3>

<p>Ahora vamos a comprobar que la conexión entre los dos servidores funciona correctamente. Para ello, vamos a realizar una consulta en la máquina oracle, que es la que no tiene la tabla empleados, y vamos a ver si podemos acceder a ella.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># maria</span>
<span class="nv">$ </span>psql <span class="nt">-U</span> maria2 <span class="nt">-d</span> scott2
<span class="nv">scott2</span><span class="o">=</span><span class="c"># SELECT * FROM dblink('host=192.168.122.189 port=5432 user=maria1 password=admin dbname=scott', 'SELECT * FROM emp WHERE deptno = 20') as t1 (empno int, ename varchar(10), job varchar(9), mgr int, hiredate date, sal numeric(7,2), comm numeric(7,2), deptno int);</span>
</code></pre></div></div>

<p><img src="/assets/images/interconexion/12.png" alt="12" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># oracle</span>
<span class="nv">$ </span>psql <span class="nt">-U</span> maria1 <span class="nt">-d</span> scott
<span class="nv">scott</span><span class="o">=</span><span class="c"># SELECT * FROM dblink('host=192.168.122.167 port=5432 user=maria2 password=admin dbname=scott2', 'SELECT * FROM dept WHERE deptno = 30') as t2 (deptno int, dname varchar(14), loc varchar(13));</span>
</code></pre></div></div>

<p><img src="/assets/images/interconexion/13.png" alt="13" /></p>

<blockquote>
  <p><strong>Nota:</strong> En el caso de posgresql, a diferencia de ORACLE, es necesario que a la hora de realizar la consulta, se especifique el formato de salida de la misma, ya que si no, dará error.</p>
</blockquote>

<p><img src="/assets/images/interconexion/14.png" alt="14" /></p>

<h2 id="interconexión-entre-un-servidor-oracle-y-un-servidor-postgresql">Interconexión entre un servidor Oracle y un servidor Postgresql</h2>

<p><img src="/assets/images/interconexion/oracle-postgresql.png" alt="postgresql-oracle" /></p>

<p>Para finalizar, vamos a realizar una interconexión entre un servidor oracle y un servidor postgresql. Para ello, vamos a utilizar el mismo esquema que en los casos anteriores, es decir, vamos a reutilizar las bases de datos que hemos creado en los casos anteriores.</p>

<p>En la máquina <code class="language-plaintext highlighter-rouge">maria</code> con ip <code class="language-plaintext highlighter-rouge">192.168.122.167</code> tenemos la base de datos <code class="language-plaintext highlighter-rouge">scott2</code> con la tabla <code class="language-plaintext highlighter-rouge">dept</code> y en la máquina <code class="language-plaintext highlighter-rouge">oracle</code> con ip <code class="language-plaintext highlighter-rouge">192.168.122.189</code> tenemos la base de datos <code class="language-plaintext highlighter-rouge">scott</code> con la tabla <code class="language-plaintext highlighter-rouge">emp</code>.</p>

<h3 id="creamos-los-enlaces-2">Creamos los enlaces</h3>

<p>Realmente, ambas máquinas ya están configuradas para acceder a ellas de forma remota, ya que en el caso de oracle, hemos creado un usuario remoto y en el caso de postgresql, hemos abierto el puerto 5432. Pero, siendo dos gestores de bases de datos diferentes, vamos a realizar los enlaces de forma diferente.</p>

<h4 id="conectándonos-de-oracle-a-postgresql">Conectándonos de Oracle a Postgresql</h4>

<p>Para que la interconexión entre estos gestores de bases de datos sea posible, debemos de tener instalado el paquete <code class="language-plaintext highlighter-rouge">postgresql-odbc</code> en la máquina oracle. Para ello, vamos a realizar los siguientes pasos:</p>

<ol>
  <li>Nos conectamos como usuario root.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>su
</code></pre></div>    </div>
  </li>
  <li>Actualizamos la lista de paquetes.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>apt-get update
</code></pre></div>    </div>
  </li>
  <li>Instalamos el paquete <code class="language-plaintext highlighter-rouge">postgresql-odbc</code> y <code class="language-plaintext highlighter-rouge">unixODCB</code>.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>apt-get <span class="nb">install </span>odbc-postgresql unixodbc
</code></pre></div>    </div>
  </li>
  <li>Comprobamos que el paquete se ha instalado correctamente.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>dpkg <span class="nt">-l</span> | <span class="nb">grep </span>postgresql-odbc
</code></pre></div>    </div>
  </li>
</ol>

<p><img src="/assets/images/interconexion/15.png" alt="15" /></p>

<ol>
  <li>Creamos el archivo de configuración de odbc.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nano /etc/odbc.ini
</code></pre></div>    </div>
  </li>
  <li>Añadimos la siguiente configuración:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>PSQLORCL]
Debug <span class="o">=</span> 0
CommLog <span class="o">=</span> 0
ReadOnly <span class="o">=</span> 0
Driver <span class="o">=</span> PostgreSQL
Servername <span class="o">=</span> 192.168.122.172
Username <span class="o">=</span> maria2
Password <span class="o">=</span> admin
Port <span class="o">=</span> 5432
Database <span class="o">=</span> scott2
Trace <span class="o">=</span> 0
TraceFile <span class="o">=</span> /tmp/sql.log
</code></pre></div>    </div>
  </li>
  <li>Creamos el archivo de configuración de odbcinst.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nano /etc/odbcinst.ini
</code></pre></div>    </div>
  </li>
  <li>Añadimos la siguiente configuración:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>PostgreSQL]
Description     <span class="o">=</span> ODBC <span class="k">for </span>PostgreSQL
Driver          <span class="o">=</span> psqlodbcw.so
Setup           <span class="o">=</span> libodbcpsqlS.so
Driver64        <span class="o">=</span> psqlodbcw.so
Setup64         <span class="o">=</span> libodbcpsqlS.so
FileUsage       <span class="o">=</span> 1
</code></pre></div>    </div>
  </li>
  <li>Reiniciamos el servicio odbc.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>service odbc restart
</code></pre></div>    </div>
  </li>
</ol>

<p>Una vez finalizada la configuración, vamos a realizar la conexión entre los dos servidores y comprobar que funciona correctamente.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>isql <span class="nt">-v</span> PSQLORCL maria2 admin
</code></pre></div></div>

<p>Y realizamos una consulta simple para comprobar que funciona correctamente.</p>

<p><img src="/assets/images/interconexion/16.png" alt="16" /></p>

<p>Realizamos el link de la base de datos pero esta vez desde Oracle, pero para ello, debemos realizar las siguientes modificaciones:</p>

<ol>
  <li>Creatermos el fichero <em>initPSQLORCL.ora</em> dentro de $ORACLE_HOME/network/admin.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nano <span class="nv">$ORACLE_HOME</span>/network/admin/initPSQLORCL.ora
</code></pre></div>    </div>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HS_FDS_CONNECT_INFO <span class="o">=</span> PSQLU
HS_FDS_TRACE_LEVEL <span class="o">=</span> DEBUG
HS_FDS_SHAREABLE_NAME <span class="o">=</span> /usr/lib64/psqlodbcw.so
HS_LANGUAGE <span class="o">=</span> AMERICAN_AMERICA.WE8ISO8859P1
<span class="nb">set </span><span class="nv">ODBCINI</span><span class="o">=</span>/etc/odbc.ini
<span class="nb">set </span><span class="nv">ODBCSYSINI</span><span class="o">=</span>/etc
</code></pre></div>    </div>
  </li>
  <li>Lo siquiente que modificaremos, añadiendo lo descrito, será el fichero <em>listener.ora</em>.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nano <span class="nv">$ORACLE_HOME</span>/network/admin/listener.ora
</code></pre></div>    </div>
    <p>```bash
LISTENER =
 (DESCRIPTION_LIST =
     (DESCRIPTION =
         (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.122.189)(PORT = 1521))
         (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
     )
 )</p>
  </li>
</ol>

<p>SID_LIST_LISTENER =
    (SID_LIST =
        (SID_DESC =
            (SID_NAME = PSQLORCL)
            (ORACLE_HOME=/opt/oracle/product/19c/dbhome_1)
            (PROGRAM=dg4odbc)
        )
    )</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
3. Modicicamos tambien el fichero *tnsnames.ora*.
```bash
PSQLORCL =
    (DESCRIPTION=
        (ADDRESS=(PROTOCOL=tcp)(HOST=192.168.122.189)(PORT=1521))
        (CONNECT_DATA=(SID=PSQLORCL))
        (HS=OK)
    )
</code></pre></div></div>

<ol>
  <li>Reiniciamos el servicio de oracle.
```bash
$ service oracle restart</li>
</ol>]]></content><author><name></name></author><category term="asgbd" /><summary type="html"><![CDATA[En esta entrada vamos a configurar servicios gestores de bases de datos para realizar interconexiones entre ellos. Es una práctica habitual en entornos de producción, donde se suele tener un servidor de bases de datos principal y otros servidores de bases de datos secundarios, que se conectan al servidor principal para realizar consultas y actualizaciones de datos.]]></summary></entry><entry><title type="html">Introducción a GitHub</title><link href="/python/2022/11/06/github.html" rel="alternate" type="text/html" title="Introducción a GitHub" /><published>2022-11-06T16:45:16+01:00</published><updated>2022-11-06T16:45:16+01:00</updated><id>/python/2022/11/06/github</id><content type="html" xml:base="/python/2022/11/06/github.html"><![CDATA[<h2 id="qué-es-github">¿Qué es GitHub?</h2>
<p>Github es un portal creado para alojar el código de las aplicaciones de cualquier desarrollador, y que fue comprada por Microsoft en junio del 2018. La plataforma está creada para que los desarrolladores suban el código de sus aplicaciones y herramientas, y que como usuario no sólo puedas descargarte la aplicación, sino también entrar a su perfil para leer sobre ella o colaborar con su desarrollo.</p>

<h2 id="introducción-a-github">Introducción a GitHub</h2>

<ol>
  <li>
    <p>Creamos un repositorio en GitHub</p>

    <p><img src="/assets/images/github/1.png" alt="1" /></p>

    <p><img src="/assets/images/github/2.png" alt="2" /></p>
  </li>
  <li>
    <p>Clonamos el repositorio en nuestro ordenador</p>

    <p><img src="/assets/images/github/3.png" alt="3" /></p>
  </li>
  <li>
    <p>Creamos un archivo en nuestro ordenador</p>

    <p><img src="/assets/images/github/4.png" alt="4" /></p>
  </li>
  <li>
    <p>Subimos el archivo al repositorio</p>

    <p><img src="/assets/images/github/5.png" alt="5" /></p>

    <p><img src="/assets/images/github/6.png" alt="6" /></p>
  </li>
</ol>

<h2 id="introducción-a-markdown">Introducción a Markdown</h2>

<p>Markdown es un lenguaje de texto que nos permite escribir de forma sencilla y rápida, y que se convierte en HTML. Es un lenguaje muy utilizado en la creación de blogs, ya que permite escribir de forma rápida y sencilla, y que se convierte en HTML.</p>

<pre>
Aprender la *sintaxis básica* del **lenguaje de marcas** `Markdown` para estructura la información en nuestro documentos.

Para ello, hemos creado este fichero de la siguiente manera:
`touch markdown.md`
`nano markdown.md`

Con este lenguaje de marcas podemos usar:
* Titulo principal.
* Subtítulo.
* Párrafos.
* Listas (ordenadas y desordenadas) como esta y la siguiente.

1. Título.
2. SUbtítulo.
3. Párrafos.
4. Listas.

También podemos incluir un enlace, a una página externa [Debian](https://www.debian.org/index.es.html) o a otro fichero Markdown [aqui](README.md)

Podemos visualizar una imagen

![Icono Markdown](markdown.png)

Y también tablas.
| Elemento | Sintaxis |
| ----------- | ----------- |
| Título | #h1 |
| Código | `code` |
| Enlace | \[titulo]\(enlace) |
</pre>

<p>En mi <a href="https://github.com/Legnakra/Prueba-MariaJesus/blob/main/markdown.md">repositorio</a> podéis encontrar el resultado de este fichero.</p>

<h2 id="ramas-y-uniones">Ramas y uniones</h2>

<p>Las ramas son una forma de trabajar en paralelo en un proyecto, y que nos permite trabajar en diferentes versiones de un mismo proyecto. Las ramas se crean a partir de la rama principal, y se pueden fusionar con la rama principal cuando se considera que la rama ya está lista para ser integrada en el proyecto.</p>

<p>Para crear una rama, podemos hacerlo desde la interfaz de GitHub, o desde la terminal. En mi caso, he creado una rama desde la terminal, y he fusionado la rama con la rama principal.</p>

<ol>
  <li>
    <p>Creamos una rama que se llame primera en tu local, y ejecuta la instrucción necesaria para comprobar que se ha creado.</p>

    <p><img src="/assets/images/github/7.png" alt="7" /></p>
  </li>
  <li>Creamos un nuevo fichero en esta rama y fusiónalo con la principal. ¿Se ha producido conflicto?
    <ul>
      <li>Si, dado que las ramas independientes han editado el mismo fichero, se han realizado una serie de commits que github no puede decidir cuál es la versión que debe elegir y nos alerta de que debemos resolverlo.</li>
    </ul>
  </li>
  <li>
    <p>Borramos la rama primera.</p>

    <p><img src="/assets/images/github/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Creamos una rama que se llame segunda, y modifica un fichero en ella para producir un conflicto al unirlo a la rama principal.</p>

    <p><img src="/assets/images/github/9.png" alt="9" /></p>
  </li>
  <li>
    <p>Solucionamos el conflicto que has creado en el punto anterior y sincronizamos la rama segunda en el remoto.</p>

    <p><img src="/assets/images/github/10.png" alt="10" /></p>

    <p><img src="/assets/images/github/11.png" alt="11" /></p>
  </li>
</ol>

<h2 id="cómo-colaborar-en-un-proyecto-de-software-libre-qué-es-un-pull-request-pr">¿Cómo colaborar en un proyecto de software libre? ¿Qué es un Pull Request (PR)?</h2>

<p>Un Pull Request es una petición de extracción que se realiza a un repositorio de GitHub, y que se utiliza para solicitar que los cambios que se han realizado en una rama sean revisados y fusionados con la rama principal. Los Pull Request se utilizan para colaborar en proyectos de software libre, y para que los desarrolladores puedan revisar los cambios que se han realizado en el código.</p>

<ol>
  <li>
    <p>Nos dirigimos al repositorio en el que queremos hacer el PR, realizamos un fork del mismo.</p>

    <p><code>
 git clone git@github.com:Legnakra/prueba-pr-asir.git
 </code></p>
  </li>
  <li>
    <p>Tomamos el enlace de clonación por vía ssh y lo clonamos en nuestra máquina local. Como para este taller hemos clonado el repositorio de prueba de pr, el comando sería:</p>

    <p><img src="/assets/images/github/12.png" alt="12" /></p>
  </li>
  <li>
    <p>Creamos la nueva rama en la que vamos a realizar los cambios (en mi caso la he llamado maria). Una vez en ella, realizamos los cambios de la siguiente manera:</p>

    <p><code>
 nano mjar.md
 git add mjar.md
 nano README.md
 git commit -am "Ficheros modificados" 
 </code></p>

    <p><img src="/assets/images/github/13.png" alt="13" /></p>
  </li>
  <li>
    <p>Actualizamos los cambios.</p>

    <p><code>
 git push origin maria
 </code></p>

    <p><img src="/assets/images/github/14.png" alt="14" /></p>
  </li>
  <li>
    <p>Y por último, nos dirigimos al repositorio original para solicitar el Pull Request a su propietario y esperamos su validación de cambios, como podemos ver <a href="https://github.com/Legnakra/prueba-pr-asir/tree/main">aquí</a>.</p>
  </li>
</ol>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[¿Qué es GitHub? Github es un portal creado para alojar el código de las aplicaciones de cualquier desarrollador, y que fue comprada por Microsoft en junio del 2018. La plataforma está creada para que los desarrolladores suban el código de sus aplicaciones y herramientas, y que como usuario no sólo puedas descargarte la aplicación, sino también entrar a su perfil para leer sobre ella o colaborar con su desarrollo.]]></summary></entry><entry><title type="html">Virtualización en Linux</title><link href="/hlc+sri/2022/11/06/virtualizaci%C3%B3n.html" rel="alternate" type="text/html" title="Virtualización en Linux" /><published>2022-11-06T13:11:32+01:00</published><updated>2022-11-06T13:11:32+01:00</updated><id>/hlc+sri/2022/11/06/virtualizaci%C3%B3n</id><content type="html" xml:base="/hlc+sri/2022/11/06/virtualizaci%C3%B3n.html"><![CDATA[<h1 id="virtualización">Virtualización</h1>

<ol>
  <li>¿Qué es la virtualización?
    <ul>
      <li>Nos permite ejecutar más de un sistema virtual, y múltiples sistemas operativos y aplicaciones, en un solo servidor, aumentando el rendimiento del hardware disponible e incrementando el tiempo de procesamiento de un equipo, ya que habitualmente se desaprovecha gran parte.</li>
    </ul>
  </li>
  <li>¿Para qué se utiliza la virtualización?
    <ul>
      <li>Aislamiento e independencia de servicios y contenidos.</li>
      <li>Laboratorio de pruebas.</li>
      <li>Virtualización de arquitecturas de las que no se dispone.</li>
      <li>Creación de clúster de máquinas y sistemas distribuidos.</li>
      <li>Herramientas de aprendizajes</li>
    </ul>
  </li>
  <li>Ventajas de la virtualización:
    <ul>
      <li>Aumenta la seguridad.</li>
      <li>Reduce los costes.</li>
      <li>Mayor aprovechamiento de los recursos.</li>
      <li>Migración en vivo.</li>
      <li>Ahorro energético.</li>
    </ul>
  </li>
  <li>Desventajas de la virtualización:
    <ul>
      <li>Rendimento.</li>
      <li>Muchos sistemas dependen de un solo equipo.</li>
    </ul>
  </li>
  <li>Conceptos de virtualización
    <ul>
      <li>HOST: Es el equipo que ejecuta el sistema operativo y las aplicaciones.</li>
      <li>GUEST: Es el sistema operativo virtualizado.</li>
      <li>Hypervisor: Es el software que permite la virtualización.</li>
    </ul>
  </li>
  <li>Tipos de virtualización
    <ul>
      <li>Emulación: imita la arquitectura de un sistema al completo. Rendimiento bajo. Ejemplo: QEMU.</li>
    </ul>
  </li>
</ol>

<ul>
  <li>
    <p>Virtualización de hardware: simula un hardware suficiente para permitir que un sistema operativo se ejecute de forma aislada. Rendimiento medio. Hipervisor de tipo 1. Ejemplo: VMware.</p>
  </li>
  <li>
    <p>Virtualización completa: El hipervisor simula un hardware suficiente para permitir que un sistema operativo no adaptado se ejecute de forma aislada. HyperVisor de tipo 2. Ejemplo: VirtualBox.</p>
  </li>
  <li>
    <p>Virtualización parcial: El hipervisor ofrece un interfaz especial para acceder a los recursos. Ejemplo: Xen.</p>
  </li>
  <li>
    <p>Virtualización ligera: también llamada virtualización basada en contenedores. Sobre el núcleo del sistema operativo se ejecuta una capa de virtualización que permite que existan múltiples instancias aisladas de espacios de usuario (contenedor). Ejemplo: Docker.</p>
    <ul>
      <li>Tipos:
        <ul>
          <li>Contenedores de Sistemas: El uso que se hace de ellos es muy similar al que hacemos sobre una máquina virtual: se accede a ellos (normalmente por ssh), se instalan servicios, se actualizan, ejecutan un conjunto de procesos, . . . Ejemplo: LXC(Linux Container).</li>
          <li>Contenedores de Aplicación: Se suelen usar para el despliegue de aplicaciones web Ejemplo: Docker, Podman, . . .</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>¿Qué es un QEMU?
    <ul>
      <li>Es un emulador genérico y de código abierto de máquinas virtuales, permitiendo ejecutar sistemas operativos de una determinada arquitectura en una máquina con otra arquitectura distinta.</li>
    </ul>
  </li>
  <li>¿Que es KVM?
    <ul>
      <li>Es un hipervisor de tipo 1 que permite la virtualización de hardware completo. Es un módulo del núcleo de Linux que que contienen las extensiones de virtualización Intel VT o AMD-V.</li>
    </ul>
  </li>
  <li>¿Qué es un Libvirt?
    <ul>
      <li>Es una biblioteca de software que proporciona una API para la gestión de máquinas virtuales, redes, almacenamiento, etc. Es una capa de abstracción que permite la gestión de máquinas virtuales independientemente del hipervisor que se utilice.</li>
    </ul>
  </li>
  <li>Mecanismos de conexión a Libvirto
    <ul>
      <li>Local no provolegiado: Se conecta a través de un socket Unix. <em>qemu:///session</em></li>
      <li>Remoto: Se conecta a través de un socket Unix. <em>qemu+ssh://user@host/system</em></li>
      <li>Acceso local privilegiado: Se acceden a las máquinas virtuales del sistema. <em>qemu:///session</em></li>
    </ul>
  </li>
  <li>Aplicaciones para usar Libvirt
    <ul>
      <li>virsh: Interfaz de línea de comandos. <em>virsh -c qemu:///session</em></li>
      <li>virt-manager: Es una interfaz gráfica para la gestión de máquinas virtuales. <em>virt-manager -c qemu:///session</em></li>
      <li>virtinst: Es una herramienta para la creación de máquinas virtuales. <em>virt-install -c qemu:///session</em></li>
      <li>virt-viewer: Es una herramienta para la gestión de máquinas virtuales. <em>virt-viewer -c qemu:///session</em></li>
      <li>gnome-boxes: Es una herramienta para la gestión de máquinas virtuales. <em>gnome-boxes -c qemu:///session</em></li>
    </ul>
  </li>
  <li>¿Qué es LXC?
    <ul>
      <li>Es un sistema de contenedores de Linux que permite la creación y gestión de contenedores de Linux. Es un sistema de virtualización ligera que permite la creación de contenedores de Linux.</li>
    </ul>
  </li>
  <li>¿Qué componentes tiene LXC?
    <ul>
      <li>Grupos de control de cgroups: Es un subsistema del núcleo de Linux que permite la gestión de recursos de un grupo de procesos.</li>
      <li>Espacio de nombres namespaces que proporcionan un punto de vista diferente a un proceso (interfaces de red, procesos, usuarios, etc.).</li>
    </ul>
  </li>
  <li>¿A qué pertenecen los contenedores de LXC?
    <ul>
      <li>A los contenedores de sistemas. Su gestión y ciclo de vida es similar al de una máquina virtual tradicional. Está mantenido por Canonical y
la página oficial es linuxcontainers.org.</li>
    </ul>
  </li>
  <li>¿Qué es LXD?
    <ul>
      <li>Es una herramienta de gestión de los contenedores y máquinas virtuales del sistema operativo Linux, desarrollada por Canonical.</li>
    </ul>
  </li>
</ol>

<h2 id="comandos">COMANDOS</h2>

<ol>
  <li>Comandos de virsh
    <ul>
      <li>virsh list: Lista las máquinas virtuales.</li>
      <li>virsh list –all: Lista todas las máquinas virtuales.</li>
      <li>virsh start <nombre>: Inicia una máquina virtual.</nombre></li>
      <li>virsh shutdown <nombre>: Apaga una máquina virtual.</nombre></li>
      <li>virsh destroy <nombre>: Apaga una máquina virtual.</nombre></li>
      <li>virsh undefine <nombre>: Elimina una máquina virtual.</nombre></li>
      <li>virsh define <nombre>: Crea una máquina virtual.</nombre></li>
      <li>virsh edit <nombre>: Edita una máquina virtual.</nombre></li>
      <li>virsh domifaddr <nombre>: Muestra la dirección IP de una máquina virtual.</nombre></li>
      <li>virsh domiflist <nombre>: Muestra las interfaces de red de una máquina virtual.</nombre></li>
      <li>virsh dominfo <nombre>: Muestra información de una máquina virtual.</nombre></li>
      <li>virsh domxml <nombre>: Muestra el XML de una máquina virtual.</nombre></li>
      <li>virsh dumpxml <nombre>: Muestra el XML de una máquina virtual.</nombre></li>
      <li>virsh net-list: Lista las redes virtuales.</li>
      <li>virsh net-start <nombre>: Inicia una red virtual.</nombre></li>
      <li>virsh net-destroy <nombre>: Apaga una red virtual.</nombre></li>
      <li>virsh net-undefine <nombre>: Elimina una red virtual.</nombre></li>
      <li>virsh net-define <nombre>: Crea una red virtual.</nombre></li>
      <li>virsh net-edit <nombre>: Edita una red virtual.</nombre></li>
      <li>virsh net-dumpxml <nombre>: Muestra el XML de una red virtual.</nombre></li>
      <li>virsh net-info <nombre>: Muestra información de una red virtual.</nombre></li>
      <li>virsh net-autostart <nombre>: Inicia una red virtual al arrancar el sistema.</nombre></li>
      <li>virsh net-autostart –disable <nombre>: No inicia una red virtual al arrancar el sistema.</nombre></li>
    </ul>
  </li>
  <li>Comandos de virt-manager
    <ul>
      <li>virt-manager: Inicia la interfaz gráfica de gestión de máquinas virtuales.</li>
      <li>virt-install: Crea una máquina virtual.</li>
      <li>virt-viewer: Gestiona una máquina virtual.</li>
    </ul>
  </li>
  <li>Comandos de LXC
    <ul>
      <li>lxc-list: Lista los contenedores.</li>
      <li>lxc-start: Inicia un contenedor.</li>
      <li>lxc-stop: Apaga un contenedor.</li>
      <li>lxc-destroy: Elimina un contenedor.</li>
      <li>lxc-create: Crea un contenedor.</li>
      <li>lxc-attach: Accede a un contenedor.</li>
      <li>lxc-console: Accede a la consola de un contenedor.</li>
      <li>lxc-info: Muestra información de un contenedor.</li>
    </ul>
  </li>
  <li>Comandos virt
    <ul>
      <li>virt-clone: Clona una máquina virtual.</li>
      <li>virt-install: Crea una máquina virtual.</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="hlc+sri" /><summary type="html"><![CDATA[Virtualización]]></summary></entry><entry><title type="html">Compilar dos2unix partiendo del código fuente</title><link href="/aso/2022/10/12/compilacion-paquete-makefile.html" rel="alternate" type="text/html" title="Compilar dos2unix partiendo del código fuente" /><published>2022-10-12T11:17:16+02:00</published><updated>2022-10-12T11:17:16+02:00</updated><id>/aso/2022/10/12/compilacion-paquete-makefile</id><content type="html" xml:base="/aso/2022/10/12/compilacion-paquete-makefile.html"><![CDATA[<p>Los lenguajes de programación compilados, no necesitan de un intérprete, si no que necesitan compiladores y linkers. Los lenguajes de programación compilados no requieren que exista un programa que los vaya leyendo, interprete, si no que, antes de ejecutarse, deben ser traducidos a un lenguaje que la máquina sea capaz de entender directamente, sin intermediarios. En ese proceso se llama al compilador y al enlazador o linker.</p>

<p>El comando que he seleccionado es dos2unix, un comando que convierte un archivo de texto DOS a formato UNIX.</p>

<h2 id="pasos-de-instalación">Pasos de instalación</h2>

<ol>
  <li>Nos descargamos el código fuente:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt source dos2unix
</code></pre></div>    </div>
  </li>
  <li>Descomprimimos el archivo con extension .orig.tar.xz.
    <ul>
      <li>x: Para extraer el archivo.</li>
      <li>v: Para mostrar la descripción detallada del progreso de la compresión.</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xv dos2unix_7.4.1.orig.tar.gz
</code></pre></div></div>

<p><img src="/images/Makefile/paso1" alt="paso1" /></p>

<p><img src="/images/Makefile/paso2" alt="paso2" /></p>

<ol>
  <li>Nos dirigimos al directorio que hemos descomprimido y ejecutamos lo siguiente:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd dos2unix-7.4.1/
make
</code></pre></div></div>

<p><img src="/images/Makefile/paso2-2" alt="paso2-2" /></p>

<ol>
  <li>Realizamos la instalación con la entrada del comando:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make install
</code></pre></div></div>

<p><img src="/images/Makefile/paso3" alt="paso3" /></p>

<ol>
  <li>Realizamos la comprobación de que el paquete se ha instalado correctamente.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dos2unix --version
whereis dos2unix
</code></pre></div></div>

<p><img src="/images/Makefile/paso4" alt="paso4" /></p>

<p><img src="/images/Makefile/paso5" alt="paso5" /></p>

<h2 id="pasos-de-instalación-1">Pasos de instalación</h2>

<p>Para realizar una desinstalación limpia del paquete deberemos realizar los siguientes pasos</p>

<ol>
  <li>Nos dirigimos al directorio donde se encuentra nuestro fichero Makefile.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd dos2unix-7.4.1/
ls
</code></pre></div>    </div>
  </li>
</ol>

<p><img src="/images/Makefile/paso5-2" alt="paso5-2" /></p>

<ol>
  <li>Desde allí, ejecutamos lo siguiente en nuestra consola y se realizará una desinstalación limpia.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo make uninstall
</code></pre></div></div>

<p><img src="/images/Makefile/paso6" alt="paso6" /></p>

<ol>
  <li>Comprobamos que ciertamente, el paquete ha sido desinstalado de nuestra maquina.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whereis dos2unix
apt policy dos2unix
</code></pre></div>    </div>
  </li>
</ol>

<p><img src="/images/Makefile/paso7" alt="paso7" /></p>]]></content><author><name></name></author><category term="ASO" /><summary type="html"><![CDATA[Los lenguajes de programación compilados, no necesitan de un intérprete, si no que necesitan compiladores y linkers. Los lenguajes de programación compilados no requieren que exista un programa que los vaya leyendo, interprete, si no que, antes de ejecutarse, deben ser traducidos a un lenguaje que la máquina sea capaz de entender directamente, sin intermediarios. En ese proceso se llama al compilador y al enlazador o linker.]]></summary></entry><entry><title type="html">Prueba: Introducción a la implantación de aplicaciones web</title><link href="/prueba/2022/10/10/prueba.html" rel="alternate" type="text/html" title="Prueba: Introducción a la implantación de aplicaciones web" /><published>2022-10-10T13:11:16+02:00</published><updated>2022-10-10T13:11:16+02:00</updated><id>/prueba/2022/10/10/prueba</id><content type="html" xml:base="/prueba/2022/10/10/prueba.html"><![CDATA[<h2 id="nombre-completo">Nombre completo:</h2>
<p>María Jesús Alloza Rodríguez</p>

<p><img src="https://img2.freepng.es/20171220/kre/linux-logo-png-5a3a1fe7d94070.02257309151375869588993545.jpg" alt="imagen" /></p>]]></content><author><name></name></author><category term="prueba" /><summary type="html"><![CDATA[Nombre completo: María Jesús Alloza Rodríguez]]></summary></entry><entry><title type="html">¿Qué diferencia hay entre exploit, vulnerabilidad y payload?</title><link href="/seguridad/2022/10/10/payload.html" rel="alternate" type="text/html" title="¿Qué diferencia hay entre exploit, vulnerabilidad y payload?" /><published>2022-10-10T10:40:32+02:00</published><updated>2022-10-10T10:40:32+02:00</updated><id>/seguridad/2022/10/10/payload</id><content type="html" xml:base="/seguridad/2022/10/10/payload.html"><![CDATA[<p>En seguridad informática es muy habitual confundir estos tres conceptos, y por ello vamos a ver que es un exploit, una vulnerabilidad y un payload.</p>

<p>Debemos tener en cuenta que estos términos son utilizados principalmente cuando realizamos pruebas de penetración o ejercicios de hacking ético. 
¿En qué parte del hacking podemos encontrarnos con estos términos?
Lo vemos en la fase de explotación, es decir, una vez que conocemos las características del sistema que tienen las máquinas a las que queremos acceder, podemos investigar si existen vulnerabilidades para esos sistemas, y en el caso afirmativo, (que de costumbre es que sí) sería el momento de buscar algún exploit para romper dicha vulnerabilidad.</p>

<p>Pero vamos a ver cada uno de ellos y como se interrelacionan</p>

<h2 id="qué-es-un-exploit">¿Qué es un exploit?</h2>

<p>Un exploit es la herramienta(software) con la cual el hacker aprovechará para comprometer, romper y explotar una vulnerabilidad de seguridad del sistema para sus propios fines.</p>

<p>Esto sucede ya que algunos fabricantes suelen tener fallas de seguridad en sus productos, como por el ejemplo el exploit de día cero, denominado así cuando el desarrollador del producto desconoce de una vulnerabilidad que solo el ciberdelincuente conoce.</p>

<p>Los ciberdelincuentes aplican ingeniería inversa para analizar toda la programación de dicho sistema, de este modo pueden detectar algún error de código y explotarlo.</p>

<h3 id="tipos">Tipos</h3>

<ul>
  <li><strong>Exploit remoto</strong>:
Se realizan mediante una conexión víctima con el atacante, todo mediante una red de comunicaciones.
Por ejemplo, una conexión por internet, por lo general este tipo de ataque suele hacerse mediante el envío y la instalación del software malicioso en el dispositivo.</li>
</ul>

<p><img src="https://assets.website-files.com/5ff66329429d880392f6cba2/61c43d47dccfe68a303551d4_exploit%20Preview.png" alt="Exploit" /></p>

<ul>
  <li>
    <p><strong>Exploit local</strong>:
La principal diferencia con el anterior tipo es que se necesita acceso al sistema antes de efectuar un ataque de explotación. Se necesita burlar al sistema para escalar privilegios en el sistema, donde el ciberdelincuente podría controlar al final todo el sistema.</p>
  </li>
  <li>
    <p><strong>Exploit en cliente</strong>:
Para realizar este tipo de ataques suele influir mucho el phishing para poder comprometer la máquina víctima con un exploit.
Esto se realiza principalmente en las estaciones de trabajo de una organización atacando los softwares de ofimática mediante envío de malware por correos electrónicos.
La mayoría de veces suele ser un éxito, ya que algunos cortafuegos o antivirus dan por alto estos ataques, de este modo los ciberdelincuentes empiezan a escalar privilegios hasta obtener el control total del sistema, aquí podemos llegar a la conclusión de que las víctimas dan el acceso.</p>
  </li>
</ul>

<p>Un claro ejemplo explot fue el llamado Eternal Blue, que se aprovechó de la vulnerabilidad en el protocolo SMB en la versión 1, que estaba presente en todos los sistemas operativos de windows, desde su versión 95 al 10. Es capaz de brindarnos control total de una máquina, otorgando la capacidad de ejecutar código a nivel administrador.</p>

<h2 id="qué-es-la-vulnerabilidad">¿Qué es la vulnerabilidad?</h2>

<p><img src="https://netcloudengineering.com/wp-content/uploads/2017/06/vulnerabilidades-ciberseguridad.jpg" alt="vulnerabilidad" /></p>

<p>Una vulnerabilidad  es una debilidad o un error en el código de un sistema que puede ser explotado para obtener acceso no autorizado o realizar acciones no autorizadas en un sistema informático comprometer la seguridad permitiendo a los atacantes ejecutar código, acceder a la memoria de un sistema, instalar malware y robar, destruir o modificar datos confidenciales.</p>

<h3 id="ejemplos-de-vulnerabilidad">Ejemplos de vulnerabilidad</h3>

<ul>
  <li>
    <p><strong>Autenticación rota</strong>:
En la autenticación rota, cada vez que un usuario inicia sesión en su cuenta, se crea una identificación de sesión, y esa identificación de sesión solo se permite para esa cuenta en particular. En caso de que la aplicación web no esté diseñada de forma segura, el atacante puede usar varias técnicas dadas:</p>

    <ul>
      <li>Relleno de credenciales</li>
      <li>Contraseñas sin cifrar</li>
      <li>Tiempos de espera de sesión mal configurados</li>
    </ul>
  </li>
  <li>
    <p><strong>Inyección de SQL</strong>:
Es un tipo de vulnerabilidad en la que un atacante inserta su propio código en un sitio web con el fin acceder a datos protegidos o sensibles.</p>
  </li>
  <li>
    <p><strong>Secuencias de comandos entre sitios:</strong>
Son un tipo de vulnerabilidad de los sitios web, que permite que los atacantes coloquen secuencias de comandos maliciosas en páginas web.</p>
  </li>
</ul>

<p><img src="https://academy.avast.com/hs-fs/hubfs/What_is_scross-site_scripting-1.png?width=600&amp;name=What_is_scross-site_scripting-1.png" alt="Vulnerabilidad" /></p>

<ul>
  <li>
    <p><strong>Falsificación de solicitudes entre sitios</strong>:
Es un ataque contra aplicaciones hospedadas en web en las que una aplicación web malintencionada puede influir en la interacción entre un explorador cliente y una aplicación web que confía en ese explorador.</p>
  </li>
  <li>
    <p><strong>Configuración incorrecta de seguridad</strong>:
Son controles de seguridad que se configuran incorrectamente o se dejan inseguros, lo que pone en riesgo sus sistemas y datos.</p>
  </li>
</ul>

<h2 id="qué-es-el-payload">¿Qué es el payload?</h2>

<p>En informática, un payload es una carga de capacidad en un paquete o en otros medios de transmisión. Dicho término está arraigado en el mundo militar y a veces está asociado con la capacidad de código malicioso con el fin de dañar. Podemos encontrarnos con data payloads o malware payload. Del primero podemos decir que se produce cuando el dato es enviado por un destino de comunicación, y el segundo es un código malicioso que pretende hacer daño al objetivo señalado.</p>

<p><img src="https://esgeeks.com/media/2022/03/Concepto-payload-carga-útil.jpg" alt="payload" /></p>

<h3 id="ejemplos">Ejemplos</h3>

<p>Un ejemplo de <strong>Data pyload</strong> sería a través de un paquete IP. Este puede contener un payload con comandos emitidos por el último usuario, como una solicitud de un contenido web. Aunque, a menudo, consiste en transmitir datos por un servidor en respuesta a un usuario solicitante.  Los límites de los payloads en las PDUs (Protocol Data Unit) son con frecuencia especificados por un protocolo, y el tamaño máximo para un PDU individual raramente cambia.</p>

<p><img src="https://cdn-icons-png.flaticon.com/512/1995/1995756.png" alt="icono" /></p>

<p>El tamaño máximo de payloads por paquetes de IP está limitado por el campo de longitud total (total length) en la cabecera del paquete IP; este campo tiene una longitud de 16 bits, lo que significa que el valor máximo posible es 2¹⁶ y el  valor más alto posible para la longitud del paquete es de 65535, menos del número de bytes que requiere un encabezado de paquete. El MTU para paquetes IP varía por el sistema y la red. La IP original estándar especifica que todos los hosts deben ser capaces de aceptar paquetes tan largos como sean de 576 bytes con los payload data de 512 bytes y los 64 de la cabecera. El valor predeterminado MTU actualmente aceptado para paquetes IPv4 es de 1500 bytes por la compatibilidad con los segmentos Ethernet.</p>

<p>En cuanto a un <strong>payload malicioso</strong> (o malware payload) podemos poner como ejemplo todos aquellos correos electrónicos o incluso SMS que contienen un virus autorreplicante alojado en un enlace. Los atacantes eluden las defensas, mantienen la carga y atacan a la víctima. Esta vía, la de métodos de distribución comprobados, como los emails de suplantación de identidad y los gusanos, pueden adaptarse. Mientras no tenga límites específicos para la capacidad máxima de carga, los actores maliciosos intentarán mantenerlos en un tamaño razonable para evitar ser detectado por herramientas de detección de malware.</p>

<p>Casi ningún tipo de malware puede ser incorporado dentro de un payload con la ayuda de un generador de payload para crear un malware ejecutable. Una vez entregado y ejecutado, el proceso de distribución infecta al sistema objetivo, a menos que haya un sistema de detección de malware. Una carga útil puede contener cualquier tipo de malware, incluido el ransomware, el reclutamiento de botnets u otros tipos de virus o gusanos.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Ya con este contexto, podemos decir que un exploit es un pequeño programa o un pedazo de código que se aprovecha o explota de una vulnerabilidad encontrada, mientras que un payload viene siendo esa acción que queremos hacer una vez que hemos explotado la vulnerabilidad.</p>

<p>Tanto el exploit como el payload son pedazos de código que funcionan en conjunto para un fin, que en este caso, sería explotar la vulnerabilidad encontrada.</p>

<p>Y también cabe decir que dentro del mundo del hacking, existen varias herramientas automatizadas, como lo es Metaexploit, que en la práctica nos ayudan a comprender mucho mejor como funciona este par de términos, ya que no necesariamente un exploit está amarrado a un payload y viceversa. Sino que un exploit puede usar varios payloads a fin de tener una shellcon privilegios, crear usuarios, etc.</p>]]></content><author><name></name></author><category term="seguridad" /><summary type="html"><![CDATA[En seguridad informática es muy habitual confundir estos tres conceptos, y por ello vamos a ver que es un exploit, una vulnerabilidad y un payload.]]></summary></entry><entry><title type="html">Introducción a la programación Python</title><link href="/python/2022/09/29/inicio-python.html" rel="alternate" type="text/html" title="Introducción a la programación Python" /><published>2022-09-29T17:45:16+02:00</published><updated>2022-09-29T17:45:16+02:00</updated><id>/python/2022/09/29/inicio-python</id><content type="html" xml:base="/python/2022/09/29/inicio-python.html"><![CDATA[<h2 id="ejercicio-1">Ejercicio 1</h2>
<p>Diseñar el algoritmo correspondiente a un programa que lea el valor correspondiente a una distancia en millas marinas y las escriba expresadas en metros.</p>

<h3 id="análisis">Análisis:</h3>
<p>Problema: Tenemos que leer una cantidad de millas marinas y calcular su valor en metros.
Entrada: millas(entero).
Salida: metros (entero).</p>
<h3 id="diseño">Diseño:</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Leer distancia_millas (distancia_millas).
2. Convertir millas marinas a metros (distancia_millas*1852).
3. Mostrar el resultado.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Leer distancia_millas (distancia_millas).
distancia_millas = float(input("Distancia en millas marinas: "))

2. Convertir millas marinas a metros (distancia_millas*1852).
metros= distancia_millas*1852

3. Mostrar el resultado en metros.
print("La distancia en metros es de: ",metros, "metros")
</code></pre></div></div>

<h2 id="ejercicio-2">Ejercicio 2</h2>
<p>Escribir un programa que pida al usuario su peso (en kg) y estatura (en metros), calcule el índice de masa corporal y lo almacene en una variable, e imprima por pantalla la frase “Tu índice de masa corporal es…” y el resultado.</p>

<h3 id="análisis-1">Análisis:</h3>
<p>Problema: Tenemos que calcular el IMC (índice de masa corporal) dados el peso (kg) y la estatura (m).
Entrada: peso (entero), estatura (entero).
Salida: imc (entero).</p>

<h3 id="diseño-1">Diseño:</h3>
<p>1.Leer peso (peso) y estatura (estatura).
2.Calcular el IMC (imc = peso/(estatura**2,2).
3.Mostrar el resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.Leer peso (peso) y estatura (estatura).

peso = input("¿Cuál es tu peso?(kg): ")
estatura = input("¿Cuál es tu estatura (metros): ")

2.Calcular el IMC (imc = peso/(estatura**2,2).
imc = round(float(peso)/float(estatura)**2,2)

3.Mostrar el resultado.
print("Tu índice de masa corporal es " + str(imc))
</code></pre></div></div>

<h2 id="ejercicio-3">Ejercicio 3</h2>
<p>Una juguetería tiene mucho éxito en dos de sus productos: payasos y muñecas. Suele hacer venta por correo y la empresa de logística les cobra por peso de cada paquete así que deben calcular el peso de los payasos y muñecas que saldrán en cada paquete a demanda. Cada payaso pesa 112 g y cada muñeca 75 g. Escribir un programa que lea el número de payasos y muñecas vendidos en el último pedido y calcule el peso total del paquete que será enviado. Además se nos pide el precio que se cobra por gramo, , y se nos mostrará el total de dinero que necesitamos para realizar el envío.</p>

<h3 id="análisis-2">Análisis</h3>
<p>Problema: Tenemos que calcular el peso del último pedido de payasos y muñecas, y el precio por gramo
al realizar el envío.
Entrada: payasos (real), muñecas (real), peso_payaso (real), peso_muñeca (real).
Salida:peso_total (real), precio_envío (entero).</p>

<h3 id="diseño-2">Diseño:</h3>
<p>1.Leer cantidad de payasos (payasos)
2.Leer cantidad de muñecas (muñecas)
3.Calcular el peso del pedido (peso_total = peso_payaso<em>payaso + peso_muñeca</em>muñeca)
4.Leer el precio del envío por gramo.
5.Calcular precio del envío.
6.Mostrar el resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
peso_payaso = 112
peso_muñeca = 75

1.Leer cantidad de payasos (payasos)
payasos = int(input("Introduce el número de payasos a enviar: "))

2.Leer cantidad de muñecas (muñecas)
muñecas = int(input("Introduce el número de muñecas a enviar: "))

3.Calcular el peso del pedido (peso_total = peso_payaso*payaso + peso_muñeca*muñeca)
peso_total = peso_payaso * payasos + peso_muñeca * muñecas

4.Leer el precio del envío por gramo.
precio = float(input("El precio por gramo del envío es de: "))

5.Calcular precio del envío.
precio_envio = peso_total * precio

6.Mostrar el resultado.
print("El precio total del envío es de: ",precio_envio,"€." )
</code></pre></div></div>

<h2 id="ejercicio-4">Ejercicio 4</h2>
<p>Diseñar el algoritmo correspondiente a un programa que pida el total de kilómetros recorridos, el precio de la gasolina (por litro), el consumo del coche (litros/100 km) y nos muestre la siguiente información:</p>
<ul>
  <li>El total de litros de gasolina que ha gastado en el trayecto.</li>
  <li>¿Cuánto dinero te ha costado la gasolina?</li>
</ul>

<h3 id="análisis-3">Análisis</h3>
<p>Problema:Tenemos que calcular el consumo de un coche, el consumo en un recorrido con determinados kilómetros y el coste del trayecto.
Entrada:kilometros_recorridos (entero), precio_gasolina (entero), consumo_coche (entero).
Salida: total_litros (entero), consumo_gasolina (entero), gasto_gasolina (entero).</p>

<h3 id="diseño-3">Diseño</h3>
<p>1.Leer kilómetros totales recorridos.
2.Leer precio gasolina.
3.Leer consumo del coche.
4.Calcular litros consumidos en el recorrido.
5.Calcular coste de gasolina en el recorrido.
6.Mostrar resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.Leer kilómetros totales recorridos.
kilometros_recorridos = float(input("Los kilómetros recorridos son: "))

2.Leer precio gasolina.
precio_gasolina = float(input("El precio de la gasolina (por litro) es: "))

3.Leer consumo del coche.
consumo_coche= float(input("El coche consume (litros/100km): "))

4.Calcular litros consumidos en el recorrido.
consumo_gasolina =consumo_coche / 100 * kilometros_recorridos
print("El coche ha gastado en ",kilometros_recorridos," un total de",consumo_gasolina,"litros de gasolina.")

5.Calcular coste de gasolina en el recorrido.
gasto_gasolina = consumo_gasolina*precio_gasolina

6.Mostrar resultado.
print("El gasto total de gasolina es de: ",gasto_gasolina,"€.")
</code></pre></div></div>

<h1 id="ejercicio-5">Ejercicio 5</h1>
<p>Suponiendo que una paella se puede cocinar exclusivamente con arroz y gambas, y que para cada cuatro personas se utiliza medio kilo de arroz y un cuarto de kilo de gambas, escribir un programa que pida por pantalla el número de comensales para la paella, el precio por kilo de los ingredientes y muestre las cantidades de los ingredientes necesarios y el coste de la misma.</p>

<h3 id="análisis-4">Análisis</h3>
<p>Problema:Te pide el número de comensales para calcular el precio por kilo de los ingredientes para una paella, muestre las cantidades y el coste de la misma.
Entrada: comensales (real), cantidad_arroz (entero), cantidad_gambas (entero), precio_gamba(entero),precio_arroz(entero).
Salida:coste_paella (entero).</p>

<h3 id="diseño-4">Diseño</h3>
<p>1.Leer el número de comensales.
2.Calcular ingredientes necesarios para la paella.
3.Leer precios del arroz y las gambas.
4.Calcular el coste total de la paella.
5.Mostrar resultado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.Leer el número de comensales.
comensales = float(input("El número total de comensales es: "))

2.Calcular ingredientes necesarios para la paella.
cantidad_arroz= comensales* 0.5/4
cantidad_gambas=comensales* 0.25/4
print("Vamos a necesitar ",cantidad_arroz, "gramos de arroz.")
print("Vamos a necesitar ",cantidad_gambas, "gramos de gambas.")

3.Leer precios del arroz y las gambas.
precio_arroz= float(input("El precio del arroz(kg) es de: "))
precio_gamba= float(input("El precio de las gambas(kg) es de: "))

4.Calcular el coste total de la paella.
coste_paella= (cantidad_arroz*precio_arroz)+(cantidad_gambas*precio_gamba)

5.Mostrar resultado.
print("La paella cuesta: ",coste_paella, "€.")
</code></pre></div></div>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[Ejercicio 1 Diseñar el algoritmo correspondiente a un programa que lea el valor correspondiente a una distancia en millas marinas y las escriba expresadas en metros.]]></summary></entry><entry><title type="html">Crear un sitio web estático con Jekyll</title><link href="/jekyll/2022/09/29/origen.html" rel="alternate" type="text/html" title="Crear un sitio web estático con Jekyll" /><published>2022-09-29T17:45:16+02:00</published><updated>2022-09-29T17:45:16+02:00</updated><id>/jekyll/2022/09/29/origen</id><content type="html" xml:base="/jekyll/2022/09/29/origen.html"><![CDATA[<p>En este post hablaremos de como crear un sitio web estático con <strong>Jekyll</strong>, un generador de sitios web estáticos.</p>

<p><img src="https://jekyllrb.com/img/jekyll-og.png" alt="Jekyll" /></p>

<h2 id="ventajas-y-desventajas">Ventajas y desventajas.</h2>
<p>En primer lugar, este tipo de sitios no requieren un hosting con soporte, ya que está compuesto de archivos HTML, CSS, y JavaScript.</p>

<p>Otras ventajas que nos encontramos es su velocodad de carga y el ahorro de costos del hosting, ya que existen servicios gratuitos para ello.</p>

<p>En cuanto a desventajas, nos encontramos que no podemos editar o crear en línea, e incluso no es posible la creación de usuarios.</p>

<h2 id="preparando-el-escenario">Preparando el escenario</h2>
<p>Para ello, vamos a realizar la instalación tanto de <strong>Jekyll</strong> y de <strong>Ruby</strong> de la siguiente manera:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ apt install jekyll
$ apt install jekyll bundler
$ apt install ruby
</code></pre></div></div>

<p>Creamos el directorio, en el que vamos a alojar nuestra web estática</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir /directorio/web
</code></pre></div></div>

<p>Y ejecutamos dentro del directorio web el comando necesario para crear nuestro sitio web estático:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ jekyll new sitio-jekyll
</code></pre></div></div>

<p>Al ejecutar el comando, se nos creará el directorio <code class="language-plaintext highlighter-rouge">sitio-jekyll</code> con la siguiente estructura:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sitio-jekyll/
  _posts/
    2022-09-29-welcome-to-jekyll.markdown
  _config.yml
  about.md
  Gemfile
  index.md
</code></pre></div></div>

<h2 id="para-qué-sirve-lo-que-hemos-creado">¿Para qué sirve lo que hemos creado?</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_posts/</code>: En este directorio se almacenarán los artículos por orden cronológico de nuestro sitio web.</li>
  <li><code class="language-plaintext highlighter-rouge">_config.yml</code>: En dicho fichero encontraremos las configuraciones que controlarán la forma en la que se generará la web y los artículos.</li>
  <li><code class="language-plaintext highlighter-rouge">Gemfile</code>: Este fichero aloja las definiciones de las dependencias o librerías adicionales de <strong>Ruby</strong> que necesitaremos para crear el sitio web (lo que sería el <code class="language-plaintext highlighter-rouge">requirements.txt</code>de <strong>Python</strong>).</li>
  <li><code class="language-plaintext highlighter-rouge">.md</code>: Los ficheros que componen el contenido de las páginas y los artículos tienen la extensión <code class="language-plaintext highlighter-rouge">markdown</code>, y luego es <strong>Jekyll</strong> es que se encargade transformar el código <strong>HTML</strong> a la hora de la compilación.</li>
</ul>

<h2 id="ejecutando-el-sitio">Ejecutando el sitio</h2>
<p>Para esto, ejecutaremos en la terminal lo siguiente:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd /directorio/web/sitio-jekyll
$ bundle exec jekyll serve
</code></pre></div></div>

<p>Tras esto, podremos ver el sitio generado en nuestro navegador, de forma local a la dirección <em>http://localhost:4000/</em></p>

<h2 id="conclusión">Conclusión</h2>
<p>A partir de ciertas herramientas, podemos desplegar una página web de forma estática, con estilo, <strong>CSS</strong>, etc… de forma rápida, sin costes y de forma eficaz.</p>]]></content><author><name></name></author><category term="jekyll" /><summary type="html"><![CDATA[En este post hablaremos de como crear un sitio web estático con Jekyll, un generador de sitios web estáticos.]]></summary></entry></feed>