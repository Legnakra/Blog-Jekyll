<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-02-14T20:03:40+01:00</updated><id>/feed.xml</id><title type="html">sysmaria</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Implantación de aplicaciones web Python en docker</title><link href="/iaw/2023/02/11/docker-python.html" rel="alternate" type="text/html" title="Implantación de aplicaciones web Python en docker" /><published>2023-02-11T16:45:16+01:00</published><updated>2023-02-11T16:45:16+01:00</updated><id>/iaw/2023/02/11/docker-python</id><content type="html" xml:base="/iaw/2023/02/11/docker-python.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>En este post vamos a configurar contenedores de Docker para ejecutar aplicaciones web Python. Para ello, vamos a utilizar una aplicación web Python sencilla que se encuentra en el repositorio de <a href="https://github.com/josedom24/django_tutorial">GitHub</a>.</p>

<h2 id="entorno-de-desarrollo">Entorno de desarrollo</h2>

<p>Vamos a crear un entorno de desarrollo en el que realizaremos las pruebas necesarias para la puesta a punto antes de lanzar nuestra aplicación en producción.</p>

<p>También vamos a crear dos contenedores que estarán conectados a la misma red. Una vez comprobado que la aplicación funciona, pasaremos a crear el docker-compose para pasarlo a producción.</p>

<h3 id="creación-de-la-red">Creación de la red</h3>

<p>Para crear la red, ejecutamos el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create net_django
</code></pre></div></div>

<h3 id="creación-del-contenedor-de-la-base-de-datos">Creación del contenedor de la base de datos</h3>

<p>Ya creada la red en la que van a ir conectados los contenedores, nos ponemos manos a la obra y creamos el contenedor de la base de datos. Para ello, ejecutamos el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="nt">--name</span> mariadb <span class="nt">-v</span> vol_polls:/var/lib/mysql <span class="nt">--network</span> net_django <span class="nt">-e</span> <span class="nv">MARIADB_ROOT_PASSWORD</span><span class="o">=</span>admin <span class="nt">-e</span> <span class="nv">MARIADB_USER</span><span class="o">=</span>django <span class="nt">-e</span> <span class="nv">MARIADB_PASSWORD</span><span class="o">=</span>admin <span class="nt">-e</span> <span class="nv">MARIADB_DATABASE</span><span class="o">=</span>django mariadb
</code></pre></div></div>

<p>Tendremos que modificar el fichero <code class="language-plaintext highlighter-rouge">settings.py</code> de la aplicación web para que sea capaz de leer las variables de entorno:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>

<span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">)))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DATABASES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'default'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'ENGINE'</span><span class="p">:</span> <span class="s">'django.db.backends.mysql'</span><span class="p">,</span>
        <span class="s">'NAME'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"BASE_DATOS"</span><span class="p">),</span>
        <span class="s">'USER'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'USUARIO'</span><span class="p">),</span>
        <span class="s">'PASSWORD'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"CONTRA"</span><span class="p">),</span>
        <span class="s">'HOST'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'HOST'</span><span class="p">),</span>
        <span class="s">'PORT'</span><span class="p">:</span> <span class="s">'3306'</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ALLOWED_HOSTS</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"ALLOWED_HOSTS"</span><span class="p">)]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">STATIC_ROOT</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">BASE_DIR</span><span class="p">,</span> <span class="s">'static'</span><span class="p">)</span>
<span class="n">STATIC_URL</span> <span class="o">=</span> <span class="s">'/static/'</span>
<span class="n">CSRF_TRUSTED_ORIGINS</span> <span class="o">=</span> <span class="p">[</span><span class="s">'http://*.mariatec.es'</span><span class="p">,</span><span class="s">'http://*.127.0.0.1'</span><span class="p">,</span><span class="s">'https://*.mariatec.es'</span><span class="p">,</span><span class="s">'https://*.127.0.0.1'</span><span class="p">]</span>
</code></pre></div></div>

<p>La estructura del directorio de la aplicación web es la siguiente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>├── practica2
│   ├── django_tutorial
│   │   ├── manage.py
│   │   ├── requirements.txt
│   ├── docker-compose.yml
│   ├── Dockerfile
│   ├── polls.sh
</code></pre></div></div>

<p>Creamos el fichero <code class="language-plaintext highlighter-rouge">Dockerfile</code> a partir de la imagen de Python:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">FROM python:3</span>
<span class="s">WORKDIR /usr/src/app</span>
<span class="s">MAINTAINER Maria Jesús Alloza Rodríguez 'mariajesus.allozarodriguez@gmail.com'</span>
<span class="s">RUN apt-get install git &amp;&amp; pip install --root-user-action=ignore --upgrade pip &amp;&amp; pip install --root-user-action=ignore django mysqlclient</span>
<span class="s">RUN git clone https://github.com/Legnakra/django_tutorial.git /usr/src/app &amp;&amp; mkdir static</span>
<span class="s">ADD ./polls.sh /usr/src/app/</span>
<span class="s">RUN chmod +x /usr/src/app/polls.sh</span>
<span class="s">ENV ALLOWED_HOSTS=*</span>
<span class="s">ENV HOST=mariadb</span>
<span class="s">ENV USUARIO=django</span>
<span class="s">ENV CONTRA=django</span>
<span class="s">ENV BASE_DATOS=django</span>
<span class="s">ENV DJANGO_SUPERUSER_PASSWORD=admin</span>
<span class="s">ENV DJANGO_SUPERUSER_USERNAME=admin</span>
<span class="s">ENV DJANGO_SUPERUSER_EMAIL=admin@example.org</span>
<span class="s">ENTRYPOINT ["/usr/src/app/polls.sh"]</span>
</code></pre></div></div>

<p>Una vez terminado de crear el fichero <code class="language-plaintext highlighter-rouge">Dockerfile</code>, creamos el fichero <code class="language-plaintext highlighter-rouge">django_polls.sh</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /bin/sh</span>

python3 manage.py makemigrations
python3 manage.py migrate
python3 manage.py createsuperuser <span class="nt">--noinput</span>
python3 manage.py collectstatic <span class="nt">--noinput</span>
python3 manage.py runserver 0.0.0.0:8006
</code></pre></div></div>

<p>Creamos la imagen de Docker:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> legnakra/django:v1 <span class="nb">.</span>
</code></pre></div></div>

<p><img src="/assets/images/docker/p2/1.png" alt="1" /></p>

<p>Ejecutando <code class="language-plaintext highlighter-rouge">docker run -d --name polls --network django-net -p 8080:8006 legnakra/django:v1</code> podemos ver que la aplicación se ejecuta correctamente.</p>

<p><img src="/assets/images/docker/p2/2.png" alt="2" /></p>

<p>Tras ver como en la imagen anterior, todo funciona correctamente, nos disponemos a crear el docker-compose que levantará los dos contenedores que hemos creado.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi docker-compose.yml
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">django-tutorial</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">django-tutorial</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">legnakra/django:v1</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">ALLOWED_HOSTS</span><span class="pi">:</span> <span class="s2">"</span><span class="s">*"</span>
      <span class="na">HOST</span><span class="pi">:</span> <span class="s">bd_mariadb_django</span>
      <span class="na">USUARIO</span><span class="pi">:</span> <span class="s">django</span>
      <span class="na">CONTRA</span><span class="pi">:</span> <span class="s">django</span>
      <span class="na">BASE_DATOS</span><span class="pi">:</span> <span class="s">django</span>
      <span class="na">DJANGO_SUPERUSER_PASSWORD</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">DJANGO_SUPERUSER_USERNAME</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">DJANGO_SUPERUSER_EMAIL</span><span class="pi">:</span> <span class="s">admin@admin.org</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8084:8006</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db_django</span>
  <span class="na">db_django</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bd_mariadb_django</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mariadb:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MARIADB_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root</span>
      <span class="na">MARIADB_DATABASE</span><span class="pi">:</span> <span class="s">django</span>
      <span class="na">MARIADB_USER</span><span class="pi">:</span> <span class="s">django</span>
      <span class="na">MARIADB_PASSWORD</span><span class="pi">:</span> <span class="s">django</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mariadb_data_django:/var/lib/mysql</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">net-mariatec</span>
<span class="na">volumes</span><span class="pi">:</span>
    <span class="na">mariadb_data_django</span><span class="pi">:</span>
<span class="na">netwoks</span><span class="pi">:</span>
  <span class="na">net-mariatec</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">net-mariatec</span>
    <span class="na">external</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<p>Levantamos el escenario de nuestro entorno de desarrollo con <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> y podemos comprobar que todo funciona correctamente.</p>

<p><img src="/assets/images/docker/p2/3.png" alt="3" /></p>

<p><img src="/assets/images/docker/p2/4.png" alt="4" /></p>

<p>Nos dirigimos a la zona de administración con las credenciales que hemos configurado en el fichero <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> y podemos ver que accedemos y podemos crear nuevas encuestas.</p>

<p><img src="/assets/images/docker/p2/5.png" alt="5" /></p>

<h2 id="entorno-de-producción">Entorno de producción</h2>

<p>Ya tenemos la aplicación funcionando en nuestro entorno de desarrollo, por lo que ahora solo queda que nos vayamos al entorno de producción y despleguemos la aplicación.</p>

<p>Para ello, nos vamos a crear un registro en nuestro servidor DNS para que podamos acceder a la aplicación desde el exterior.</p>

<p>⬜️ django.mariatec.es        CNAME    mariatec.es</p>

<p>Generamos el certificado SSL para poder acceder a la aplicación desde el exterior.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certbot certonly <span class="nt">--standalone</span> <span class="nt">-d</span> django.mariatec.com
</code></pre></div></div>

<p><img src="/assets/images/docker/p2/6.png" alt="6" /></p>

<p>Tras generarlos, creamos el proxy de nginx para poder acceder a la aplicación desde el exterior.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /etc/nginx/sites-available/django.mariatec.es
</code></pre></div></div>

<p>recuerda que debe ser escuchado por elpuerto 8084.</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
        <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
        <span class="kn">listen</span> <span class="s">[::]:80</span><span class="p">;</span>

        <span class="kn">server_name</span> <span class="s">django.mariatec.es</span><span class="p">;</span>

        <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
        <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>
        <span class="kn">listen</span> <span class="s">[::]:443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>

        <span class="kn">ssl</span>    <span class="no">on</span><span class="p">;</span>
        <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/django.mariatec.es/fullchain.pem</span><span class="p">;</span>
        <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/django.mariatec.es/privkey.pem</span><span class="p">;</span>

        <span class="kn">index</span> <span class="s">index.html</span> <span class="s">index.php</span> <span class="s">index.htm</span> <span class="s">index.nginx-debian.html</span><span class="p">;</span>

        <span class="kn">server_name</span> <span class="s">django.mariatec.es</span><span class="p">;</span>

        <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
                <span class="kn">proxy_pass</span> <span class="s">http://localhost:8084</span><span class="p">;</span>
                <span class="kn">include</span> <span class="s">proxy_params</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Creamos el enlace simbólico para que nginx pueda cargar la configuración y reniciamos el servicio de nginx.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/django /etc/nginx/sites-enabled/django

systemctl restart nginx
</code></pre></div></div>

<p>Si accedemos desde nuestro navegador a la dirección <code class="language-plaintext highlighter-rouge">https://django.mariatec.es</code> podemos ver que accedemos a la aplicación.</p>

<p><img src="/assets/images/docker/p2/7.png" alt="7" /></p>

<p>Y que podemos acceder a la zona de administración.</p>

<p><img src="/assets/images/docker/p2/8.png" alt="8" /></p>

<p><img src="/assets/images/docker/p2/9.png" alt="9" /></p>

<p><img src="/assets/images/docker/p2/10.png" alt="10" /></p>

<p><img src="/assets/images/docker/p2/11.png" alt="11" /></p>]]></content><author><name></name></author><category term="IAW" /><summary type="html"><![CDATA[Introducción En este post vamos a configurar contenedores de Docker para ejecutar aplicaciones web Python. Para ello, vamos a utilizar una aplicación web Python sencilla que se encuentra en el repositorio de GitHub. Entorno de desarrollo Vamos a crear un entorno de desarrollo en el que realizaremos las pruebas necesarias para la puesta a punto antes de lanzar nuestra aplicación en producción. También vamos a crear dos contenedores que estarán conectados a la misma red. Una vez comprobado que la aplicación funciona, pasaremos a crear el docker-compose para pasarlo a producción. Creación de la red Para crear la red, ejecutamos el siguiente comando: docker network create net_django Creación del contenedor de la base de datos Ya creada la red en la que van a ir conectados los contenedores, nos ponemos manos a la obra y creamos el contenedor de la base de datos. Para ello, ejecutamos el siguiente comando: docker run -d --name mariadb -v vol_polls:/var/lib/mysql --network net_django -e MARIADB_ROOT_PASSWORD=admin -e MARIADB_USER=django -e MARIADB_PASSWORD=admin -e MARIADB_DATABASE=django mariadb Tendremos que modificar el fichero settings.py de la aplicación web para que sea capaz de leer las variables de entorno: import os BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': os.environ.get("BASE_DATOS"), 'USER': os.environ.get('USUARIO'), 'PASSWORD': os.environ.get("CONTRA"), 'HOST': os.environ.get('HOST'), 'PORT': '3306', } } ALLOWED_HOSTS = [os.environ.get("ALLOWED_HOSTS")] STATIC_ROOT = os.path.join(BASE_DIR, 'static') STATIC_URL = '/static/' CSRF_TRUSTED_ORIGINS = ['http://*.mariatec.es','http://*.127.0.0.1','https://*.mariatec.es','https://*.127.0.0.1'] La estructura del directorio de la aplicación web es la siguiente: ├── practica2 │   ├── django_tutorial │   │   ├── manage.py │   │   ├── requirements.txt │   ├── docker-compose.yml │   ├── Dockerfile │   ├── polls.sh Creamos el fichero Dockerfile a partir de la imagen de Python: FROM python:3 WORKDIR /usr/src/app MAINTAINER Maria Jesús Alloza Rodríguez 'mariajesus.allozarodriguez@gmail.com' RUN apt-get install git &amp;&amp; pip install --root-user-action=ignore --upgrade pip &amp;&amp; pip install --root-user-action=ignore django mysqlclient RUN git clone https://github.com/Legnakra/django_tutorial.git /usr/src/app &amp;&amp; mkdir static ADD ./polls.sh /usr/src/app/ RUN chmod +x /usr/src/app/polls.sh ENV ALLOWED_HOSTS=* ENV HOST=mariadb ENV USUARIO=django ENV CONTRA=django ENV BASE_DATOS=django ENV DJANGO_SUPERUSER_PASSWORD=admin ENV DJANGO_SUPERUSER_USERNAME=admin ENV DJANGO_SUPERUSER_EMAIL=admin@example.org ENTRYPOINT ["/usr/src/app/polls.sh"] Una vez terminado de crear el fichero Dockerfile, creamos el fichero django_polls.sh: #! /bin/sh python3 manage.py makemigrations python3 manage.py migrate python3 manage.py createsuperuser --noinput python3 manage.py collectstatic --noinput python3 manage.py runserver 0.0.0.0:8006 Creamos la imagen de Docker: docker build -t legnakra/django:v1 . Ejecutando docker run -d --name polls --network django-net -p 8080:8006 legnakra/django:v1 podemos ver que la aplicación se ejecuta correctamente. Tras ver como en la imagen anterior, todo funciona correctamente, nos disponemos a crear el docker-compose que levantará los dos contenedores que hemos creado. vi docker-compose.yml version: '3.7' services: django-tutorial: container_name: django-tutorial image: legnakra/django:v1 restart: always environment: ALLOWED_HOSTS: "*" HOST: bd_mariadb_django USUARIO: django CONTRA: django BASE_DATOS: django DJANGO_SUPERUSER_PASSWORD: admin DJANGO_SUPERUSER_USERNAME: admin DJANGO_SUPERUSER_EMAIL: admin@admin.org ports: - 8084:8006 depends_on: - db_django db_django: container_name: bd_mariadb_django image: mariadb:latest restart: always environment: MARIADB_ROOT_PASSWORD: root MARIADB_DATABASE: django MARIADB_USER: django MARIADB_PASSWORD: django volumes: - mariadb_data_django:/var/lib/mysql networks: - net-mariatec volumes: mariadb_data_django: netwoks: net-mariatec: name: net-mariatec external: true Levantamos el escenario de nuestro entorno de desarrollo con docker-compose up -d y podemos comprobar que todo funciona correctamente. Nos dirigimos a la zona de administración con las credenciales que hemos configurado en el fichero docker-compose.yml y podemos ver que accedemos y podemos crear nuevas encuestas. Entorno de producción Ya tenemos la aplicación funcionando en nuestro entorno de desarrollo, por lo que ahora solo queda que nos vayamos al entorno de producción y despleguemos la aplicación. Para ello, nos vamos a crear un registro en nuestro servidor DNS para que podamos acceder a la aplicación desde el exterior. ⬜️ django.mariatec.es CNAME mariatec.es Generamos el certificado SSL para poder acceder a la aplicación desde el exterior. certbot certonly --standalone -d django.mariatec.com Tras generarlos, creamos el proxy de nginx para poder acceder a la aplicación desde el exterior. vi /etc/nginx/sites-available/django.mariatec.es recuerda que debe ser escuchado por elpuerto 8084. server { listen 80; listen [::]:80; server_name django.mariatec.es; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; ssl on; ssl_certificate /etc/letsencrypt/live/django.mariatec.es/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/django.mariatec.es/privkey.pem; index index.html index.php index.htm index.nginx-debian.html; server_name django.mariatec.es; location / { proxy_pass http://localhost:8084; include proxy_params; } } Creamos el enlace simbólico para que nginx pueda cargar la configuración y reniciamos el servicio de nginx. ln -s /etc/nginx/sites-available/django /etc/nginx/sites-enabled/django systemctl restart nginx Si accedemos desde nuestro navegador a la dirección https://django.mariatec.es podemos ver que accedemos a la aplicación. Y que podemos acceder a la zona de administración.]]></summary></entry><entry><title type="html">Implantación de aplicaciones web PHP en docker</title><link href="/iaw/2023/02/09/docker-bookmedik.html" rel="alternate" type="text/html" title="Implantación de aplicaciones web PHP en docker" /><published>2023-02-09T16:45:16+01:00</published><updated>2023-02-09T16:45:16+01:00</updated><id>/iaw/2023/02/09/docker-bookmedik</id><content type="html" xml:base="/iaw/2023/02/09/docker-bookmedik.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>En este post vamos a reaizar la implantación de una aplicación web PHP en docker. Vamos a hacer uso de <a href="https://github.com/evilnapsis/bookmedik">Bookmedik</a>. Crearemos una imagen Docker para implementar dicha aplicación.</p>

<h2 id="aspectos-a-tener-en-cuenta">Aspectos a tener en cuenta</h2>

<ul>
  <li>Contenedor mariadb
    <ul>
      <li>Es necesario que nuestra aplicación guarde su información en un contenedor docker mariadb.</li>
      <li>El script para generar la base de datos y los registros lo encuentras en el repositorio y se llama schema.sql. Deberemos crear un usuario con su contraseña en la base de datos. La base de datos se llama bookmedik y se crea al ejecutar el script.</li>
      <li>Ejecuta el contenedor mariadb y carga los datos del script schema.sql. Para más información.</li>
      <li>El contenedor mariadb debe tener un volumen para guardar la base de datos.</li>
    </ul>
  </li>
  <li>Contenedor bookmedik
    <ul>
      <li>Vamos a crear tres versiones de la imagen que nos permite implantar la aplicación PHP.</li>
      <li>La imagen deberá crear las variables de entorno necesarias con datos de conexión por defecto.</li>
      <li>Al crear un contenedor a partir de estas imágenes se ejecutará un script bash que realizará las siguientes tareas:
        <ul>
          <li>Que modifique el fichero <code class="language-plaintext highlighter-rouge">core\controller\Database.php</code> para que lea las variables de entorno. Para obtener las variables de entorno en PHP usar la función getenv. Para más información.</li>
          <li>Que se inicialice la base de datos con el fichero <code class="language-plaintext highlighter-rouge">schema.sql</code>.</li>
          <li>Que ejecute el servidor web.</li>
        </ul>
      </li>
      <li>El contenedor que crearemos debe tener un volumen para guardar los logs del servidor web.</li>
      <li>La imagen la tenemos que crear en tu entorno de desarrollo con el comando docker build.</li>
    </ul>
  </li>
</ul>

<h2 id="preparamos-el-escenario">Preparamos el escenario</h2>

<p>Lo primero que deberemos hacer es cerciorarnos de que tenemos instalado docker en nuestro entorno de desarrollo. Para ello, ejecutamos el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nt">--version</span>
</code></pre></div></div>

<p>En caso de no tenerlo, lo instalaremos con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>docker.io docker compose
</code></pre></div></div>

<p>Clonamos el repositorio de la aplicación web:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/evilnapsis/bookmedik.git
</code></pre></div></div>

<h2 id="tarea-1-creación-de-una-imagen-docker-con-una-aplicación-web-desde-una-imagen-base">Tarea 1: Creación de una imagen docker con una aplicación web desde una imagen base</h2>

<p>Llegados a este punto, y teniendo el repositorio forkado a nuestro usuario, vamos a modificar el fichero <code class="language-plaintext highlighter-rouge">schema.sql</code> para que se ejecute al crear el contenedor. Por ello, deberemos eliminar las siguientes líneas:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">bookmedik</span><span class="p">;</span>
<span class="n">USE</span> <span class="n">bookmedik</span><span class="p">;</span>
</code></pre></div></div>

<p>Nos dirigimos al fichero <code class="language-plaintext highlighter-rouge">core/controller/Database.php</code> para que lea las variables de entorno. Para ello, debemos modificar las siguientes líneas:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="kd">class</span> <span class="nc">Database</span> <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="nv">$db</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">static</span> <span class="nv">$con</span><span class="p">;</span>
        <span class="k">function</span> <span class="n">Database</span><span class="p">(){</span>
                <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">=</span><span class="nb">getenv</span><span class="p">(</span><span class="s1">'USUARIO_BOOKMEDIK'</span><span class="p">);</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">pass</span><span class="o">=</span><span class="nb">getenv</span><span class="p">(</span><span class="s1">'CONTRA_BOOKMEDIK'</span><span class="p">);</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">=</span><span class="nb">getenv</span><span class="p">(</span><span class="s1">'DATABASE_HOST'</span><span class="p">);</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">ddbb</span><span class="o">=</span><span class="nb">getenv</span><span class="p">(</span><span class="s1">'NOMBRE_DB'</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">function</span> <span class="n">connect</span><span class="p">(){</span>
                <span class="nv">$con</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">mysqli</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">user</span><span class="p">,</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">pass</span><span class="p">,</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">ddbb</span><span class="p">);</span>
                <span class="nv">$con</span><span class="o">-&gt;</span><span class="nf">query</span><span class="p">(</span><span class="s2">"set sql_mode=''"</span><span class="p">);</span>
                <span class="k">return</span> <span class="nv">$con</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="n">getCon</span><span class="p">(){</span>
                <span class="k">if</span><span class="p">(</span><span class="k">self</span><span class="o">::</span><span class="nv">$con</span><span class="o">==</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="o">::</span><span class="nv">$db</span><span class="o">==</span><span class="kc">null</span><span class="p">){</span>
                        <span class="k">self</span><span class="o">::</span><span class="nv">$db</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Database</span><span class="p">();</span>
                        <span class="k">self</span><span class="o">::</span><span class="nv">$con</span> <span class="o">=</span> <span class="k">self</span><span class="o">::</span><span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">connect</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="k">self</span><span class="o">::</span><span class="nv">$con</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>Ya teniendo todo esto realizado, vamos a crear el fichero <code class="language-plaintext highlighter-rouge">Dockerfile</code> para crear la imagen docker. Para ello, debemos crear un fichero llamado <code class="language-plaintext highlighter-rouge">Dockerfile</code> en la raíz del proyecto y añadir el siguiente contenido:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> debian:bullseye</span>
<span class="k">MAINTAINER</span><span class="s"> María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com"</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get upgrade <span class="nt">-y</span> <span class="o">&amp;&amp;</span> apt-get <span class="nb">install </span>apache2 libapache2-mod-php php php-mysql mariadb-client <span class="nt">-y</span> <span class="o">&amp;&amp;</span> apt-get clean <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/apt/lists/<span class="k">*</span>
<span class="k">COPY</span><span class="s"> bookmedik /var/www/html/</span>
<span class="k">ADD</span><span class="s"> script.sh /opt/</span>
<span class="k">RUN </span><span class="nb">chmod</span> +x /opt/script.sh <span class="o">&amp;&amp;</span> <span class="nb">rm</span> /var/www/html/index.html
<span class="k">ENTRYPOINT</span><span class="s"> ["/opt/script.sh"]</span>
</code></pre></div></div>

<p>Y el fichero <code class="language-plaintext highlighter-rouge">script.sh</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /bin/sh</span>

mysql <span class="nt">-u</span> <span class="nv">$USUARIO_BOOKMEDIK</span> <span class="nt">--password</span><span class="o">=</span><span class="nv">$CONTRA_BOOKMEDIK</span> <span class="nt">-h</span> <span class="nv">$DATABASE_HOST</span> <span class="nv">$NOMBRE_DB</span> &lt; /var/www/html/schema.sql

/usr/sbin/apache2ctl <span class="nt">-D</span> FOREGROUND
</code></pre></div></div>

<p>El script que hemos creado, tendrá como destino el directorio raíz del repositorio, para añadirlo al contenedor. Y ya podríamos crear la imagen del contenedor con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> legnakra/bookmedik:v1 <span class="nb">.</span>
</code></pre></div></div>

<p>Si ejecutamos <code class="language-plaintext highlighter-rouge">docker images</code>, podremos ver que la imagen se ha creado correctamente:</p>

<h2 id="tarea-2-despliegue-en-el-entorno-de-desarrollo">Tarea 2: Despliegue en el entorno de desarrollo</h2>

<p>En esta tarea, crearemos un scritp con docker-compose que levantará el escenario con los contenedores. Debemos tener en cuenta que para acceder a la aplicación, las credenciales serán: <code class="language-plaintext highlighter-rouge">Usuario: admin // contraseña: admin.</code></p>

<p>Por ello, creamos el fichero <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> para levantar ambos contenedores:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">bookmedik</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bookmedik-app</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">legnakra/bookmedik:v1</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">USUARIO_BOOKMEDIK</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">CONTRA_BOOKMEDIK</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">DATABASE_HOST</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
      <span class="na">NOMBRE_DB</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8081:80</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mariadb</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MARIADB_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root</span>
      <span class="na">MARIADB_DATABASE</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">MARIADB_USER</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">MARIADB_PASSWORD</span><span class="pi">:</span> <span class="s">admin</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mariadb_data:/var/lib/mysql</span>
<span class="na">volumes</span><span class="pi">:</span>
    <span class="na">mariadb_data</span><span class="pi">:</span>
</code></pre></div></div>

<p>Levantamos el escenario con <code class="language-plaintext highlighter-rouge">docker compose up -d</code>y con <code class="language-plaintext highlighter-rouge">docker ps</code> podemos ver que los contenedores se han levantado correctamente:</p>

<p><img src="/assets/images/docker/p1/1.png" alt="1" /></p>

<p>Si accedemos a la aplicación, podremos ver que funciona correctamente:</p>

<p><img src="/assets/images/docker/p1/2.png" alt="2" /></p>

<h2 id="tarea-3-creación-de-una-imagen-docker-con-una-aplicación-web-desde-una-imagen-php">Tarea 3: Creación de una imagen docker con una aplicación web desde una imagen PHP</h2>

<p>Ahora le toca el turno a la imagen de PHP. Para ello, crearemos un fichero llamado <code class="language-plaintext highlighter-rouge">Dockerfile</code> en la raíz del proyecto y añadiremos el siguiente contenido:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> php:7.4-apache-bullseye</span>
<span class="k">MAINTAINER</span><span class="s"> María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com"</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get upgrade <span class="nt">-y</span> <span class="o">&amp;&amp;</span> docker-php-ext-install mysqli pdo pdo_mysql <span class="o">&amp;&amp;</span> apt-get <span class="nb">install </span>mariadb-client <span class="nt">-y</span> <span class="o">&amp;&amp;</span> apt-get clean <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/apt/lists/<span class="k">*</span>
<span class="k">ADD</span><span class="s"> bookmedik /var/www/html/</span>
<span class="k">ADD</span><span class="s"> script.sh /opt/</span>
<span class="k">RUN </span><span class="nb">chmod</span> +x /opt/script.sh
<span class="k">ENTRYPOINT</span><span class="s"> ["/opt/script.sh"]</span>
</code></pre></div></div>

<p>Y creamos una nueva imagen:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> legnakra/bookmedik:v2 <span class="nb">.</span>
</code></pre></div></div>

<p>EL fichero <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> quedaría de la siguiente forma:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">bookmedik</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bookmedik-app</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">legnakra/bookmedik:v2</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">USUARIO_BOOKMEDIK</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">CONTRA_BOOKMEDIK</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">DATABASE_HOST</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
      <span class="na">NOMBRE_DB</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8081:80</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mariadb:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MARIADB_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root</span>
      <span class="na">MARIADB_DATABASE</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">MARIADB_USER</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">MARIADB_PASSWORD</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mariadb_data:/var/lib/mysql</span>
<span class="na">volumes</span><span class="pi">:</span>
    <span class="na">mariadb_data</span><span class="pi">:</span>
</code></pre></div></div>

<p>Realizamos el despliegue con <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> y como vemos en la imagen anterior, ambos contenedores se están ejecutando y en la siguiente, comprobamos que la imagen se ha creado correctamente:</p>

<p><img src="/assets/images/docker/p1/3.png" alt="3" /></p>

<p>Si accedemos a la aplicación, podremos ver que funciona correctamente:</p>

<p><img src="/assets/images/docker/p1/4.png" alt="4" /></p>

<p><img src="/assets/images/docker/p1/5.png" alt="5" /></p>

<h2 id="tarea-4-ejecución-de-una-aplicación-php-en-docker-con-nginx">Tarea 4: Ejecución de una aplicación PHP en docker con nginx</h2>

<p>En esta tarea, vamos a tener que crear dos imágenes:</p>
<ul>
  <li>Una que contrendrá la aplicación PHP y será nginx la encargada de servirla.</li>
  <li>Otra que tendrá los modulos de PHP necesarios para que la aplicación funcione.</li>
</ul>

<p>Creamos el <code class="language-plaintext highlighter-rouge">Dockerfile</code> con php-fpm y sus correspondientes modulos:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> php:7.4-fpm</span>
<span class="k">MAINTAINER</span><span class="s"> María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com"</span>
<span class="k">RUN </span>docker-php-ext-install mysqli
</code></pre></div></div>

<p>Creamos la imagen:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> legnakra/php-fpm-mysql:v1 <span class="nb">.</span>
</code></pre></div></div>

<p><img src="/assets/images/docker/p1/6.png" alt="6" /></p>

<p>Para crear el dockerfile con la aplicación y nginx como servidor web, añadimos el siguiente contenido:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> nginx</span>
<span class="k">MAINTAINER</span><span class="s"> María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com"</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get upgrade <span class="nt">-y</span> <span class="o">&amp;&amp;</span> apt-get <span class="nb">install </span>mariadb-client <span class="nt">-y</span> <span class="o">&amp;&amp;</span> apt-get clean <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/apt/lists/<span class="k">*</span>
<span class="k">ADD</span><span class="s"> default.conf /etc/nginx/conf.d/</span>
<span class="k">ADD</span><span class="s"> bookmedik /usr/share/nginx/html</span>
<span class="k">ADD</span><span class="s"> script.sh /opt/</span>
<span class="k">RUN </span><span class="nb">chmod</span> +x /opt/script.sh <span class="o">&amp;&amp;</span> <span class="nb">rm</span> /usr/share/nginx/html/index.html
<span class="k">ENTRYPOINT</span><span class="s"> ["/opt/script.sh"]</span>
</code></pre></div></div>

<p>En el docker file anterior, hemos establecido el fichero <code class="language-plaintext highlighter-rouge">default.conf</code> como el fichero de configuración de nginx. Este fichero contendrá la siguiente información:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">nano</span> <span class="s">default.conf</span>

<span class="s">server</span> <span class="p">{</span>
    <span class="kn">listen</span>       <span class="mi">80</span><span class="p">;</span>
    <span class="kn">listen</span>  <span class="s">[::]:80</span><span class="p">;</span>
    <span class="kn">server_name</span>  <span class="s">localhost</span><span class="p">;</span>
    <span class="kn">error_log</span>  <span class="n">/var/log/nginx/error.log</span><span class="p">;</span>
    <span class="kn">access_log</span> <span class="n">/var/log/nginx/access.log</span><span class="p">;</span>
    <span class="kn">root</span>   <span class="n">/usr/share/nginx/html</span><span class="p">;</span>
    <span class="kn">index</span>  <span class="s">index.php</span> <span class="s">index.html</span><span class="p">;</span>

    <span class="kn">location</span> <span class="p">~</span> <span class="sr">\.php$</span> <span class="p">{</span>
        <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>
        <span class="kn">fastcgi_split_path_info</span> <span class="s">^(.+</span><span class="err">\</span><span class="s">.php)(/.+)</span>$<span class="p">;</span>
        <span class="kn">fastcgi_pass</span> <span class="s">book_php:9000</span><span class="p">;</span>
        <span class="kn">fastcgi_index</span> <span class="s">index.php</span><span class="p">;</span>
        <span class="kn">include</span> <span class="s">fastcgi_params</span><span class="p">;</span>
        <span class="kn">fastcgi_param</span> <span class="s">SCRIPT_FILENAME</span> <span class="nv">$document_root$fastcgi_script_name</span><span class="p">;</span>
        <span class="kn">fastcgi_param</span> <span class="s">PATH_INFO</span> <span class="nv">$fastcgi_path_info</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Y también deberemos modificar <code class="language-plaintext highlighter-rouge">script.sh</code> para adaptarlo a nginx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /bin/sh</span>

<span class="nb">sleep </span>10

mysql <span class="nt">-u</span> <span class="nv">$USUARIO_BOOKMEDIK</span> <span class="nt">--password</span><span class="o">=</span><span class="nv">$CONTRA_BOOKMEDIK</span> <span class="nt">-h</span> <span class="nv">$DATABASE_HOST</span> <span class="nv">$NOMBRE_DB</span> &lt; /usr/share/nginx/html/schema.sql

nginx <span class="nt">-g</span> <span class="s2">"daemon off;"</span>
</code></pre></div></div>

<p>Creamos la imagen:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> legnakra/bookmedik:v3 <span class="nb">.</span>
</code></pre></div></div>

<p><img src="/assets/images/docker/p1/7.png" alt="7" /></p>

<p>Antes de modificar el <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> debemos tener en cuenta que:</p>
<ul>
  <li>Los contenedores que tienen php-fpm y nginx, deben estar en la misma ruta.</li>
  <li>Las variables de entorno que se pasan al contenedor de nginx, deben también estar en el contenedor de php-fpm.</li>
</ul>

<p>Por lo que el fichero <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> quedaría de la siguiente forma:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">bookmedik</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bookmedik-app</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">legnakra/bookmedik:v3</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">USUARIO_BOOKMEDIK</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">CONTRA_BOOKMEDIK</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">DATABASE_HOST</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
      <span class="na">NOMBRE_DB</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8082:80</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
      <span class="pi">-</span> <span class="s">php</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">phpdocs:/usr/share/nginx/html/</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mariadb</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MARIADB_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root</span>
      <span class="na">MARIADB_DATABASE</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">MARIADB_USER</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">MARIADB_PASSWORD</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mariadb_data:/var/lib/mysql</span>
  <span class="na">php</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">book_php</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">legnakra/php-fpm-mysql:v1</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">USUARIO_BOOKMEDIK</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">CONTRA_BOOKMEDIK</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">DATABASE_HOST</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
      <span class="na">NOMBRE_DB</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">phpdocs:/usr/share/nginx/html/</span> 

<span class="na">volumes</span><span class="pi">:</span>
    <span class="na">mariadb_data</span><span class="pi">:</span>
    <span class="na">phpdocs</span><span class="pi">:</span>
</code></pre></div></div>

<p>Tras todos los pasos anteriores, podemos cerciorarnos en la imagen anterior, que las imágenes que hemos confeccionado se han creado correctamente.</p>

<p>Ahora, ejecutamos el <code class="language-plaintext highlighter-rouge">docker compose.yaml</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>

<p><img src="/assets/images/docker/p1/8.png" alt="8" /></p>

<p>Y comprobamos que todo funciona como esperábamos:</p>

<p><img src="/assets/images/docker/p1/9.png" alt="9" /></p>

<p>Si accedemos a la aplicación, podremos ver que funciona correctamente:</p>

<p><img src="/assets/images/docker/p1/10.png" alt="10" /></p>

<p><img src="/assets/images/docker/p1/11.png" alt="11" /></p>

<h2 id="tarea-5-puesta-en-producción-de-nuestra-aplicación">Tarea 5: Puesta en producción de nuestra aplicación</h2>

<p>Vamos a poner en producción la aplicación a través de nuestro VPS, por lo que lo primero que deberemo de hacer es crear un registro CNAME en nuestro DNS para que apunte a la IP de nuestro VPS.</p>

<p>⬜️ bookmedik.mariatec.es     CNAME       mariatec.es</p>

<p>Y le generamos un certificado de <code class="language-plaintext highlighter-rouge">Let's Encrypt</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certbot certonly <span class="nt">--standalone</span> <span class="nt">-d</span> bookmedik.mariatec.es
</code></pre></div></div>

<p>Instalamos docker y docker-compose en nuestro VPS:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span> <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt <span class="nb">install </span>docker.io docker-compose-plugin <span class="nt">-y</span>
</code></pre></div></div>

<p>Al tener las imágenes creadas subidas a Docker Hub, podemos descargarlas en nuestro VPS:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull legnakra/bookmedik:v2
</code></pre></div></div>

<p>En mi caso he elegido la versión 2, ya que es la que tiene el fichero <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> adaptado para el VPS.</p>

<p>Creamos el virtualhost en nginx para que actúe de proxy inverso:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /etc/nginx/sites-available/bookmedik.mariatec.es
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server <span class="o">{</span>
        listen 80<span class="p">;</span>
        listen <span class="o">[</span>::]:80<span class="p">;</span>

        server_name bookmedik.mariatec.es<span class="p">;</span>

        <span class="k">return </span>301 https://<span class="nv">$host$request_uri</span><span class="p">;</span>
<span class="o">}</span>

server <span class="o">{</span>
        listen 443 ssl http2<span class="p">;</span>
        listen <span class="o">[</span>::]:443 ssl http2<span class="p">;</span>

        ssl    on<span class="p">;</span>
        ssl_certificate /etc/letsencrypt/live/bookmedik.mariatec.es/fullchain.pem<span class="p">;</span>
        ssl_certificate_key     /etc/letsencrypt/live/bookmedik.mariatec.es/privkey.pem<span class="p">;</span>

        index index.html index.php index.htm index.nginx-debian.html<span class="p">;</span>

        server_name bookmedik.mariatec.es<span class="p">;</span>

        location / <span class="o">{</span>
                proxy_pass http://localhost:8083<span class="p">;</span>
                include proxy_params<span class="p">;</span>
        <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Creamos el enlace simbólico y reiniciamos nginx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/bookmedik /etc/nginx/sites-enabled/
systemctl restart nginx
</code></pre></div></div>

<p>En mi caso, he subido los ficheros a github, por lo que he clonado <a href="https://github.com/Legnakra/Docker-Bookmedik/tree/main/Tarea%204">el repositorio</a> y el repositorio de <a href="https://github.com/evilnapsis/bookmedik">Bookmedik</a> en mi VPS, dejando la estructura de carpetas de la siguiente forma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>├── Bookmedik
│   ├── docker-compose.yaml
│   ├── Dockerfile
│   ├── scripts
│   ├── bookmedik
│   │   ├── PhpWord
│   │   ├── core
│   │   ├── assets
│   │   ├── report
│   │   ├── index.php
│   │   ├── instalation.txt
│   │   ├── schema.sql
│   │   ├── logout.php
│   │   ├── README.md
</code></pre></div></div>

<p>Realizamos la ejecución del comando <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> y comprobamos que todo funciona correctamente:</p>

<p><img src="/assets/images/docker/p1/12.png" alt="12" /></p>

<p>Y como podemos comprobar en la siguiente imagen, la aplicación funciona correctamente.</p>

<p><img src="/assets/images/docker/p1/13.png" alt="13" /></p>

<p><strong>NOTA</strong>: A la hora de hacer el despliegue, debemos cerciorarnos de cambiar el puerto de escucha, dado que puede caber la posibilidad (o que sea muy probable) de que el puerto 8080 esté ocupado. En mi caso, he puesto el puerto de escucha en el 8083 debido a que ya tengo aplicaciones desplegadas en mi VPS.</p>

<p><img src="/assets/images/docker/p1/14.png" alt="14" /></p>

<h2 id="tarea-6-modificación-de-la-aplicación">Tarea 6: Modificación de la aplicación</h2>

<p>Vamos a modificar la aplicación para que nos muestre nuestro nombre en la línea <code class="language-plaintext highlighter-rouge">&lt;h4 class="title"&gt;Acceder a BookMedik&lt;/h4&gt;</code>.</p>

<p>Para ello, vamos a utilizar la imagen de <code class="language-plaintext highlighter-rouge">legnakra/bookmedik:v1</code> que ya tiene el fichero <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> para generar la nueva imagen.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano <span class="sb">`</span>core/app/view/login-view.php<span class="sb">`</span>
<span class="nt">---</span>
&lt;h4 <span class="nv">class</span><span class="o">=</span><span class="s2">"title"</span><span class="o">&gt;</span>María Jesús Alloza Rodríguez&lt;/h4&gt;
</code></pre></div></div>

<p><img src="/assets/images/docker/p1/15.png" alt="15" /></p>

<p>Creamos la nueva imagen</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> legnakra/bookmedik:v1_2 <span class="nb">.</span>
</code></pre></div></div>
<p><img src="/assets/images/docker/p1/16.png" alt="16" /></p>

<p>La resubimos a DockerHub:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker push legnakra/bookmedik:v1_2
</code></pre></div></div>

<p>Eliminamos los contenedores que están en ejecución, modificamos el fichero <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> para que descargue la nueva imagen y ejecutamos el <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose down
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano docker-compose.yaml
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">bookmedik</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bookmedik-app</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">legnakra/bookmedik:v1_2</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">USUARIO_BOOKMEDIK</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">CONTRA_BOOKMEDIK</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">DATABASE_HOST</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
      <span class="na">NOMBRE_DB</span><span class="pi">:</span> <span class="s">bookmedik</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8081:80</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">bd_mariadb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mariadb</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MARIADB_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root</span>
      <span class="na">MARIADB_DATABASE</span><span class="pi">:</span> <span class="s">bookmedik</span>
      <span class="na">MARIADB_USER</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">MARIADB_PASSWORD</span><span class="pi">:</span> <span class="s">admin</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mariadb_data:/var/lib/mysql</span>
<span class="na">volumes</span><span class="pi">:</span>
    <span class="na">mariadb_data</span><span class="pi">:</span>
</code></pre></div></div>

<p><img src="/assets/images/docker/p1/17.png" alt="17" /></p>

<p>Y con esto daríamos terminado como desplegar una aplicación PHP en un VPS con contenedores Docker.</p>

<h2 id="conclusiones">Conclusiones</h2>

<p>Docker es una herramienta muy útil para el despliegue de aplicaciones, ya que nos permite crear contenedores que contienen todo lo necesario para que la aplicación funcione correctamente. Además, nos permite crear imágenes que podemos subir a Docker Hub para que otras personas puedan descargarlas y utilizarlas.</p>

<h2 id="bibliografía">Bibliografía</h2>

<p><a href="https://www.docker.com/">https://www.docker.com/</a></p>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04-es">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04-es</a></p>]]></content><author><name></name></author><category term="IAW" /><summary type="html"><![CDATA[Introducción En este post vamos a reaizar la implantación de una aplicación web PHP en docker. Vamos a hacer uso de Bookmedik. Crearemos una imagen Docker para implementar dicha aplicación. Aspectos a tener en cuenta Contenedor mariadb Es necesario que nuestra aplicación guarde su información en un contenedor docker mariadb. El script para generar la base de datos y los registros lo encuentras en el repositorio y se llama schema.sql. Deberemos crear un usuario con su contraseña en la base de datos. La base de datos se llama bookmedik y se crea al ejecutar el script. Ejecuta el contenedor mariadb y carga los datos del script schema.sql. Para más información. El contenedor mariadb debe tener un volumen para guardar la base de datos. Contenedor bookmedik Vamos a crear tres versiones de la imagen que nos permite implantar la aplicación PHP. La imagen deberá crear las variables de entorno necesarias con datos de conexión por defecto. Al crear un contenedor a partir de estas imágenes se ejecutará un script bash que realizará las siguientes tareas: Que modifique el fichero core\controller\Database.php para que lea las variables de entorno. Para obtener las variables de entorno en PHP usar la función getenv. Para más información. Que se inicialice la base de datos con el fichero schema.sql. Que ejecute el servidor web. El contenedor que crearemos debe tener un volumen para guardar los logs del servidor web. La imagen la tenemos que crear en tu entorno de desarrollo con el comando docker build. Preparamos el escenario Lo primero que deberemos hacer es cerciorarnos de que tenemos instalado docker en nuestro entorno de desarrollo. Para ello, ejecutamos el siguiente comando: $ docker --version En caso de no tenerlo, lo instalaremos con el siguiente comando: sudo apt install docker.io docker compose Clonamos el repositorio de la aplicación web: git clone https://github.com/evilnapsis/bookmedik.git Tarea 1: Creación de una imagen docker con una aplicación web desde una imagen base Llegados a este punto, y teniendo el repositorio forkado a nuestro usuario, vamos a modificar el fichero schema.sql para que se ejecute al crear el contenedor. Por ello, deberemos eliminar las siguientes líneas: CREATE DATABASE bookmedik; USE bookmedik; Nos dirigimos al fichero core/controller/Database.php para que lea las variables de entorno. Para ello, debemos modificar las siguientes líneas: &lt;?php class Database { public static $db; public static $con; function Database(){ $this-&gt;user=getenv('USUARIO_BOOKMEDIK');$this-&gt;pass=getenv('CONTRA_BOOKMEDIK');$this-&gt;host=getenv('DATABASE_HOST');$this-&gt;ddbb=getenv('NOMBRE_DB'); } function connect(){ $con = new mysqli($this-&gt;host,$this-&gt;user,$this-&gt;pass,$this-&gt;ddbb); $con-&gt;query("set sql_mode=''"); return $con; } public static function getCon(){ if(self::$con==null &amp;&amp; self::$db==null){ self::$db = new Database(); self::$con = self::$db-&gt;connect(); } return self::$con; } } ?&gt; Ya teniendo todo esto realizado, vamos a crear el fichero Dockerfile para crear la imagen docker. Para ello, debemos crear un fichero llamado Dockerfile en la raíz del proyecto y añadir el siguiente contenido: FROM debian:bullseye MAINTAINER María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com" RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install apache2 libapache2-mod-php php php-mysql mariadb-client -y &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* COPY bookmedik /var/www/html/ ADD script.sh /opt/ RUN chmod +x /opt/script.sh &amp;&amp; rm /var/www/html/index.html ENTRYPOINT ["/opt/script.sh"] Y el fichero script.sh: #! /bin/sh mysql -u $USUARIO_BOOKMEDIK --password=$CONTRA_BOOKMEDIK -h $DATABASE_HOST $NOMBRE_DB &lt; /var/www/html/schema.sql /usr/sbin/apache2ctl -D FOREGROUND El script que hemos creado, tendrá como destino el directorio raíz del repositorio, para añadirlo al contenedor. Y ya podríamos crear la imagen del contenedor con el siguiente comando: docker build -t legnakra/bookmedik:v1 . Si ejecutamos docker images, podremos ver que la imagen se ha creado correctamente: Tarea 2: Despliegue en el entorno de desarrollo En esta tarea, crearemos un scritp con docker-compose que levantará el escenario con los contenedores. Debemos tener en cuenta que para acceder a la aplicación, las credenciales serán: Usuario: admin // contraseña: admin. Por ello, creamos el fichero docker-compose.yaml para levantar ambos contenedores: version: '3.8' services: bookmedik: container_name: bookmedik-app image: legnakra/bookmedik:v1 restart: always environment: USUARIO_BOOKMEDIK: admin CONTRA_BOOKMEDIK: admin DATABASE_HOST: bd_mariadb NOMBRE_DB: bookmedik ports: - 8081:80 depends_on: - db db: container_name: bd_mariadb image: mariadb restart: always environment: MARIADB_ROOT_PASSWORD: root MARIADB_DATABASE: bookmedik MARIADB_USER: admin MARIADB_PASSWORD: admin volumes: - mariadb_data:/var/lib/mysql volumes: mariadb_data: Levantamos el escenario con docker compose up -dy con docker ps podemos ver que los contenedores se han levantado correctamente: Si accedemos a la aplicación, podremos ver que funciona correctamente: Tarea 3: Creación de una imagen docker con una aplicación web desde una imagen PHP Ahora le toca el turno a la imagen de PHP. Para ello, crearemos un fichero llamado Dockerfile en la raíz del proyecto y añadiremos el siguiente contenido: FROM php:7.4-apache-bullseye MAINTAINER María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com" RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; docker-php-ext-install mysqli pdo pdo_mysql &amp;&amp; apt-get install mariadb-client -y &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* ADD bookmedik /var/www/html/ ADD script.sh /opt/ RUN chmod +x /opt/script.sh ENTRYPOINT ["/opt/script.sh"] Y creamos una nueva imagen: docker build -t legnakra/bookmedik:v2 . EL fichero docker-compose.yaml quedaría de la siguiente forma: version: '3.8' services: bookmedik: container_name: bookmedik-app image: legnakra/bookmedik:v2 restart: always environment: USUARIO_BOOKMEDIK: bookmedik CONTRA_BOOKMEDIK: bookmedik DATABASE_HOST: bd_mariadb NOMBRE_DB: bookmedik ports: - 8081:80 depends_on: - db db: container_name: bd_mariadb image: mariadb:latest restart: always environment: MARIADB_ROOT_PASSWORD: root MARIADB_DATABASE: bookmedik MARIADB_USER: bookmedik MARIADB_PASSWORD: bookmedik volumes: - mariadb_data:/var/lib/mysql volumes: mariadb_data: Realizamos el despliegue con docker-compose up -d y como vemos en la imagen anterior, ambos contenedores se están ejecutando y en la siguiente, comprobamos que la imagen se ha creado correctamente: Si accedemos a la aplicación, podremos ver que funciona correctamente: Tarea 4: Ejecución de una aplicación PHP en docker con nginx En esta tarea, vamos a tener que crear dos imágenes: Una que contrendrá la aplicación PHP y será nginx la encargada de servirla. Otra que tendrá los modulos de PHP necesarios para que la aplicación funcione. Creamos el Dockerfile con php-fpm y sus correspondientes modulos: FROM php:7.4-fpm MAINTAINER María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com" RUN docker-php-ext-install mysqli Creamos la imagen: docker build -t legnakra/php-fpm-mysql:v1 . Para crear el dockerfile con la aplicación y nginx como servidor web, añadimos el siguiente contenido: FROM nginx MAINTAINER María Jesús Alloza Rodríguez "mariajesus.allozarodriguez@gmail.com" RUN apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get install mariadb-client -y &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* ADD default.conf /etc/nginx/conf.d/ ADD bookmedik /usr/share/nginx/html ADD script.sh /opt/ RUN chmod +x /opt/script.sh &amp;&amp; rm /usr/share/nginx/html/index.html ENTRYPOINT ["/opt/script.sh"] En el docker file anterior, hemos establecido el fichero default.conf como el fichero de configuración de nginx. Este fichero contendrá la siguiente información: nano default.conf server { listen 80; listen [::]:80; server_name localhost; error_log /var/log/nginx/error.log; access_log /var/log/nginx/access.log; root /usr/share/nginx/html; index index.php index.html; location ~ \.php$ { try_files $uri =404; fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_pass book_php:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; } } Y también deberemos modificar script.sh para adaptarlo a nginx: #! /bin/sh sleep 10 mysql -u $USUARIO_BOOKMEDIK --password=$CONTRA_BOOKMEDIK -h $DATABASE_HOST $NOMBRE_DB &lt; /usr/share/nginx/html/schema.sql nginx -g "daemon off;" Creamos la imagen: docker build -t legnakra/bookmedik:v3 . Antes de modificar el docker-compose.yaml debemos tener en cuenta que: Los contenedores que tienen php-fpm y nginx, deben estar en la misma ruta. Las variables de entorno que se pasan al contenedor de nginx, deben también estar en el contenedor de php-fpm. Por lo que el fichero docker-compose.yaml quedaría de la siguiente forma: version: '3.8' services: bookmedik: container_name: bookmedik-app image: legnakra/bookmedik:v3 restart: always environment: USUARIO_BOOKMEDIK: bookmedik CONTRA_BOOKMEDIK: bookmedik DATABASE_HOST: bd_mariadb NOMBRE_DB: bookmedik ports: - 8082:80 depends_on: - db - php volumes: - phpdocs:/usr/share/nginx/html/ db: container_name: bd_mariadb image: mariadb restart: always environment: MARIADB_ROOT_PASSWORD: root MARIADB_DATABASE: bookmedik MARIADB_USER: bookmedik MARIADB_PASSWORD: bookmedik volumes: - mariadb_data:/var/lib/mysql php: container_name: book_php image: legnakra/php-fpm-mysql:v1 restart: always environment: USUARIO_BOOKMEDIK: bookmedik CONTRA_BOOKMEDIK: bookmedik DATABASE_HOST: bd_mariadb NOMBRE_DB: bookmedik volumes: - phpdocs:/usr/share/nginx/html/ volumes: mariadb_data: phpdocs: Tras todos los pasos anteriores, podemos cerciorarnos en la imagen anterior, que las imágenes que hemos confeccionado se han creado correctamente. Ahora, ejecutamos el docker compose.yaml: docker-compose up -d Y comprobamos que todo funciona como esperábamos: Si accedemos a la aplicación, podremos ver que funciona correctamente: Tarea 5: Puesta en producción de nuestra aplicación Vamos a poner en producción la aplicación a través de nuestro VPS, por lo que lo primero que deberemo de hacer es crear un registro CNAME en nuestro DNS para que apunte a la IP de nuestro VPS. ⬜️ bookmedik.mariatec.es CNAME mariatec.es Y le generamos un certificado de Let's Encrypt: certbot certonly --standalone -d bookmedik.mariatec.es Instalamos docker y docker-compose en nuestro VPS: sudo apt update &amp;&amp; sudo apt upgrade -y &amp;&amp; sudo apt install docker.io docker-compose-plugin -y Al tener las imágenes creadas subidas a Docker Hub, podemos descargarlas en nuestro VPS: docker pull legnakra/bookmedik:v2 En mi caso he elegido la versión 2, ya que es la que tiene el fichero docker-compose.yaml adaptado para el VPS. Creamos el virtualhost en nginx para que actúe de proxy inverso: nano /etc/nginx/sites-available/bookmedik.mariatec.es server { listen 80; listen [::]:80; server_name bookmedik.mariatec.es; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; ssl on; ssl_certificate /etc/letsencrypt/live/bookmedik.mariatec.es/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/bookmedik.mariatec.es/privkey.pem; index index.html index.php index.htm index.nginx-debian.html; server_name bookmedik.mariatec.es; location / { proxy_pass http://localhost:8083; include proxy_params; } } Creamos el enlace simbólico y reiniciamos nginx: ln -s /etc/nginx/sites-available/bookmedik /etc/nginx/sites-enabled/ systemctl restart nginx En mi caso, he subido los ficheros a github, por lo que he clonado el repositorio y el repositorio de Bookmedik en mi VPS, dejando la estructura de carpetas de la siguiente forma: ├── Bookmedik │   ├── docker-compose.yaml │   ├── Dockerfile │   ├── scripts │   ├── bookmedik │   │   ├── PhpWord │   │   ├── core │   │   ├── assets │   │   ├── report │   │   ├── index.php │   │   ├── instalation.txt │   │   ├── schema.sql │   │   ├── logout.php │   │   ├── README.md Realizamos la ejecución del comando docker-compose up -d y comprobamos que todo funciona correctamente: Y como podemos comprobar en la siguiente imagen, la aplicación funciona correctamente. NOTA: A la hora de hacer el despliegue, debemos cerciorarnos de cambiar el puerto de escucha, dado que puede caber la posibilidad (o que sea muy probable) de que el puerto 8080 esté ocupado. En mi caso, he puesto el puerto de escucha en el 8083 debido a que ya tengo aplicaciones desplegadas en mi VPS. Tarea 6: Modificación de la aplicación Vamos a modificar la aplicación para que nos muestre nuestro nombre en la línea &lt;h4 class="title"&gt;Acceder a BookMedik&lt;/h4&gt;. Para ello, vamos a utilizar la imagen de legnakra/bookmedik:v1 que ya tiene el fichero docker-compose.yaml para generar la nueva imagen. nano `core/app/view/login-view.php` --- &lt;h4 class="title"&gt;María Jesús Alloza Rodríguez&lt;/h4&gt; Creamos la nueva imagen docker build -t legnakra/bookmedik:v1_2 . La resubimos a DockerHub: docker push legnakra/bookmedik:v1_2 Eliminamos los contenedores que están en ejecución, modificamos el fichero docker-compose.yaml para que descargue la nueva imagen y ejecutamos el docker-compose.yaml: docker compose down nano docker-compose.yaml version: '3.8' services: bookmedik: container_name: bookmedik-app image: legnakra/bookmedik:v1_2 restart: always environment: USUARIO_BOOKMEDIK: admin CONTRA_BOOKMEDIK: admin DATABASE_HOST: bd_mariadb NOMBRE_DB: bookmedik ports: - 8081:80 depends_on: - db db: container_name: bd_mariadb image: mariadb restart: always environment: MARIADB_ROOT_PASSWORD: root MARIADB_DATABASE: bookmedik MARIADB_USER: admin MARIADB_PASSWORD: admin volumes: - mariadb_data:/var/lib/mysql volumes: mariadb_data: Y con esto daríamos terminado como desplegar una aplicación PHP en un VPS con contenedores Docker. Conclusiones Docker es una herramienta muy útil para el despliegue de aplicaciones, ya que nos permite crear contenedores que contienen todo lo necesario para que la aplicación funcione correctamente. Además, nos permite crear imágenes que podemos subir a Docker Hub para que otras personas puedan descargarlas y utilizarlas. Bibliografía https://www.docker.com/ https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04-es]]></summary></entry><entry><title type="html">Escenario - Configuración de LDAP en Alfa</title><link href="/aso/2023/02/07/ldap2.html" rel="alternate" type="text/html" title="Escenario - Configuración de LDAP en Alfa" /><published>2023-02-07T16:45:16+01:00</published><updated>2023-02-07T16:45:16+01:00</updated><id>/aso/2023/02/07/ldap2</id><content type="html" xml:base="/aso/2023/02/07/ldap2.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>En nuestro <a href="https://sysmaria.netlify.app/hlc+sri/2022/12/05/escenario.html">escenario</a> vamos a realizar la instalación y configuración de OpenLDAP en la máquina <code class="language-plaintext highlighter-rouge">Alfa</code>. Lo haremos utilizando como base el nombre DNS asignado a la máquina, <code class="language-plaintext highlighter-rouge">alfa.mariajesus.gonzalonazareno.org</code>.</p>

<p>En esta ocasión, vamos a crear entre todos los alumnos de la clase, los que vayamos a hacer dicha práctica, un fichero CSV que incluya la siguiente información:</p>

<ul>
  <li>Nombre del alumno</li>
  <li>Apellidos del alumno</li>
  <li>Dirección de correo electrónico</li>
  <li>Nombre del equipo</li>
  <li>Dirección IP del equipo</li>
  <li>Clave pública SSH del equipo</li>
</ul>

<p>El mío quedaría así:</p>

<pre><code class="language-csv">Ivan,Pina Castillo,ivanpicas88@gmail.com,ivan,ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCfYm123AV12rRYM+tPkrd0Hrzc9Py32Ov8JVZCnH5zVBj3I/IxE08LUhccSSx9aD0DrW+RdfpmLCSBTgGnbdM9eYlq3jxoBqqye4DQeXLSPyXcp/qRPGPsNO+eGypVhRB+Oq9B+ktrHgzAXQSP1yjmjN57H7GVBnMEJhpCEVXk5vWgMhVNxsDSF6lHrbiaYLtunTtt+fNgrprzXuUqhUwEDRt6/ktwad420J7kmqkB4dQuex3hV+16l1GyNH8AJzNzoinTiLr/jW8Ja0udgIknsxFvZ5Df+ACCrXfIFwvdPTm6Nya0jCm9vFx5yc5O1E07qlbAAn3FiIfS5Udjs6rNZjfFH5GmlpodhcGy4nkCYZvylnEayIa/ak4wA7oDft60hlHBMCHMoyY3ZcIkWGmVkwnTB3xfxfykPeD14zQAlIuMol9RNmPUbDYtbfY64npLPmagUIHSpwwbs1byEBbzzqzG8qcCAPUk3mK6oB5+OKUNJDv+4MM+suj+Y/PnWM8= debian@delta
Juan Jesus,Alejo Sillero,juanjesusalejosillero@gmail.com,juanje,ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDzLgcT2qKvflOcKWjUGX0ecoVWN+phHx7dEws3b/rY/xAichGJ6oP8ucD4lVJ8XVrEOaUgqQ1laPK33+u9MmzARx4g17/jKcwepUWdkKVA2++RWG3bsNgxCCkR1Gi7XMAAjwq8/17OjCj+4bvfTPlW5FSjDqaLhfqqeDtKpFJ3wjGG5sjNPC0GU4cRKzggZaR40ld7siaOiMteQ8X6bIggeXw+ULGiUhB4/uoLu0z69AzGgDfoPJuJEx4pPlcnOip/TAuL/pUjTjdUUDTsrZSJegWoLmRwylKvwtX8WojqI2TnTOyLT0IG1oStq4gC4AKOiCqfiBOm25bFfX0lW0uUaR1RjEuGz3jV0vkH3pCiuarNk5KnEQQqUO0x6ZvdCvOlsWYoiDQ6MclGKfUkUzC1uST5khs4xB1zQAZ5795on4SV8STASTwjpxuTuk7v4lTxrm8bTAF4bWiezgOQ0aFr7P0APygX0rbCR1aXoGfSyrrvqOUtkUzpiWwZwOpj0K0= juanjesus@delta.juanjesus.gonzalonazareno.org
Angel,Suarez Perez,angelsuarezperez@gmail.com,angel,ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDFEJGJIWb1KviE3kwQRoUV2C4E0d9L0mq9XjSt1kmznXSXMODJBdHwa7GOb9iwmW3OKkTa6RGokB2nKvs+2IBm9HcPYM0WM78wxEazuUvwpHR4mV58gzif/ETM48/ceQcf1fqADW1456Mfk7zFHwgf8vjyNfFCtR6NGve7wb7ojm79a9CJpqZEJ9X+EVxjbKysdvhS3BsNo5L3aJwPsAHE29+lFhDmOOzuEXWTjvFRkC1aFN1iVyxdolNJuh3onWXZDzPI55Q/DHtkpjKZ4cYqBsmwZFjWlum5aWRltgYMZtvoGOBglIxBQWjY4sl7WCiW89b+6zIcG4vWq48qhoO76ROYEPJL4pdkxxUZbjk4xApHLoO56+fXCtoo+fO/zQiHyTElzXBg/v2MmqxUrFQmQCzhbAuKK88rycZVFdIknuc+Raoi3faiX2x5N9AL4PMpEVJaTi7b/n7NMZVTkuVT9U/X9pwABSi1yngxlr2BpTg2FJD5iId15v51nx1ynXE= angelsuarez@charlie
Maria Jesus,Alloza Rodriguez, mariajesus.allozarodriguez@gmail.com, ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDd4xzwnydw85ipOR35RhK/S4750Z+PDsr8JILUh3abXczA25pR/CoXmMdSqTOTG8QqA2eKyJtATbz7W7nbaniIO8vWlyYYBYiiq3gXIW8u5hZl791Odgl5V1INEuQFgdwyABk60m2kPzc8pzvBJc65TGq3C8YrpOY/k3DoXd0dBEmZe5bCUqCcSF9j1J+4FQj0NxF1sXrnP0ZNL0y70CPROzwZw0ECz1eB/WhfH4niQhF3jHSw9WEYy548JIy4xAbeexnenwVua5W0Wyu7Rfk2NIGuMnq0Ese06wSu1x7sX8rBOljs+E3+eAsPmBDGXzNlpi8x8k9ZAdSjLCY5mpPeXauOR7LKfVpqjXNDzBBoodQrDQOA8QbbUxOtYz2srno3KF0RmAzhk/puEn19rkhWulOBMr322Kom+br7Rzc/WiML7YHEYhAY1GE8eyCSzH3Mkv7dqLAfP3WZ6pgbVXe/OdHkpuXBw+RS/GqvlVTbl//gHsMbEMav3CZBZttiIpU= maria@delta.mariajesus.gonzalonazareno.org
</code></pre>

<h3 id="esquema-openssh-lpk">Esquema openssh-lpk</h3>

<p>Tras haber creado los ficheros, vamos a añadir el esquema openssh-lpk al servidor LDAP. Para ello, vamos a crear un fichero llamado openssh-lpk.ldif:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /etc/ldap/schema/openssh-lpk.ldif
</code></pre></div></div>

<p>Y añadimos el siguiente contenido:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dn: <span class="nv">cn</span><span class="o">=</span>openssh-lpk,cn<span class="o">=</span>schema,cn<span class="o">=</span>config
objectClass: olcSchemaConfig
cn: openssh-lpk
olcAttributeTypes: <span class="o">(</span> 1.3.6.1.4.1.24552.500.1.1.1.13 NAME <span class="s1">'sshPublicKey'</span>
  DESC <span class="s1">'MANDATORY: OpenSSH Public key'</span>
  EQUALITY octetStringMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 <span class="o">)</span>
olcObjectClasses: <span class="o">(</span> 1.3.6.1.4.1.24552.500.1.1.2.0 NAME <span class="s1">'ldapPublicKey'</span> SUP top AUXILIARY
  DESC <span class="s1">'MANDATORY: OpenSSH LPK objectclass'</span>
  MAY <span class="o">(</span> sshPublicKey <span class="nv">$ </span>uid <span class="o">)</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>Lo siguiente será añadir el esquema al directorio que utilizamos para el servidor LDAP ejecutando el siguiente comando en nuestra terminal en la máquina <code class="language-plaintext highlighter-rouge">alfa</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapadd <span class="nt">-Y</span> EXTERNAL <span class="nt">-H</span> ldapi:/// <span class="nt">-f</span> /etc/ldap/schema/openssh-lpk.ldif
</code></pre></div></div>

<h3 id="script-en-python-">Script en Python 🐍</h3>

<h2 id="referencias">Referencias</h2>

<p>[1] <a href="https://www.openldap.org/">https://www.openldap.org/</a></p>

<p>[2] <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-openldap-and-phpldapadmin-on-ubuntu-18-04-es">https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-openldap-and-phpldapadmin-on-ubuntu-18-04-es</a></p>

<ul>
  <li>
    <p>Disk Image or VM file: Esto incluye el archivo de imagen que puede ser una copia exacta de un disco duro, una tarjeta multimedia o    incluso una máquina virtual.</p>
  </li>
  <li>
    <p>Local Disk: Esta opción incluye dispositivos como discos duros, pen drives, tarjetas de memoria, etc.</p>
  </li>
  <li>
    <p>Logical Files: Incluye la imagen de cualquier carpeta o archivo local.</p>
  </li>
  <li>
    <p>Unallocated Space Image File: Incluyen archivos que no contienen ningún sistema de archivos y se ejecutan con la ayuda del módulo      Ingest.</p>
  </li>
  <li>
    <p>Autopsy Logical Imager Results: Incluyen la fuente de datos de la ejecución del generador de imágenes lógicas.</p>
  </li>
  <li>
    <p>XRY Text Export: Incluyen la fuente de datos de la exportación de archivos de texto desde XRY.</p>
  </li>
</ul>]]></content><author><name></name></author><category term="ASO" /><summary type="html"><![CDATA[Introducción En nuestro escenario vamos a realizar la instalación y configuración de OpenLDAP en la máquina Alfa. Lo haremos utilizando como base el nombre DNS asignado a la máquina, alfa.mariajesus.gonzalonazareno.org. En esta ocasión, vamos a crear entre todos los alumnos de la clase, los que vayamos a hacer dicha práctica, un fichero CSV que incluya la siguiente información: Nombre del alumno Apellidos del alumno Dirección de correo electrónico Nombre del equipo Dirección IP del equipo Clave pública SSH del equipo El mío quedaría así: Ivan,Pina Castillo,ivanpicas88@gmail.com,ivan,ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCfYm123AV12rRYM+tPkrd0Hrzc9Py32Ov8JVZCnH5zVBj3I/IxE08LUhccSSx9aD0DrW+RdfpmLCSBTgGnbdM9eYlq3jxoBqqye4DQeXLSPyXcp/qRPGPsNO+eGypVhRB+Oq9B+ktrHgzAXQSP1yjmjN57H7GVBnMEJhpCEVXk5vWgMhVNxsDSF6lHrbiaYLtunTtt+fNgrprzXuUqhUwEDRt6/ktwad420J7kmqkB4dQuex3hV+16l1GyNH8AJzNzoinTiLr/jW8Ja0udgIknsxFvZ5Df+ACCrXfIFwvdPTm6Nya0jCm9vFx5yc5O1E07qlbAAn3FiIfS5Udjs6rNZjfFH5GmlpodhcGy4nkCYZvylnEayIa/ak4wA7oDft60hlHBMCHMoyY3ZcIkWGmVkwnTB3xfxfykPeD14zQAlIuMol9RNmPUbDYtbfY64npLPmagUIHSpwwbs1byEBbzzqzG8qcCAPUk3mK6oB5+OKUNJDv+4MM+suj+Y/PnWM8= debian@delta Juan Jesus,Alejo Sillero,juanjesusalejosillero@gmail.com,juanje,ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDzLgcT2qKvflOcKWjUGX0ecoVWN+phHx7dEws3b/rY/xAichGJ6oP8ucD4lVJ8XVrEOaUgqQ1laPK33+u9MmzARx4g17/jKcwepUWdkKVA2++RWG3bsNgxCCkR1Gi7XMAAjwq8/17OjCj+4bvfTPlW5FSjDqaLhfqqeDtKpFJ3wjGG5sjNPC0GU4cRKzggZaR40ld7siaOiMteQ8X6bIggeXw+ULGiUhB4/uoLu0z69AzGgDfoPJuJEx4pPlcnOip/TAuL/pUjTjdUUDTsrZSJegWoLmRwylKvwtX8WojqI2TnTOyLT0IG1oStq4gC4AKOiCqfiBOm25bFfX0lW0uUaR1RjEuGz3jV0vkH3pCiuarNk5KnEQQqUO0x6ZvdCvOlsWYoiDQ6MclGKfUkUzC1uST5khs4xB1zQAZ5795on4SV8STASTwjpxuTuk7v4lTxrm8bTAF4bWiezgOQ0aFr7P0APygX0rbCR1aXoGfSyrrvqOUtkUzpiWwZwOpj0K0= juanjesus@delta.juanjesus.gonzalonazareno.org Angel,Suarez Perez,angelsuarezperez@gmail.com,angel,ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDFEJGJIWb1KviE3kwQRoUV2C4E0d9L0mq9XjSt1kmznXSXMODJBdHwa7GOb9iwmW3OKkTa6RGokB2nKvs+2IBm9HcPYM0WM78wxEazuUvwpHR4mV58gzif/ETM48/ceQcf1fqADW1456Mfk7zFHwgf8vjyNfFCtR6NGve7wb7ojm79a9CJpqZEJ9X+EVxjbKysdvhS3BsNo5L3aJwPsAHE29+lFhDmOOzuEXWTjvFRkC1aFN1iVyxdolNJuh3onWXZDzPI55Q/DHtkpjKZ4cYqBsmwZFjWlum5aWRltgYMZtvoGOBglIxBQWjY4sl7WCiW89b+6zIcG4vWq48qhoO76ROYEPJL4pdkxxUZbjk4xApHLoO56+fXCtoo+fO/zQiHyTElzXBg/v2MmqxUrFQmQCzhbAuKK88rycZVFdIknuc+Raoi3faiX2x5N9AL4PMpEVJaTi7b/n7NMZVTkuVT9U/X9pwABSi1yngxlr2BpTg2FJD5iId15v51nx1ynXE= angelsuarez@charlie Maria Jesus,Alloza Rodriguez, mariajesus.allozarodriguez@gmail.com, ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDd4xzwnydw85ipOR35RhK/S4750Z+PDsr8JILUh3abXczA25pR/CoXmMdSqTOTG8QqA2eKyJtATbz7W7nbaniIO8vWlyYYBYiiq3gXIW8u5hZl791Odgl5V1INEuQFgdwyABk60m2kPzc8pzvBJc65TGq3C8YrpOY/k3DoXd0dBEmZe5bCUqCcSF9j1J+4FQj0NxF1sXrnP0ZNL0y70CPROzwZw0ECz1eB/WhfH4niQhF3jHSw9WEYy548JIy4xAbeexnenwVua5W0Wyu7Rfk2NIGuMnq0Ese06wSu1x7sX8rBOljs+E3+eAsPmBDGXzNlpi8x8k9ZAdSjLCY5mpPeXauOR7LKfVpqjXNDzBBoodQrDQOA8QbbUxOtYz2srno3KF0RmAzhk/puEn19rkhWulOBMr322Kom+br7Rzc/WiML7YHEYhAY1GE8eyCSzH3Mkv7dqLAfP3WZ6pgbVXe/OdHkpuXBw+RS/GqvlVTbl//gHsMbEMav3CZBZttiIpU= maria@delta.mariajesus.gonzalonazareno.org Esquema openssh-lpk Tras haber creado los ficheros, vamos a añadir el esquema openssh-lpk al servidor LDAP. Para ello, vamos a crear un fichero llamado openssh-lpk.ldif: vi /etc/ldap/schema/openssh-lpk.ldif Y añadimos el siguiente contenido: dn: cn=openssh-lpk,cn=schema,cn=config objectClass: olcSchemaConfig cn: openssh-lpk olcAttributeTypes: ( 1.3.6.1.4.1.24552.500.1.1.1.13 NAME 'sshPublicKey' DESC 'MANDATORY: OpenSSH Public key' EQUALITY octetStringMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 ) olcObjectClasses: ( 1.3.6.1.4.1.24552.500.1.1.2.0 NAME 'ldapPublicKey' SUP top AUXILIARY DESC 'MANDATORY: OpenSSH LPK objectclass' MAY ( sshPublicKey $ uid ) ) Lo siguiente será añadir el esquema al directorio que utilizamos para el servidor LDAP ejecutando el siguiente comando en nuestra terminal en la máquina alfa: ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/ldap/schema/openssh-lpk.ldif Script en Python 🐍 Referencias [1] https://www.openldap.org/ [2] https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-openldap-and-phpldapadmin-on-ubuntu-18-04-es Disk Image or VM file: Esto incluye el archivo de imagen que puede ser una copia exacta de un disco duro, una tarjeta multimedia o incluso una máquina virtual. Local Disk: Esta opción incluye dispositivos como discos duros, pen drives, tarjetas de memoria, etc. Logical Files: Incluye la imagen de cualquier carpeta o archivo local. Unallocated Space Image File: Incluyen archivos que no contienen ningún sistema de archivos y se ejecutan con la ayuda del módulo Ingest. Autopsy Logical Imager Results: Incluyen la fuente de datos de la ejecución del generador de imágenes lógicas. XRY Text Export: Incluyen la fuente de datos de la exportación de archivos de texto desde XRY.]]></summary></entry><entry><title type="html">Kubernetes: Trabajando con Services</title><link href="/hlc+sri/2023/02/05/kubernetes-ingress.html" rel="alternate" type="text/html" title="Kubernetes: Trabajando con Services" /><published>2023-02-05T16:45:16+01:00</published><updated>2023-02-05T16:45:16+01:00</updated><id>/hlc+sri/2023/02/05/kubernetes-ingress</id><content type="html" xml:base="/hlc+sri/2023/02/05/kubernetes-ingress.html"><![CDATA[<h2 id="ejercicio-1-despliegue-y-acceso-de-la-aplicación-guestbook">Ejercicio 1: Despliegue y acceso de la aplicación GuestBook</h2>

<p>Una vez que tenemos creado el despliegue de la aplicación GuestBook, que realizamos en el anterior taller, vamos a crear los Services correspondientes para acceder a ella:</p>

<h3 id="service-para-acceder-a-la-aplicación">Service para acceder a la aplicación:</h3>

<p>Vamos a crear un Service que nos va a permitir acceder a la aplicación GuestBook desde el exterior, para ello crea un fichero yaml con la definición del Service a partir de la siguiente plantilla:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">guestbook</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">guestbook</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
<span class="na">spec</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span>
      <span class="na">targetPort</span><span class="pi">:</span>
    <span class="na">selector</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">guestbook</span>
        <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
</code></pre></div></div>

<ul>
  <li>Lanzamos el servicio con el comando <code class="language-plaintext highlighter-rouge">kubectl create -f guestbook-service.yaml</code> y comprobamos que se ha creado correctamente con el comando <code class="language-plaintext highlighter-rouge">kubectl get all</code>.</li>
</ul>

<p><img src="/assets/images/kubernetes/t4/1.png" alt="1" /></p>

<ul>
  <li>Accedemos a la ip del nodo master y al puerto asignado desde un navegador web para ver la aplicación.</li>
</ul>

<p><img src="/assets/images/kubernetes/t4/2.png" alt="2" /></p>

<p>Pero claro, no funciona, ¿por qué? Porque la aplicación guestbook necesita conectarse a la base de datos redis, y no la encuentra. Para ello vamos a crear el Service para acceder a la base de datos. De esta forma, conectaremos el frontend con el backend, donde este último será de tipo ClusterIP.</p>

<h3 id="service-para-acceder-a-la-base-de-datos">Service para acceder a la base de datos:</h3>

<p>A continuación vamos a crear el Service para acceder a la base de datos. Vamos a crear el fichero yaml. Tenemos que poner el tipo del Service, el puerto del servicio será el 6379 y el nombre del puerto de la base de datos que hemos asignado en el Deployment es redis-server. Nota: No cambies el nombre del Service, ya que la aplicación guestbook va a acceder por defecto a la base de datos usando el nombre redis.</p>

<p>Para ello, realizaremos lo siguientes pasos:</p>

<ol>
  <li>
    <p>Elaboramos el fichero yaml con la definición del Service, y lo creamos.</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">redis</span>
   <span class="na">labels</span><span class="pi">:</span>
     <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
     <span class="na">tier</span><span class="pi">:</span> <span class="s">backend</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">ClusterIP</span>
   <span class="na">ports</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">6379</span>
     <span class="na">targetPort</span><span class="pi">:</span> <span class="s">redis-server</span>
   <span class="na">selector</span><span class="pi">:</span>
     <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
     <span class="na">tier</span><span class="pi">:</span> <span class="s">backend</span>
</code></pre></div>    </div>

    <p>Y lo creamos.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl create <span class="nt">-f</span> redis-service.yaml
</code></pre></div>    </div>
  </li>
  <li>
    <p>Listamos los servicios para comprobar que se ha creado correctamente.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t4/3.png" alt="3" /></p>
  </li>
  <li>
    <p>Accederemos a la ip del nodo master y al puerto asignado desde un navegador web para ver la aplicación.</p>

    <p><img src="/assets/images/kubernetes/t4/4.png" alt="4" /></p>
  </li>
</ol>

<p>¡EY! ¡Ya funciona! Pero claro, no es muy cómodo acceder a la aplicación usando la ip del nodo master y el puerto asignado. Para ello vamos a crear un Ingress que nos permita acceder a la aplicación usando un nombre del tipo www.mariajesus.org.</p>

<h3 id="acceso-a-la-aplicación-usando-ingress">Acceso a la aplicación usando Ingress</h3>

<p>Vamos a crear el fichero yaml de definición del recurso Ingress para acceder a la aplicación. Indicaremos un host del tipo www.mariajesus.org, también el nombre del Service que creamos para acceder a la aplicación guestbook y tendremos que tener en cuenta que el puerto de dicho servicio era el 80. Para ello realizaremos los siguientes pasos:</p>

<ol>
  <li>
    <p>Activamos el addon ingress en minikube para instalar el Ingress Controller y creamos el recurso Ingress.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> minikube addons <span class="nb">enable </span>ingress
</code></pre></div>    </div>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">guestbook</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">rules</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">www.mariajesus.org</span>
     <span class="na">http</span><span class="pi">:</span>
       <span class="na">paths</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
         <span class="na">pathType</span><span class="pi">:</span> <span class="s">Prefix</span>
         <span class="na">backend</span><span class="pi">:</span>
           <span class="na">service</span><span class="pi">:</span>
             <span class="na">name</span><span class="pi">:</span> <span class="s">guestbook</span>
             <span class="na">port</span><span class="pi">:</span>
               <span class="na">number</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Creamos la definición del recurso Ingress con los datos sugeridos, y creamos el recurso Ingress.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl create <span class="nt">-f</span> guestbook-ingress.yaml
</code></pre></div>    </div>

    <p>Y comprobamos que se ha creado correctamente.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t4/5.png" alt="5" /></p>
  </li>
  <li>
    <p>Modificaremos el fichero /etc/hosts de nuestro ordenador para configurar la resolución estática.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nano /etc/hosts
</code></pre></div>    </div>

    <p>Añadimos la siguiente línea al fichero:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 192.168.15.42 www.mariajesus.org
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t4/6.png" alt="6" /></p>
  </li>
  <li>
    <p>Accederemos a la aplicación usando el nombre que has asignado.</p>

    <p><img src="/assets/images/kubernetes/t4/7.png" alt="7" /></p>
  </li>
</ol>

<p>Para eliminarlo todo, ejecutamos el siguiente comando:</p>

<h2 id="ejercicio-2-despliegue-y-acceso-de-la-aplicación-lets-chat">Ejercicio 2: Despliegue y acceso de la Aplicación Lets-Chat</h2>

<p>¿Qué es Lets-Chat?</p>

<p>Lets-Chat es una aplicación de mensajería instantánea basada en Node.js y MongoDB. Es una aplicación de código abierto que se puede desplegar en cualquier entorno de forma sencilla. En este ejercicio vamos a desplegar Lets-Chat en Kubernetes.</p>

<p>Para realizar el despliegue y el acceso de la aplicación, deberemos tener en cuenta los siguientes aspectos:</p>

<ul>
  <li>
    <p>La imagen docker que vamos a usar para el despliegue de Let’s Chat es sdelements/lets-chat y para desplegar mongoDB utilizaremos la imagen mongo. Nota: utiliza imagen mongo:4, Let’s Chat es una aplicación antigua y no funciona con las últimas versiones de mongo.</p>
  </li>
  <li>
    <p>Al crear el despliegue de Let’s Chat podemos poner varias replicas, pero el despliegue de la base de datos, sólo creará una replica.</p>
  </li>
  <li>
    <p>El puerto en el que responde la aplicación es el 8080. La base de datos utiliza el puerto 27017.</p>
  </li>
  <li>
    <p>Vamos acceder desde el exterior a la aplicación. Sin embargo, no es necesario acceder desde el exterior a la base de datos.</p>
  </li>
  <li>
    <p>El nombre del Service para acceder a la base de datos debe ser mongo ya que por defecto la aplicación va a conectar a la base de datos usando ese nombre.</p>
  </li>
  <li>
    <p>Queremos acceder a la aplicación usando un nombre del tipo www.chat-mariajesus.org.</p>
  </li>
</ul>

<p>Tras tener todo esto en cuenta, vamos a utilizar como modelos los ficheros yaml de la actividad anterior, crea los ficheros necesarios para crear los recursos en tu cluster de Kubernetes para desplegar esta aplicación.</p>

<ol>
  <li>
    <p>Creamos los ficheros encargados del despliegue de la aplicación Lets-Chat y de la base de datos.</p>

    <ul>
      <li>Fichero del despliegue de la aplicación Lets-Chat.</li>
    </ul>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
   <span class="na">labels</span><span class="pi">:</span>
     <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
   <span class="na">selector</span><span class="pi">:</span>
     <span class="na">matchLabels</span><span class="pi">:</span>
       <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
   <span class="na">template</span><span class="pi">:</span>
     <span class="na">metadata</span><span class="pi">:</span>
       <span class="na">labels</span><span class="pi">:</span>
         <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
     <span class="na">spec</span><span class="pi">:</span>
       <span class="na">containers</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
         <span class="na">image</span><span class="pi">:</span> <span class="s">sdelements/lets-chat</span>
         <span class="na">ports</span><span class="pi">:</span>
           <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http-server</span>
             <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div>    </div>

    <ul>
      <li>Fichero del despliegue de la base de datos.</li>
    </ul>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
   <span class="na">labels</span><span class="pi">:</span>
     <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
   <span class="na">selector</span><span class="pi">:</span>
     <span class="na">matchLabels</span><span class="pi">:</span>
       <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
   <span class="na">template</span><span class="pi">:</span>
     <span class="na">metadata</span><span class="pi">:</span>
       <span class="na">labels</span><span class="pi">:</span>
         <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
     <span class="na">spec</span><span class="pi">:</span>
       <span class="na">containers</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
         <span class="na">image</span><span class="pi">:</span> <span class="s">sdelements/lets-chat</span>
         <span class="na">ports</span><span class="pi">:</span>
           <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http-server</span>
             <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div>    </div>

    <ul>
      <li>Levantamos los despliegues.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl create <span class="nt">-f</span> letschat-deployment.yaml
 kubectl create <span class="nt">-f</span> mongo-deployment.yaml
</code></pre></div>    </div>

    <ul>
      <li>Comprobamos que se han creado correctamente.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t4/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Creamos los ficheros de servicios de Let’s Chat y de la base de datos.</p>

    <ul>
      <li>Fichero del servicio de la base de datos.</li>
    </ul>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
 <span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">mongo</span>
 <span class="na">spec</span><span class="pi">:</span>
 <span class="na">ports</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mongo</span>
     <span class="s">port</span><span class="err">:</span> <span class="m">27017</span>
     <span class="na">targetPort</span><span class="pi">:</span> <span class="s">mongo</span>
 <span class="na">selector</span><span class="pi">:</span>
     <span class="na">name</span><span class="pi">:</span> <span class="s">mongo</span>
</code></pre></div>    </div>

    <ul>
      <li>Fichero del servicio de LetsChat.</li>
    </ul>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
 <span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
 <span class="na">spec</span><span class="pi">:</span>
 <span class="na">type</span><span class="pi">:</span> <span class="s">NodePort</span>
 <span class="na">ports</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
     <span class="s">port</span><span class="err">:</span> <span class="m">8080</span>
     <span class="na">targetPort</span><span class="pi">:</span> <span class="s">http-server</span>
 <span class="na">selector</span><span class="pi">:</span>
     <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
</code></pre></div>    </div>

    <ul>
      <li>Levantamos los servicios.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl create <span class="nt">-f</span> mongo-service.yaml
 kubectl create <span class="nt">-f</span> letschat-service.yaml
</code></pre></div>    </div>

    <ul>
      <li>Comprobamos que se han creado correctamente.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t4/9.png" alt="9" /></p>

    <p>Nuestra aplicación LetsChat está desplegada en el cluster de Kubernetes, pero no podemos acceder a ella desde el exterior.</p>

    <p><img src="/assets/images/kubernetes/t4/10.png" alt="10" /></p>

    <p>Para poder acceder a ella desde el exterior, vamos a crear un Ingress.</p>
  </li>
  <li>
    <p>Creamos el fichero de Ingress para LetsChat.</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
 <span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">ingress-letschat</span>
 <span class="na">spec</span><span class="pi">:</span>
 <span class="na">rules</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">www.chat-mariajesus.org</span>
     <span class="s">http</span><span class="err">:</span>
     <span class="na">paths</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
         <span class="s">pathType</span><span class="err">:</span> <span class="s">Prefix</span>
         <span class="s">backend</span><span class="err">:</span>
         <span class="na">service</span><span class="pi">:</span>
             <span class="na">name</span><span class="pi">:</span> <span class="s">letschat</span>
             <span class="na">port</span><span class="pi">:</span>
             <span class="na">number</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div>    </div>

    <ul>
      <li>Levantamos el Ingress.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl create <span class="nt">-f</span> letschat-ingress.yaml
</code></pre></div>    </div>

    <ul>
      <li>Comprobamos que se ha creado correctamente.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get all
</code></pre></div>    </div>

    <ul>
      <li>Agregamos la siguiente línea al fichero /etc/hosts.</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 192.168.100.185 www.chat-mariajesus.org
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t4/11.png" alt="11" /></p>

    <ul>
      <li>Comprobamos que podemos acceder a la aplicación LetsChat desde el exterior.</li>
    </ul>

    <p><img src="/assets/images/kubernetes/t4/12.png" alt="12" /></p>
  </li>
</ol>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Ejercicio 1: Despliegue y acceso de la aplicación GuestBook]]></summary></entry><entry><title type="html">Taller Kubernetes: Trabajando con Deployments</title><link href="/hlc+sri/2023/02/04/kubernetes-deploy.html" rel="alternate" type="text/html" title="Taller Kubernetes: Trabajando con Deployments" /><published>2023-02-04T16:45:16+01:00</published><updated>2023-02-04T16:45:16+01:00</updated><id>/hlc+sri/2023/02/04/kubernetes-deploy</id><content type="html" xml:base="/hlc+sri/2023/02/04/kubernetes-deploy.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>En este taller vamos a trabajar con Deployments, que es un objeto de Kubernetes que nos permite crear un conjunto de Pods idénticos. En este caso, vamos a crear un Deployment que va a controlar un conjunto de Pods.</p>

<h3 id="ejercicio-1-trabajando-con-deployments">Ejercicio 1: Trabajando con Deployments</h3>

<ol>
  <li>
    <p>Crearemos un fichero yaml con la descripción del recurso Deployment, teniendo en cuenta los siguientes aspectos:</p>

    <ul>
      <li>Indicaremos nombres distintos para el Deployment y para el contenedor de los Pods que va a controlar.</li>
      <li>El Deployment va a crear 2 réplicas.</li>
      <li>La imagen que debemos desplegar es iesgn/test_web:latest.</li>
      <li>Indicaremos de manera adecuada una etiqueta en la especificación del Pod que vas a definir que coincida con el selector del Deployment.</li>
    </ul>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">test-web-deployment</span>
   <span class="na">labels</span><span class="pi">:</span>
     <span class="na">app</span><span class="pi">:</span> <span class="s">web</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">revisionHistoryLimit</span><span class="pi">:</span> <span class="m">5</span>
   <span class="na">strategy</span><span class="pi">:</span>
     <span class="na">type</span><span class="pi">:</span> <span class="s">RollingUpdate</span>
   <span class="na">replicas</span><span class="pi">:</span> <span class="m">2</span>
   <span class="na">selector</span><span class="pi">:</span>
     <span class="na">matchLabels</span><span class="pi">:</span>
       <span class="na">app</span><span class="pi">:</span> <span class="s">web</span>
   <span class="na">template</span><span class="pi">:</span>
     <span class="na">metadata</span><span class="pi">:</span>
       <span class="na">labels</span><span class="pi">:</span>
         <span class="na">app</span><span class="pi">:</span> <span class="s">web</span>
     <span class="na">spec</span><span class="pi">:</span>
       <span class="na">containers</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/test_web:latest</span>
         <span class="na">name</span><span class="pi">:</span> <span class="s">container-testweb</span>
         <span class="na">ports</span><span class="pi">:</span>
         <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
           <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/0.png" alt="0" /></p>
  </li>
  <li>
    <p>Creamos el deployment:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl apply <span class="nt">-f</span> test-web-deployment.yaml
</code></pre></div>    </div>
  </li>
  <li>
    <p>Comprobamos los recursos que se han creado, en nuestro caso, Deployment, ReplicaSet y Pods.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/1.png" alt="1" /></p>
  </li>
  <li>
    <p>Obtenemos la información detallada del Deployment:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl describe deployments.apps/test-web-deployment
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/2.png" alt="2" /></p>
  </li>
  <li>
    <p>Crearemos un una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accede a la aplicación con un navegador web.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl port-forward deployments.apps/test-web-deployment 8080:80
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/3.png" alt="3" /></p>

    <p><img src="/assets/images/kubernetes/t3/4.png" alt="4" /></p>
  </li>
  <li>
    <p>Accederemos a los logs del despliegue para comprobar el acceso que has hecho en el punto anterior.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl logs deployments.apps/test-web-deployment
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/5.png" alt="5" /></p>
  </li>
  <li>
    <p>Elimina el Deployment y comprueba que se han borrado todos los recursos creados.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl delete deployments.apps/test-web-deployment
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/6.png" alt="6" /></p>
  </li>
</ol>

<h3 id="ejercicio-2-actualización-y-desactualización-de-nuestra-aplicación">Ejercicio 2: Actualización y desactualización de nuestra aplicación.</h3>

<h4 id="primera-verisón">Primera verisón</h4>
<p>El equipo de desarrollo ha creado una primera versión preliminar de una aplicación web y ha creado una imagen de contenedor con el siguiente nombre: iesgn/test_web:version1.</p>

<p>Vamos a desplegar esta primera versión de la aplicación. Recuerda que primero debemos descargarnos la imagen del contenedor con un <code class="language-plaintext highlighter-rouge">docker pull iesgn/test_web:version1</code>.</p>

<ol>
  <li>
    <p>Creamos un fichero yaml para desplegar la imagen: iesgn/test_web:version1.</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">test-web-deployment</span>
   <span class="na">labels</span><span class="pi">:</span>
     <span class="na">app</span><span class="pi">:</span> <span class="s">web</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">revisionHistoryLimit</span><span class="pi">:</span> <span class="m">5</span>
   <span class="na">strategy</span><span class="pi">:</span>
     <span class="na">type</span><span class="pi">:</span> <span class="s">RollingUpdate</span>
   <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
   <span class="na">selector</span><span class="pi">:</span>
     <span class="na">matchLabels</span><span class="pi">:</span>
       <span class="na">app</span><span class="pi">:</span> <span class="s">web</span>
   <span class="na">template</span><span class="pi">:</span>
     <span class="na">metadata</span><span class="pi">:</span>
       <span class="na">labels</span><span class="pi">:</span>
         <span class="na">app</span><span class="pi">:</span> <span class="s">web</span>
     <span class="na">spec</span><span class="pi">:</span>
       <span class="na">containers</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/test_web:version1</span>
         <span class="na">name</span><span class="pi">:</span> <span class="s">contendor-testweb</span>
         <span class="na">ports</span><span class="pi">:</span>
         <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
           <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/7.png" alt="7" /></p>
  </li>
  <li>
    <p>Creamos el deployment:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl apply <span class="nt">-f</span> test-web-deployment2.yaml
</code></pre></div>    </div>

    <p><strong>NOTA</strong>: Anotaremos el despliegue para tener un registro de los cambios que se han ido realizando.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl annotate deployment/test-web-deployment kubernetes.io/change-cause<span class="o">=</span><span class="s2">"Deployment version 1"</span>
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Creamos una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accedemos a la aplicación con un navegador web.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl port-forward deployment.apps/test-web-deployment 8080:80
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/9.png" alt="9" /></p>
  </li>
</ol>

<h4 id="segunda-versión">Segunda versión</h4>

<p>Nuestro equipo de desarrollo ha seguido trabajando y ya tiene lista la versión 2 de nuestra aplicación, han creado una imagen que se llama: iesgn/test_web:version2. Recuerda que primero debemos descargarnos la imagen del contenedor con un <code class="language-plaintext highlighter-rouge">docker pull iesgn/test_web:version2</code>.Vamos a actualizar nuestro despliegue con la nueva versión, para ello:</p>

<ol>
  <li>Realiza la actualización del despliegue utilizando la nueva imagen y anotamos el registro de cambios.</li>
</ol>

<ul>
  <li>
    <p>Cambiamos el fichero yaml y cambiamos lo siguiente:</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/test_web:version2</span>
<span class="nn">...</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Anotamos la versión 2 de la aplicación.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl annotate deployment/test-web-deployment2 kubernetes.io/change-cause<span class="o">=</span><span class="s2">"Deployment version 2"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Actualizamos el deployment:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> test-web-deployment2.yaml
</code></pre></div>    </div>
  </li>
</ul>

<ol>
  <li>Comprobamos que se han creado los recursos.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  kubectl get all
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t3/10.png" alt="10" /></p>

<ol>
  <li>
    <p>Visualizamos el historial de actualizaciones.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl rollout <span class="nb">history </span>deployment/test-web-deployment
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/11.png" alt="11" /></p>
  </li>
  <li>
    <p>Creamos   una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accedemos a la aplicación con un navegador web.</p>
  </li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  kubectl port-forward deployment.apps/test-web-deployment2 8080:80
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t3/12.png" alt="12" /></p>

<h4 id="tercera-versión">Tercera versión</h4>

<p>Finalmente después de un trabajo muy duro, el equipo de desarrollo ha creado la imagen iesgn/test_web:version3. Recuerda que primero debemos descargarnos la imagen del contenedor con un <code class="language-plaintext highlighter-rouge">docker pull iesgn/test_web:version3</code> y la vamos a poner en producción, para ello:</p>

<ul>
  <li>
    <p>Realizamos la actualización del despliegue utilizando la nueva imagen y anotamos el registro de cambios.</p>

    <ul>
      <li>
        <p>Cambiamos el fichero yaml y cambiamos lo siguiente:</p>

        <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">...</span>
<span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/test_web:version3</span>
<span class="nn">...</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Anotamos la versión 3 de la aplicación.</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl annotate deployment/test-web-deployment kubernetes.io/change-cause<span class="o">=</span><span class="s2">"Deployment version 3"</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Actualizamos el deployment:</p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> test-web-deployment2.yaml
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Comprobamos que se han creado los recursos.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/13.png" alt="13" /></p>
  </li>
  <li>
    <p>Visualizamos el historial de actualizaciones.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  kubectl rollout <span class="nb">history </span>deployment/test-web-deployment2
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/14.png" alt="14" /></p>
  </li>
  <li>
    <p>Creamos una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accedemos a la aplicación con un navegador web.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward deployment.apps/test-web-deployment 8080:80
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/15.png" alt="15" /></p>
  </li>
</ul>

<h4 id="rollback">Rollback</h4>

<p>¡Vaya!, parece que esta versión tiene un fallo, y no se ve de forma adecuada la hoja de estilos, tenemos que volver a la versión anterior:</p>

<ul>
  <li>
    <p>Realizamos el rollback a la versión anterior.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl rollout undo deployment/test-web-deployment
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/16.png" alt="16" /></p>
  </li>
  <li>
    <p>Anotamos el rollback.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl annotate deployment/test-web-deployment2 kubernetes.io/change-cause<span class="o">=</span><span class="s2">"Deployment rollback"</span>
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/17.png" alt="17" /></p>
  </li>
  <li>
    <p>Comprobamos que se han creado los recursos.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl rollout <span class="nb">history </span>deployment/test-web-deployment
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/18.png" alt="18" /></p>
  </li>
  <li>
    <p>Creamos una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 80, y accedemos a la aplicación con un navegador web.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward deployment.apps/test-web-deployment 8080:80
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/19.png" alt="19" /></p>
  </li>
</ul>

<h3 id="ejercicio-3-despliegue-de-la-aplicación-guestbook">Ejercicio 3: Despliegue de la aplicación GuestBook</h3>

<p>En esta tarea vamos a desplegar una aplicación web que requiere de dos servicios para su ejecución. La aplicación se llama GuestBook y necesita los siguientes servicios:</p>

<ul>
  <li>
    <p>La aplicación Guestbook es una aplicación web desarrollada en python que es servida en el puerto 5000/tcp. Utilizaremos la imagen iesgn/guestbook.</p>
  </li>
  <li>
    <p>Esta aplicación guarda la información en una base de datos no relacional redis, que utiliza el puerto 6379/tcp para recibir las conexiones. Usaremos la imagen redis.</p>
  </li>
</ul>

<p>Por lo tanto si tenemos dos servicios distintos, tendremos dos ficheros yaml para crear dos recursos Deployment, uno para cada servicio. Con esta manera de trabajar podemos obtener las siguientes características:</p>

<ul>
  <li>
    <p>Cada conjunto de Pods creado en cada despliegue ejecutarán un solo proceso para ofrecer el servicio.</p>
  </li>
  <li>
    <p>Cada conjunto de Pods se puede escalar de manera independiente. Esto es importante, si identificamos que al acceder a alguno de los servicios se crea un cuello de botella, podemos escalarlo para tener más Pods ejecutando el servicio.</p>
  </li>
  <li>
    <p>Las actualizaciones de los distintos servicios no interfieren en el resto.</p>
  </li>
  <li>
    <p>Lo estudiaremos en un módulo posterior, pero podremos gestionar el almacenamiento de cada servicio de forma independiente.</p>
  </li>
</ul>

<p>Por lo tanto para desplegar la aplicaciones tendremos dos ficheros.yaml:</p>

<ul>
  <li>
    <p>guestbook-deployment.yaml</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">guestbook</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">guestbook</span>
      <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
    <span class="na">selector</span><span class="pi">:</span>
      <span class="na">matchLabels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">guestbook</span>
        <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
    <span class="na">template</span><span class="pi">:</span>
      <span class="na">metadata</span><span class="pi">:</span>
        <span class="na">labels</span><span class="pi">:</span>
          <span class="na">app</span><span class="pi">:</span> <span class="s">guestbook</span>
          <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
      <span class="na">spec</span><span class="pi">:</span>
        <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">contenedor-guestbook</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/guestbook</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http-server</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">5000</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>redis-deployment.yaml</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
  <span class="na">metadata</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">labels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
      <span class="na">tier</span><span class="pi">:</span> <span class="s">backend</span>
  <span class="na">spec</span><span class="pi">:</span>
    <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">selector</span><span class="pi">:</span>
      <span class="na">matchLabels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
        <span class="na">tier</span><span class="pi">:</span> <span class="s">backend</span>
    <span class="na">template</span><span class="pi">:</span>
      <span class="na">metadata</span><span class="pi">:</span>
        <span class="na">labels</span><span class="pi">:</span>
          <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
          <span class="na">tier</span><span class="pi">:</span> <span class="s">backend</span>
      <span class="na">spec</span><span class="pi">:</span>
        <span class="na">containers</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">contenedor-redis</span>
            <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
            <span class="na">ports</span><span class="pi">:</span>
              <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">redis-server</span>
                <span class="na">containerPort</span><span class="pi">:</span> <span class="m">6379</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Para realizar el despliegue realiza los siguientes pasos:</p>

<ul>
  <li>
    <p>Usando los ficheros anteriores, creamos los dos Deployments.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> guestbook-deployment.yaml
kubectl apply <span class="nt">-f</span> redis-deployment.yaml
</code></pre></div>    </div>
  </li>
  <li>
    <p>Comprobamos que se han creado los recursos.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get all
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/20.png" alt="20" /></p>
  </li>
  <li>
    <p>Crea una redirección utilizando el port-forward para acceder a la aplicación, sabiendo que la aplicación ofrece el servicio en el puerto 5000, y accede a la aplicación con un navegador web.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward deployment.apps/guestbook 8080:5000
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t3/21.png" alt="21" /></p>

    <p><img src="/assets/images/kubernetes/t3/22.png" alt="22" /></p>

    <p>Para eliminarlo ejecuta:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  kubectl delete <span class="nt">-f</span> guestbook-deployment.yaml
  kubectl delete <span class="nt">-f</span> redis-deployment.yaml
</code></pre></div>    </div>

    <p>¿Qué aparece en la página principal de la aplicación?. Aparece el siguiente mensaje: Waiting for database connection…. Por lo tanto podemos indicar varias conclusiones:</p>
  </li>
</ul>

<ol>
  <li>
    <p>Hasta ahora no estamos accediendo de forma “normal” a las aplicaciones. El uso de la opción port-forward es un mecanismo que realmente nos posibilita acceder a la aplicación, pero utilizando un proxy. Deberíamos acceder a las aplicaciones usando una ip y un puerto determinado.</p>
  </li>
  <li>
    <p>Parece que tampoco hay acceso entre los Pods de los distintos despliegues. Parece que los Pods de la aplicación guestbook no pueden acceder al Pod donde se está ejecutando la base de datos redis.</p>
  </li>
</ol>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Introducción]]></summary></entry><entry><title type="html">Taller Kubernetes: Trabajando con Pods</title><link href="/hlc+sri/2023/02/03/kubernetes-pods.html" rel="alternate" type="text/html" title="Taller Kubernetes: Trabajando con Pods" /><published>2023-02-03T16:45:16+01:00</published><updated>2023-02-03T16:45:16+01:00</updated><id>/hlc+sri/2023/02/03/kubernetes-pods</id><content type="html" xml:base="/hlc+sri/2023/02/03/kubernetes-pods.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>Un Pod en kubernetes es un grupo de uno o más contenedores que comparten un espacio de red y espacio de almacenamiento. Los Pods son la unidad de despliegue en Kubernetes. Un Pod representa un proceso en ejecución en su clúster.</p>

<p>En este post vamos a crear un Pod en Kubernetes y para ello, vamos a desplegar una imagen que nos ofrece un servidor web con una página estática.</p>

<h2 id="desplegando-un-pod">Desplegando un Pod</h2>

<h3 id="creando-un-pod">Creando un Pod</h3>

<p>Lo primero que vamos a hacer, es crear un fichero yaml con la descripción del recurso Pod, teniendo en cuenta lo siguiente:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Los pods deben tener distinto nombre que el del contenedor.
* La imagen que vamos a desplegar es `iesgn/test_web:latest`.
* Le asignaremos una etiqueta en la descripción del Pod.
</code></pre></div></div>

<p>Antes que nada nos vamos a descargar la imagen con un <code class="language-plaintext highlighter-rouge">docker pull iesgn/test_web:latest</code>:</p>

<p><img src="/assets/images/kubernetes/t1/1.png" alt="1" /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">pod-test-web</span>
 <span class="na">labels</span><span class="pi">:</span>
   <span class="na">service</span><span class="pi">:</span> <span class="s">pod-taller1</span>
<span class="na">spec</span><span class="pi">:</span>
 <span class="na">containers</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/test_web:latest</span>
     <span class="na">name</span><span class="pi">:</span> <span class="s">container-test-web</span>
</code></pre></div></div>

<p>Una vez creado el fichero, vamos a crear el Pod en nuestro clúster de Kubernetes.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> test_web.yaml
</code></pre></div></div>

<h3 id="comprobando-el-estado-del-pod">Comprobando el estado del Pod</h3>

<p>Para comprobar el estado del Pod, podemos ejecutar el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pod pod-test-web <span class="nt">-o</span> wide
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/2.png" alt="2" /></p>

<p>Como podemos ver, el Pod se ha creado correctamente y está en estado <code class="language-plaintext highlighter-rouge">Running</code>.</p>

<h3 id="obteniendo-información-del-pod">Obteniendo información del Pod</h3>

<p>Para obtener información del Pod, podemos ejecutar el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pod pod-test-web <span class="nt">-o</span> wide
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/3.png" alt="3" /></p>

<p>O con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe pod pod-test-web
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/4.png" alt="4" /></p>

<h3 id="accediendo-al-pod">Accediendo al Pod</h3>

<p>En esta ocasión, vamos a acceder de forma interactiva y comprobaremos los ficheros que están en el <code class="language-plaintext highlighter-rouge">DocumentRoot</code> del servidor web.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec</span> <span class="nt">-it</span> pod-test-web <span class="nt">--</span> /bin/bash
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-la</span> htdocs/
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/5.png" alt="5" /></p>

<h3 id="creando-una-redirección">Creando una redirección</h3>

<p>Vamos a crear una redirección con <code class="language-plaintext highlighter-rouge">kubectl port-forward</code> para poder acceder al Pod desde el navegador. Utilizaremos el puerto 8888 del localhost y redirigiremos el puerto 80 del Pod.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward test-web 8888:80
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/6.png" alt="6" /></p>

<p>Ahora, podemos acceder al Pod desde el navegador con la siguiente URL: <code class="language-plaintext highlighter-rouge">http://localhost:8888</code>.</p>

<p><img src="/assets/images/kubernetes/t1/7.png" alt="7" /></p>

<h3 id="mostrando-los-logs-del-pod">Mostrando los logs del Pod</h3>

<p>Para mostrar los logs del Pod, podemos ejecutar el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs test-web
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/8.png" alt="8" /></p>

<p>De esta manera, podemos ver los logs del servidor web que hemos desplegado.</p>

<h3 id="eliminando-el-pod">Eliminando el Pod</h3>

<p>Para eliminar el Pod, podemos ejecutar el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete pod pod-test-web

kubectl get pod
</code></pre></div></div>

<p><img src="/assets/images/kubernetes/t1/9.png" alt="9" /></p>

<p>Como podemos ver en la imagen anterior, el pod se ha eliminado correctamente.</p>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Introducción]]></summary></entry><entry><title type="html">Taller Kubernetes: Trabajando con ReplicaSet</title><link href="/hlc+sri/2023/02/03/kubernetes-replicaset.html" rel="alternate" type="text/html" title="Taller Kubernetes: Trabajando con ReplicaSet" /><published>2023-02-03T16:45:16+01:00</published><updated>2023-02-03T16:45:16+01:00</updated><id>/hlc+sri/2023/02/03/kubernetes-replicaset</id><content type="html" xml:base="/hlc+sri/2023/02/03/kubernetes-replicaset.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>En este taller vamos a trabajar con ReplicaSet, que es un objeto de Kubernetes que nos permite crear un conjunto de Pods idénticos. En este caso, vamos a crear un ReplicaSet que va a controlar un conjunto de Pods.</p>

<h3 id="creando-un-replicaset">Creando un ReplicaSet</h3>

<ol>
  <li>
    <p>Creamos un fichero yaml con la descripción del recurso ReplicaSet, teniendo en cuenta los siguientes aspectos:</p>

    <ul>
      <li>Indicaremos nombres distintos para el ReplicaSet y para el contenedor de los Pods que va a controlar.</li>
      <li>El ReplicaSet va a crear 3 réplicas.</li>
      <li>La imagen que debemos desplegar es iesgn/test_web:latest.</li>
      <li>Indicaremos de manera adecuada una etiqueta en la especificación del Pod que vas a definir que coincida con el selector del ReplicaSet.</li>
    </ul>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicaSet</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">test-web-replica</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
   <span class="na">selector</span><span class="pi">:</span>
     <span class="na">matchLabels</span><span class="pi">:</span>
       <span class="na">app</span><span class="pi">:</span> <span class="s">web-test</span>
   <span class="na">template</span><span class="pi">:</span>
     <span class="na">metadata</span><span class="pi">:</span>
       <span class="na">labels</span><span class="pi">:</span>
         <span class="na">app</span><span class="pi">:</span> <span class="s">web-test</span>
     <span class="na">spec</span><span class="pi">:</span>
       <span class="na">containers</span><span class="pi">:</span>
         <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">iesgn/test_web:latest</span>
           <span class="na">name</span><span class="pi">:</span> <span class="s">container-test-web</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Creamos el recurso:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl apply <span class="nt">-f</span> test-web-replica.yaml
</code></pre></div>    </div>
  </li>
  <li>
    <p>Comprobamos que se ha creado el ReplicaSet:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get rs,pods
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t2/1.png" alt="1" /></p>
  </li>
  <li>
    <p>Obtenemos la información detallada del ReplicaSet:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl describe rs test-web-replica
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t2/2.png" alt="2" /></p>
  </li>
  <li>
    <p>Vamos a probar la tolerancia a fallos: Elimina uno de los 3 Pods, y comprueba que inmediatamente se ha vuelto a crear un nuevo Pod</p>

    <ul>
      <li>Obtenemos el nombre del Pod que queremos eliminar:</li>
    </ul>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get pods
</code></pre></div>    </div>

    <ul>
      <li>Eliminamos el Pod:
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl delete pod test-web-replica-96tvz
</code></pre></div>        </div>
      </li>
    </ul>

    <p><img src="/assets/images/kubernetes/t2/3.png" alt="3" /></p>
  </li>
  <li>
    <p>Vamos a comprobar la escalabilidad: escala el ReplicaSet para tener 6 Pods de la aplicación.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl scale rs test-web-replica <span class="nt">--replicas</span><span class="o">=</span>6
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t2/4.png" alt="4" /></p>
  </li>
  <li>
    <p>Elimina el ReplicaSet y comprueba que se han borrado todos los Pods.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl delete rs test-web-replica
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/t2/5.png" alt="5" /></p>
  </li>
</ol>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Introducción]]></summary></entry><entry><title type="html">Kubernetes: Instalación y configuración de minikube y kubectl</title><link href="/hlc+sri/2023/02/01/kubernetes-instalacion.html" rel="alternate" type="text/html" title="Kubernetes: Instalación y configuración de minikube y kubectl" /><published>2023-02-01T16:45:16+01:00</published><updated>2023-02-01T16:45:16+01:00</updated><id>/hlc+sri/2023/02/01/kubernetes-instalacion</id><content type="html" xml:base="/hlc+sri/2023/02/01/kubernetes-instalacion.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>Como nos cuentan en su <a href="https://kubernetes.io/es/">página oficial</a>,Kubernetes es una plataforma de orquestación de contenedores de código abierto que automatiza la implementación, la gestión y el escalado de aplicaciones en contenedores. Dicho de otra manera, es un sistema de administración de clústeres que mantiene las cargas de trabajo en ejecución y es un gran problema en DevOps.</p>

<p>A medida que la adopción nativa de la nube sigue aumentando, Kubernetes se ha convertido en la plataforma de infraestructura de más rápido crecimiento. Un informe de Cloud Native Computing Foundation (CNCF) descubrió que para 2020, más del 90 % de las organizaciones encuestadas usaban Kubernetes.</p>

<h2 id="instalación">Instalación</h2>

<h3 id="instalando-minikube">Instalando minikube</h3>

<p>Vamos a instalar minikube en nuestro sistema operativo. En mi caso, os voy a mostrar cómo hacerlo en Debian 11. Para ello, vamos a realizar los siguientes pasos:</p>

<ol>
  <li>
    <p>Descargar el binario de minikube desde su <a href="https://minikube.sigs.k8s.io/docs/start/">página oficial</a>.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> curl <span class="nt">-LO</span> https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
</code></pre></div>    </div>
  </li>
  <li>
    <p>Instalar el binario en el sistema.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">sudo install </span>minikube-linux-amd64 /usr/local/bin/minikube
</code></pre></div>    </div>
  </li>
  <li>
    <p>Comprobar que se ha instalado correctamente.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> minikube version
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/1.png" alt="1" /></p>
  </li>
  <li>
    <p>Iniciamos un clúster de Kubernetes con minikube.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> minikube start <span class="nt">--driver</span><span class="o">=</span>kvm2
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/2.png" alt="2" /></p>
  </li>
  <li>
    <p>Comprobamos su estado.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> minikube status
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/3.png" alt="3" /></p>
  </li>
</ol>

<h3 id="instalando-kubectl">Instalando kubectl</h3>

<p>Para instalar kubectl, vamos a realizar los siguientes pasos:</p>

<ol>
  <li>
    <p>Instalamos kubernetes-client en nuestro sistema.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>apt <span class="nb">install </span>kubernetes-client
</code></pre></div>    </div>
  </li>
  <li>
    <p>Comprobamos que se ha instalado correctamente.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl version
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/4.png" alt="4" /></p>

    <p>Si visualizamos el fichero que se nos ha creado en nuestro directorio <code class="language-plaintext highlighter-rouge">/home</code>, veremos que se ha creado un fichero de configuración en .kube.</p>

    <p><img src="/assets/images/kubernetes/instalacion/5.png" alt="5" /></p>

    <p>En este fichero se encuentra la configuración de nuestro clúster de Kubernetes.</p>
  </li>
</ol>

<h3 id="comandos-básicos">Comandos básicos</h3>

<ul>
  <li>Muestra la IP del clúster.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get nodes <span class="nt">-o</span> wide
</code></pre></div></div>

<ul>
  <li>Muestra los pods que se están ejecutando en el clúster.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods
</code></pre></div></div>

<ul>
  <li>Muestra los servicios que se están ejecutando en el clúster.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get services
</code></pre></div></div>

<ul>
  <li>Muestra los deployments que se están ejecutando en el clúster.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get deployments
</code></pre></div></div>

<ul>
  <li>Borra todos los deployments que se están ejecutando en el clúster.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete all <span class="nt">--all</span> <span class="nt">--all-namespaces</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Introducción]]></summary></entry><entry><title type="html">Kubernetes: Trabajando con un Pod multicontenedor</title><link href="/hlc+sri/2023/02/01/kubernetes-multicontenedor.html" rel="alternate" type="text/html" title="Kubernetes: Trabajando con un Pod multicontenedor" /><published>2023-02-01T16:45:16+01:00</published><updated>2023-02-01T16:45:16+01:00</updated><id>/hlc+sri/2023/02/01/kubernetes-multicontenedor</id><content type="html" xml:base="/hlc+sri/2023/02/01/kubernetes-multicontenedor.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>Vamos a profundizar en los Pods multicontenedor. Como indicamos en el contenido del módulo, un Pod puede estar formado por varios contenedores y por volúmenes (para permitir que los contenedores del Pod puedan compartir almacenamiento).</p>

<p>La razón principal por la que los Pods pueden tener múltiples contenedores es para admitir aplicaciones auxiliares que ayudan a una aplicación primaria. Ejemplos típicos de estas aplicaciones pueden ser las que envían o recogen datos externos (por ejemplo de un repositorio) y los servidores proxy. El ayudante y las aplicaciones primarias a menudo necesitan comunicarse entre sí. Normalmente, esto se realiza a través de un sistema de archivos compartido o mediante la interfaz loopback (localhost).</p>

<h2 id="creando-un-pod-multicontenedor">Creando un Pod multicontenedor</h2>

<ol>
  <li>
    <p>Creamos un fichero yaml con la descripción del Pod multicontenedor. En este caso, vamos a crear un Pod con dos contenedores: uno con la imagen <code class="language-plaintext highlighter-rouge">nginx</code> y otro con la imagen <code class="language-plaintext highlighter-rouge">busybox</code>.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> vi pod-multicontenedor.yaml
</code></pre></div>    </div>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
 <span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
 <span class="na">metadata</span><span class="pi">:</span>
   <span class="na">name</span><span class="pi">:</span> <span class="s">pod-multicontenedor</span>
 <span class="na">spec</span><span class="pi">:</span>
   <span class="na">volumes</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
     <span class="na">emptyDir</span><span class="pi">:</span> <span class="pi">{}</span>
   <span class="na">containers</span><span class="pi">:</span>
   <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">contenedor1</span>
     <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
     <span class="na">volumeMounts</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
       <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/usr/share/nginx/html</span>
   <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">contenedor2</span>
     <span class="na">image</span><span class="pi">:</span> <span class="s">debian</span>
     <span class="na">volumeMounts</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">html</span>
       <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/html</span>
     <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">/bin/sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-c"</span><span class="pi">]</span>
     <span class="na">args</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="s">while </span><span class="no">true</span><span class="s">; do</span>
           <span class="s">date &gt;&gt; /html/index.html;</span>
           <span class="s">sleep 1;</span>
         <span class="s">done</span>
</code></pre></div>    </div>
  </li>
  <li>Vamos a crear un pod.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl create <span class="nt">-f</span> pod-multicontenedor.yaml
</code></pre></div>    </div>
  </li>
  <li>Mostramos la información del pod, y podemos ver que tiene dos contenedores.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get pod pod-multicontenedor <span class="nt">-o</span> wide
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/6.png" alt="6" /></p>
  </li>
  <li>
    <p>Mostramos el contenido de <code class="language-plaintext highlighter-rouge">index.html</code> del primer contenedor:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl <span class="nb">exec </span>pod-multicontenedor <span class="nt">-c</span> contenedor1 <span class="nt">--</span> /bin/cat /usr/share/nginx/html/index.html
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/7.png" alt="7" /></p>
  </li>
  <li>
    <p>Mostramos el contenido de <code class="language-plaintext highlighter-rouge">index.html</code> del segundo contenedor:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl <span class="nb">exec </span>pod-multicontenedor <span class="nt">-c</span> contenedor2 <span class="nt">--</span> /bin/cat /html/index.html
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Ejecutamos un “port forward” para acceder al Pod en el puerto 8081 de localhost, sabiendo que el servicio usa el puerto 80.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl port-forward pod-multicontenedor 8081:80
</code></pre></div>    </div>

    <p><img src="/assets/images/kubernetes/instalacion/9.png" alt="9" /></p>
  </li>
  <li>
    <p>Accede desde un navegador para ver el resultado. Refresca la página para observar cómo va cambiando el fichero index.html.</p>

    <p><img src="/assets/images/kubernetes/instalacion/10.png" alt="10" /></p>
  </li>
</ol>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Introducción]]></summary></entry><entry><title type="html">Taller de Almacenamiento - Creación de un cluster DRBD + OCFS2</title><link href="/hlc+sri/2023/01/29/DRBD+OCFS2.html" rel="alternate" type="text/html" title="Taller de Almacenamiento - Creación de un cluster DRBD + OCFS2" /><published>2023-01-29T17:47:32+01:00</published><updated>2023-01-29T17:47:32+01:00</updated><id>/hlc+sri/2023/01/29/DRBD+OCFS2</id><content type="html" xml:base="/hlc+sri/2023/01/29/DRBD+OCFS2.html"><![CDATA[<h2 id="introducción">Introducción</h2>

<p>En este post vamos a ver cómo crear un cluster DRBD + OCFS2 para almacenar datos en un entorno de alta disponibilidad. Para ello, vamos a utilizar dos maquinas virtuales, a las que les vamos a añadir dos discos adicionales de 2GB para que la sincronización de los datos sea más rápida.</p>

<h2 id="creación-de-las-máquinas-virtuales">Creación de las máquinas virtuales</h2>

<p>Para crear las máquinas virtuales, vamos a montarlas con Vagrant con el siguiente fichero:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Vagrant</span><span class="p">.</span><span class="nf">configure</span><span class="p">(</span><span class="s2">"2"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">define</span> <span class="ss">:mac1</span> <span class="k">do</span> <span class="o">|</span><span class="n">mac1</span><span class="o">|</span>
    <span class="n">mac1</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">box</span> <span class="o">=</span> <span class="s2">"debian/bullseye64"</span>
    <span class="n">mac1</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">hostname</span> <span class="o">=</span> <span class="s2">"mac1"</span>
    <span class="n">mac1</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">synced_folder</span> <span class="s2">"."</span><span class="p">,</span> <span class="s2">"/vagrant"</span><span class="p">,</span> <span class="ss">disabled: </span><span class="kp">true</span>
    <span class="n">mac1</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">network</span> <span class="s2">"private_network"</span><span class="p">,</span> <span class="ss">ip: </span><span class="s2">"10.0.0.20"</span>
    <span class="n">mac1</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">provider</span> <span class="ss">:libvirt</span> <span class="k">do</span> <span class="o">|</span><span class="n">libvirt</span><span class="o">|</span>
        <span class="n">libvirt</span><span class="p">.</span><span class="nf">storage</span> <span class="ss">:file</span><span class="p">,</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="s1">'2G'</span>
        <span class="n">libvirt</span><span class="p">.</span><span class="nf">storage</span> <span class="ss">:file</span><span class="p">,</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="s1">'2G'</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">define</span> <span class="ss">:mac2</span> <span class="k">do</span> <span class="o">|</span><span class="n">mac2</span><span class="o">|</span>
    <span class="n">mac2</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">box</span> <span class="o">=</span> <span class="s2">"debian/bullseye64"</span>
    <span class="n">mac2</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">hostname</span> <span class="o">=</span> <span class="s2">"mac2"</span>
    <span class="n">mac2</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">synced_folder</span> <span class="s2">"."</span><span class="p">,</span> <span class="s2">"/vagrant"</span><span class="p">,</span> <span class="ss">disabled: </span><span class="kp">true</span>
    <span class="n">mac2</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">network</span> <span class="s2">"private_network"</span><span class="p">,</span> <span class="ss">ip: </span><span class="s2">"10.0.0.30"</span>
    <span class="n">mac2</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">provider</span> <span class="ss">:libvirt</span> <span class="k">do</span> <span class="o">|</span><span class="n">libvirt</span><span class="o">|</span>
        <span class="n">libvirt</span><span class="p">.</span><span class="nf">storage</span> <span class="ss">:file</span><span class="p">,</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="s1">'2G'</span>
        <span class="n">libvirt</span><span class="p">.</span><span class="nf">storage</span> <span class="ss">:file</span><span class="p">,</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="s1">'2G'</span>
  <span class="k">end</span>
 <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="instalación">Instalación</h2>

<p>Para realizar este establecimiento, instalar el paquete DRBD:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>drbd-utils <span class="nt">-y</span>
</code></pre></div></div>

<p>Y para la implementación del sistema de ficheros, vamos a instalar OCFS2:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>ocfs2-tools <span class="nt">-y</span>
</code></pre></div></div>

<h2 id="creación-de-los-recursos-drdb">Creación de los recursos DRDB</h2>

<p>Una vez realizada la instalación de ambos paquetes, vamos a configurar el DRBD. Para ello, vamos a editar el fichero <code class="language-plaintext highlighter-rouge">/etc/drbd.d/wwwdata.res</code>. Deberemos añadir los dos discos que hemos creado en las máquinas virtuales, y añadir la siguiente configuración:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource wwwdata <span class="o">{</span>
  protocol C<span class="p">;</span>
  meta-disk internal<span class="p">;</span>
  device /dev/drbd1<span class="p">;</span>
  syncer <span class="o">{</span>
    verify-alg sha1<span class="p">;</span>
  <span class="o">}</span>
  net <span class="o">{</span>
    allow-two-primaries<span class="p">;</span>
  <span class="o">}</span>
  on mac1 <span class="o">{</span>
    disk /dev/vdb<span class="p">;</span>
    address 10.0.0.20:7789<span class="p">;</span>
  <span class="o">}</span>
  on mac2 <span class="o">{</span>
    disk /dev/vdb<span class="p">;</span>
    address 10.0.0.30:7789<span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Creado el fichero anterior, lo siguiente es crear el recurso en ambas máquinas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drbdadm create-md wwwdata
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/1.png" alt="1" /></p>

<p><img src="/assets/images/almacenamiento/taller3/2.png" alt="2" /></p>

<p>Lo mismo que hemos hecho ahora lo haremos con el segundo recurso, que se llamará <code class="language-plaintext highlighter-rouge">dbdata.res</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource dbdata <span class="o">{</span>
  protocol C<span class="p">;</span>
  meta-disk internal<span class="p">;</span>
  device /dev/drbd2<span class="p">;</span>
  syncer <span class="o">{</span>
    verify-alg sha1<span class="p">;</span>
  <span class="o">}</span>
  net <span class="o">{</span>
    allow-two-primaries<span class="p">;</span>
  <span class="o">}</span>
  on mac1 <span class="o">{</span>
    disk /dev/vdc<span class="p">;</span>
    address 10.0.0.20:7790<span class="p">;</span>
  <span class="o">}</span>
  on mac2 <span class="o">{</span>
    disk /dev/vdc<span class="p">;</span>
    address 10.0.0.30:7790<span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Creado el fichero anterior, lo siguientees crear el recurso en ambas máquinas:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drbdadm create-md dbdata
</code></pre></div></div>
<p><img src="/assets/images/almacenamiento/taller3/3.png" alt="3" /></p>

<p><img src="/assets/images/almacenamiento/taller3/4.png" alt="4" /></p>

<h2 id="configuración-single-primary-de-wwwdata">Configuración Single-Primary de wwwdata</h2>
<p>Ahora vamos a configurar <code class="language-plaintext highlighter-rouge">wwwdata</code> en modo <code class="language-plaintext highlighter-rouge">Single Primary</code>. Para ello, los activamos con el comando <code class="language-plaintext highlighter-rouge">drbdadm up wwwdata</code> y miramos el estado en ambas máquinas:</p>

<p><img src="/assets/images/almacenamiento/taller3/5.png" alt="5" /></p>

<p><img src="/assets/images/almacenamiento/taller3/6.png" alt="6" /></p>

<p>Como podemos ver en las imágenes anteriores, ambos recursos están en modo <code class="language-plaintext highlighter-rouge">Secondary/Secondary</code>. Para cambiar esto, vamos a hacer que uno de los recursos sea primario, en este caso, <code class="language-plaintext highlighter-rouge">wwwdata</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drbdadm primary <span class="nt">--force</span> wwwdata
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/7.png" alt="7" /></p>

<p><img src="/assets/images/almacenamiento/taller3/8.png" alt="8" /></p>

<p>Al pasar escaso tiempo, podemos ver que el estado del recurso pasará a <code class="language-plaintext highlighter-rouge">UpToDate/UpToDate</code>. Esto quiere decir están sincronizados.</p>

<p><img src="/assets/images/almacenamiento/taller3/9.png" alt="9" /></p>

<p><img src="/assets/images/almacenamiento/taller3/10.png" alt="10" /></p>

<p>El siguiente paso que deberíamos hacer es darle formato al recurso que acabamos de crear, de momento en la primera máquina:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>xfsprogs

mkfs.xfs /dev/drbd1
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/11.png" alt="11" /></p>

<p>Lo montamos y creamos un fichero para comprobar su funcionamiento:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mount /dev/drbd1 /mnt

<span class="nb">echo</span> <span class="s2">"Hola mundo"</span> <span class="o">&gt;</span> /mnt/hola.txt
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/12.png" alt="12" /></p>

<p>Si intentásemos montar el mismo recurso en la segunda máquina, no podríamos, ya que el recurso está en modo <code class="language-plaintext highlighter-rouge">Secondary</code>. Para poder montarlo, deberíamos desmontar el recurso, cambiar los roles y volver a montarlo pero en la segunda máquina:</p>

<ul>
  <li>Error de montaje:</li>
</ul>

<p><img src="/assets/images/almacenamiento/taller3/13.png" alt="13" /></p>

<ul>
  <li>Desmontaje del recurso en <code class="language-plaintext highlighter-rouge">mac1</code>:</li>
</ul>

<p><img src="/assets/images/almacenamiento/taller3/14.png" alt="14" /></p>

<ul>
  <li>Cambiamos los roles, ponemos la <code class="language-plaintext highlighter-rouge">mac1</code> en modo secundaria y la <code class="language-plaintext highlighter-rouge">mac2</code> en modo primario:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#mac1</span>
drbdadm secondary wwwdata
<span class="c">#mac2</span>
drbdadm primary <span class="nt">--force</span> wwwdata
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/15.png" alt="15" /></p>

<p><img src="/assets/images/almacenamiento/taller3/16.png" alt="16" /></p>

<p>El mismo montaje que hemos realizado en la primera máquina, lo haremos en la segunda:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mount /dev/drbd1 /mnt
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/17.png" alt="17" /></p>

<p>Y como podemos ver en la imagen anterior, el fichero que creamos en la primera máquina, podemos ver que sigue existiendo.</p>

<h2 id="configuración-del-recurso-dbdata-en-modo-dual-primary">Configuración del recurso dbdata en modo Dual-Primary</h2>

<p>Ahora vamos a configurar el recurso <code class="language-plaintext highlighter-rouge">dbdata</code> en modo <code class="language-plaintext highlighter-rouge">Dual-Primary</code>. Para ello, vamor a levantar el recurso en ambas máquinas.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drbdadm up dbdata
drbdadm status dbdata
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/18.png" alt="18" /></p>

<p><img src="/assets/images/almacenamiento/taller3/19.png" alt="19" /></p>

<p>Ya con el recurso levantado vamos a configurarlo en modo <code class="language-plaintext highlighter-rouge">Dual-Primary</code>. Para ello vamos a configurar el recurso en ambos nodos como primarios:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drbdadm primary <span class="nt">--force</span> dbdata
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/20.png" alt="20" /></p>

<p><img src="/assets/images/almacenamiento/taller3/21.png" alt="21" /></p>

<p>Para poder hacer que los dos recursos sean primarios, deberemos cambiar el sistema de ficheros por <code class="language-plaintext highlighter-rouge">OCFS2</code>. Pero, ¿qué es OCFS2?</p>

<p><strong>O</strong>racle <strong>C</strong>luster <strong>F</strong>ile System (OCFS2) es un sistema de archivos de código abierto que se basa en el sistema de archivos de Linux. Es un sistema de archivos de cluster de alto rendimiento que se puede utilizar para crear un sistema de archivos distribuido en un cluster de Linux.</p>

<p>Una vez entendido esto, instalamos el paquete <code class="language-plaintext highlighter-rouge">ocfs2-tools</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt <span class="nb">install </span>ocfs2-tools
</code></pre></div></div>

<p>Creamos el cluster y añadimos los nodos a este mismo de la siguiente manera:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#Creación del cluster</span>
o2cb add-cluster tclust
<span class="c">#Añadir nodos al cluster</span>
o2cb add-node tclust mac1 <span class="nt">--ip</span> 10.0.0.20
o2cb add-node tclust mac2 <span class="nt">--ip</span> 10.0.0.30
</code></pre></div></div>

<p>Todo esto lo realizaremos en el <code class="language-plaintext highlighter-rouge">mac1</code>. Y como podemos ver en la imagen, el cluster se ha creado correctamente y los nodos están añadidos.</p>

<p><img src="/assets/images/almacenamiento/taller3/22.png" alt="22" /></p>

<p>El contenido que vemos en esta imagen, será el contenido del mismo fichero en la máquina <code class="language-plaintext highlighter-rouge">mac2</code> ya que hemos copiado el fichero de configuración del cluster de la máquina <code class="language-plaintext highlighter-rouge">mac1</code> a la máquina <code class="language-plaintext highlighter-rouge">mac2</code>.</p>

<p><img src="/assets/images/almacenamiento/taller3/23.png" alt="23" /></p>

<p>Ahora vamos a modificar el fichero <code class="language-plaintext highlighter-rouge">/etc/default/o2cb</code> en ambas máquinas de la siguiente manera:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># O2CB_ENABLED: 'true' means to load the driver on boot.</span>
<span class="nv">O2CB_ENABLED</span><span class="o">=</span><span class="nb">true</span>

<span class="c"># O2CB_BOOTCLUSTER: If not empty, the name of a cluster to start.</span>
<span class="nv">O2CB_BOOTCLUSTER</span><span class="o">=</span>tclust

<span class="c"># O2CB_HEARTBEAT_THRESHOLD: Iterations before a node is considered dead.</span>
<span class="nv">O2CB_HEARTBEAT_THRESHOLD</span><span class="o">=</span>31

<span class="c"># O2CB_IDLE_TIMEOUT_MS: Time in ms before a network connection is considered dead.</span>
<span class="nv">O2CB_IDLE_TIMEOUT_MS</span><span class="o">=</span>30000

<span class="c"># O2CB_KEEPALIVE_DELAY_MS: Max. time in ms before a keepalive packet is sent.</span>
<span class="nv">O2CB_KEEPALIVE_DELAY_MS</span><span class="o">=</span>2000

<span class="c"># O2CB_RECONNECT_DELAY_MS: Min. time in ms between connection attempts.</span>
<span class="nv">O2CB_RECONNECT_DELAY_MS</span><span class="o">=</span>2000
</code></pre></div></div>

<p>Para que funciones de forma correcta, deberemos modificar el kernel con ciertos parámetros en ambas máquinas. Para eso, modificamos el fichero <code class="language-plaintext highlighter-rouge">/etc/sysctl.conf</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kernel.panic <span class="o">=</span> 30
kernel.panic_on_oops <span class="o">=</span> 1
</code></pre></div></div>

<p>Aplicamos los cambios con un <code class="language-plaintext highlighter-rouge">sysctl -p</code>.</p>

<p><img src="/assets/images/almacenamiento/taller3/24.png" alt="24" /></p>

<p><img src="/assets/images/almacenamiento/taller3/25.png" alt="25" /></p>

<p>Para finalizar, ponemos en marcha el cluster en ambas máquinas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>o2cb register-cluster tclust
o2cb cluster-status tclust
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/26.png" alt="26" /></p>

<p><img src="/assets/images/almacenamiento/taller3/27.png" alt="27" /></p>

<p>Tras verificar que el estado de nuestro cluster es <code class="language-plaintext highlighter-rouge">online</code>, vamos a crear el sistema de ficheros <code class="language-plaintext highlighter-rouge">OCFS2</code> en el recurso <code class="language-plaintext highlighter-rouge">dbdata</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>mkfs.ocfs2 <span class="nt">--cluster-stack</span><span class="o">=</span>o2cb <span class="nt">--cluster-name</span><span class="o">=</span>tclust /dev/drbd2
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/28.png" alt="28" /></p>

<p>Desde la <code class="language-plaintext highlighter-rouge">mac2</code> podemos verificr que el sistema de ficheros <code class="language-plaintext highlighter-rouge">OCFS2</code> se ha creado correctamente:</p>

<p><img src="/assets/images/almacenamiento/taller3/29.png" alt="29" /></p>

<p><img src="/assets/images/almacenamiento/taller3/30.png" alt="30" /></p>

<p>Una vez realizado el formateo del sistema de ficheros, montamos los nodos en el directorio <code class="language-plaintext highlighter-rouge">/mnt</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mount /dev/drbd2 /mnt
</code></pre></div></div>

<p><img src="/assets/images/almacenamiento/taller3/31.png" alt="31" /></p>

<p><img src="/assets/images/almacenamiento/taller3/32.png" alt="32" /></p>

<p>Para comprobar que funciona correctamente, vamos a crear un fichero en <code class="language-plaintext highlighter-rouge">mac1</code> y lo vamos a editar desde <code class="language-plaintext highlighter-rouge">mac2</code>. Tras ello, comprobamos los cambios en <code class="language-plaintext highlighter-rouge">mac1</code>:</p>

<ul>
  <li>
    <p>Creamos el fichero en <code class="language-plaintext highlighter-rouge">mac1</code>:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Hola mundo"</span> <span class="o">&gt;</span> /mnt/hola.txt
</code></pre></div>    </div>

    <p><img src="/assets/images/almacenamiento/taller3/33.png" alt="33" /></p>
  </li>
  <li>
    <p>Comprobamos su contenido y lo editamos:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /mnt/hola.txt
<span class="nb">echo</span> <span class="s2">"Hola mundo 2"</span> <span class="o">&gt;</span> /mnt/hola.txt
</code></pre></div>    </div>

    <p><img src="/assets/images/almacenamiento/taller3/34.png" alt="34" /></p>
  </li>
  <li>
    <p>Comprobamos los cambios en <code class="language-plaintext highlighter-rouge">mac1</code>:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /mnt/hola.txt
</code></pre></div>    </div>

    <p><img src="/assets/images/almacenamiento/taller3/35.png" alt="35" /></p>
  </li>
</ul>]]></content><author><name></name></author><category term="HLC+SRI" /><summary type="html"><![CDATA[Introducción]]></summary></entry></feed>