<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Cortafuegos II: Perimetral con nftables | sysmaria</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="Cortafuegos II: Perimetral con nftables">
<meta property="og:locale" content="en_US">
<meta name="description" content="Introducción">
<meta property="og:description" content="Introducción">
<link rel="canonical" href="/seguridad/2023/02/01/cortafuegos-2.html">
<meta property="og:url" content="/seguridad/2023/02/01/cortafuegos-2.html">
<meta property="og:site_name" content="sysmaria">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-01T16:45:16+01:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Cortafuegos II: Perimetral con nftables">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-01T16:45:16+01:00","datePublished":"2023-02-01T16:45:16+01:00","description":"Introducción","headline":"Cortafuegos II: Perimetral con nftables","mainEntityOfPage":{"@type":"WebPage","@id":"/seguridad/2023/02/01/cortafuegos-2.html"},"url":"/seguridad/2023/02/01/cortafuegos-2.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="sysmaria">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="sysmaria" src="" onerror="this.style.display='none'">
  sysmaria
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/categories.html">CATEGORIAS</a>




</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/assets/images/banners/iptables.png)"></div>
        <img class="img-placeholder" src="/assets/images/banners/iptables.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Cortafuegos II: Perimetral con nftables</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2023-02-01T16:45:16+01:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 1, 2023
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 23 mins</span>
  </p></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="introducción">Introducción</h2>

<p>nftables reemplaza las populares tablas {ip, ip6, arp, eb}. Este software proporciona un nuevo marco de clasificación de paquetes en el núcleo que se basa en una máquina virtual (VM) específica de la red y una nueva herramienta de línea de comandos del espacio de usuario nft. nftables reutiliza los subsistemas de Netfilter existentes, como la infraestructura de enlace existente, el sistema de seguimiento de conexiones, NAT, el subsistema de registro y colas del espacio de usuario.</p>

<p>Este software también proporciona libnftables, la biblioteca de espacio de usuario de alto nivel que incluye compatibilidad con JSON. Esta biblioteca se puede utilizar para crear y administrar reglas de nftables desde aplicaciones de terceros.</p>

<h2 id="esquema-de-red">Esquema de red</h2>

<p>Vamos a utilizar dos máquinas en openstack, que vamos a crear con la receta heat: <a href="https://fp.josedomingo.org/seguridadgs/u03/escenario2.yaml">escenario2.yaml</a>. La receta heat ha deshabilitado el cortafuego que nos ofrece openstack (todos los puertos de todos los protocolos están abiertos). Una máquina (que tiene asignada una IP flotante) hará de cortafuegos, y la otra será una máquina de la red interna 192.168.100.0/24.</p>

<h2 id="configuración-de-las-rutas-por-defecto">Configuración de las rutas por defecto</h2>

<h3 id="lan">LAN</h3>

<p>Configuramos la ruta por defecto de la LAN. Su fin es que la ruta por defecto de la LAN sea la del cortafuegos. Para ello, nos conectamos a la máquina <code class="language-plaintext highlighter-rouge">lan</code>:</p>

<p><img src="/assets/images/iptables/ej2/1.png" alt="1"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ip route del default
<span class="nb">sudo </span>ip route add default via 192.168.100.2
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/2.png" alt="2"></p>

<h3 id="creamos-las-tablas-filter-y-nat">Creamos las tablas filter y nat</h3>

<p>En NFTables las reglas se agrupan en tablas. Estas tablas contienen las cadenas, que a su vez, contienen las reglas. Las tablas se pueden crear con el comando <code class="language-plaintext highlighter-rouge">nft add table</code>. Las cadenas se pueden crear con el comando <code class="language-plaintext highlighter-rouge">nft add chain</code>. Las reglas se pueden crear con el comando <code class="language-plaintext highlighter-rouge">nft add rule</code>.</p>

<p>En nuestro caso, vamos a crear las tablas <code class="language-plaintext highlighter-rouge">filter</code> y <code class="language-plaintext highlighter-rouge">nat</code>, y de esta manera, quedarían las reglas ordenadas según el esquema de red que hemos definido:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add table inet filter
<span class="nb">sudo </span>nft add table inet nat
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/3.png" alt="3"></p>

<h3 id="creamos-las-cadenas-de-la-tabla-filter">Creamos las cadenas de la tabla filter</h3>

<p>Las primeras cadenas que vamos a crear son las de la tabla <code class="language-plaintext highlighter-rouge">filter</code>. Estas cadenas son las que se encargan de filtrar el tráfico de entrada, salida y de redirección. En este caso, vamos a crear las cadenas <code class="language-plaintext highlighter-rouge">input</code>, <code class="language-plaintext highlighter-rouge">output</code> y <code class="language-plaintext highlighter-rouge">forward</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add chain inet filter input <span class="o">{</span> <span class="nb">type </span>filter hook input priority 0 <span class="se">\;</span> counter <span class="se">\;</span> policy accept <span class="se">\;</span> <span class="o">}</span>
<span class="nb">sudo </span>nft add chain inet filter output <span class="o">{</span> <span class="nb">type </span>filter hook output priority 0 <span class="se">\;</span> counter <span class="se">\;</span> policy accept <span class="se">\;</span> <span class="o">}</span>
<span class="nb">sudo </span>nft add chain inet filter forward <span class="o">{</span> <span class="nb">type </span>filter hook forward priority 0 <span class="se">\;</span> counter <span class="se">\;</span> policy accept <span class="se">\;</span> <span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/4.png" alt="4"></p>

<h3 id="creamos-las-cadenas-de-la-tabla-nat">Creamos las cadenas de la tabla nat</h3>

<p>Las cadenas que vamos a crear son las de la tabla <code class="language-plaintext highlighter-rouge">nat</code>. Estas cadenas son las que se encargan de hacer el SNAT y el DNAT. En este caso, vamos a crear las cadenas <code class="language-plaintext highlighter-rouge">prerouting</code> y <code class="language-plaintext highlighter-rouge">postrouting</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add chain inet nat prerouting <span class="o">{</span> <span class="nb">type </span>nat hook prerouting priority 0 <span class="se">\;</span> <span class="o">}</span>
<span class="nb">sudo </span>nft add chain inet nat postrouting <span class="o">{</span> <span class="nb">type </span>nat hook postrouting priority 100 <span class="se">\;</span> <span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/5.png" alt="5"></p>

<h3 id="tráfico-ssh-de-entrada-al-cortafuegos">Tráfico ssh de entrada al cortafuegos</h3>

<p>Para permitir el tráfico ssh de entrada al cortafuegos, es necesario crear las reglas que nos permitan dicha conexión, a través de las cadenas <code class="language-plaintext highlighter-rouge">input</code> y <code class="language-plaintext highlighter-rouge">output</code> por el puerto 22 de las redes del instituto. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter input ip saddr 172.22.0.0/16 tcp dport 22 ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter output ip daddr 172.22.0.0/16 tcp sport 22 ct state established counter accept
<span class="nb">sudo </span>nft add rule inet filter input ip saddr 172.29.0.0/16 tcp dport 22 ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter output ip daddr 172.29.0.0/16 tcp sport 22 ct state established counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/6.png" alt="6"></p>

<h3 id="política-por-defecto-de-la-tabla-filter">Política por defecto de la tabla filter</h3>

<p>La política por defecto de la tabla <code class="language-plaintext highlighter-rouge">filter</code> es <code class="language-plaintext highlighter-rouge">accept</code>. Las vamos a cambiar a <code class="language-plaintext highlighter-rouge">drop</code> debido a que no queremos que se permita ningún tráfico que no esté especificado en las reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft chain inet filter input <span class="o">{</span> policy drop <span class="se">\;</span> <span class="o">}</span>
<span class="nb">sudo </span>nft chain inet filter output <span class="o">{</span> policy drop <span class="se">\;</span> <span class="o">}</span>
<span class="nb">sudo </span>nft chain inet filter forward <span class="o">{</span> policy drop <span class="se">\;</span> <span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/7.png" alt="7"></p>

<p>Si probamos hacer ping al localhost, veremos que no funciona:</p>

<p><img src="/assets/images/iptables/ej2/8.png" alt="8"></p>

<p>Y que tampoco tenemos acceso a internet:</p>

<p><img src="/assets/images/iptables/ej2/9.png" alt="9"></p>

<h3 id="activamos-el-bit-de-forward">Activamos el bit de forward</h3>

<p>Para que el cortafuegos pueda hacer el forward de paquetes, es necesario activar el bit de forward. Para ello, vamos a activar el bit de forward con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>1 | <span class="nb">sudo tee</span> /proc/sys/net/ipv4/ip_forward
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/10.png" alt="10"></p>

<h3 id="snat">SNAT</h3>

<p>Crearemos la regla SNAT con la que el cortafuegos va a hacer el SNAT de los paquetes que salgan por la interfaz <code class="language-plaintext highlighter-rouge">ens3</code> hacia la LAN. Para ello, vamos a crear la siguiente regla:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet nat postrouting oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 counter masquerade
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/11.png" alt="11"></p>

<h3 id="tráfico-ssh-de-salida-al-cortafuegos-hacia-la-lan">Tráfico ssh de salida al cortafuegos hacia la LAN</h3>

<p>El tráfico ssh de salida al cortafuegos hacia la LAN, es necesario crear las reglas que nos permitan dicha conexión, a través de las cadenas <code class="language-plaintext highlighter-rouge">input</code> y <code class="language-plaintext highlighter-rouge">output</code> por el puerto 22 de la LAN. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"ens4"</span> ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/12.png" alt="12"></p>

<p>Una vez configurado, vamos a probar que podemos conectarnos desde la máquina <code class="language-plaintext highlighter-rouge">router-fw</code> a la máquina <code class="language-plaintext highlighter-rouge">lan</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh debian@192.168.100.10
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/13.png" alt="13"></p>

<h3 id="tráfico-loopback">Tráfico loopback</h3>

<p>El tráfico loopback es aquel que se genera dentro de la misma máquina. Para permitir el tráfico loopback, es necesario crear las reglas que nos permitan dicha conexión, a través de las cadenas <code class="language-plaintext highlighter-rouge">input</code> y <code class="language-plaintext highlighter-rouge">output</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"lo"</span> counter accept
<span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"lo"</span> counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/14.png" alt="14"></p>

<p>Y ahora, si hacemos ping al localhost, veremos que funciona:</p>

<p><img src="/assets/images/iptables/ej2/15.png" alt="15"></p>

<h2 id="tráfico-icmp">Tráfico ICMP</h2>

<h3 id="permitimos-el-tráfico-icmp-de-entrada">Permitimos el tráfico ICMP de entrada</h3>

<p>Vamos a configurar también el permiso de tráfico ICMP de entrada. Este tráfico ICMP es el que se genera cuando hacemos ping a una máquina o cuando hacemos traceroute. Para permitir el tráfico ICMP de entrada, es necesario crear las reglas que nos permitan dicha conexión, a través de las cadenas <code class="language-plaintext highlighter-rouge">input</code> y <code class="language-plaintext highlighter-rouge">output</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"ens3"</span> icmp <span class="nb">type </span>echo-request counter accept
<span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"ens3"</span> icmp <span class="nb">type </span>echo-reply counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/16.png" alt="16"></p>

<p>Vamos a probar que funciona el ping desde nuestra propia máquina:</p>

<p><img src="/assets/images/iptables/ej2/17.png" alt="17"></p>

<h3 id="permitimos-el-tráfico-icmp-de-salida-hacia-la-lan">Permitimos el tráfico ICMP de salida hacia la LAN</h3>

<p>Ahora le toca el turno al tráfico ICMP de salida hacia la LAN. Para permitir el tráfico ICMP de salida hacia la LAN, es necesario crear las reglas que nos permitan dicha conexión, a través de las cadenas <code class="language-plaintext highlighter-rouge">input</code> y <code class="language-plaintext highlighter-rouge">output</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"ens4"</span> icmp <span class="nb">type </span>echo-request counter accept
<span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"ens4"</span> icmp <span class="nb">type </span>echo-reply counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/18.png" alt="18"></p>

<p>Para probar que funciona, vamos a realizar un ping desde la máquina <code class="language-plaintext highlighter-rouge">router-fw</code> a la máquina <code class="language-plaintext highlighter-rouge">lan</code>:</p>

<p><img src="/assets/images/iptables/ej2/19.png" alt="19"></p>

<h3 id="forward-tráfico-icmp-de-salida-desde-lan-hacia-internet">FORWARD: tráfico ICMP de salida desde LAN hacia internet</h3>

<p>Ahora vamos a permitir el tráfico ICMP de salida desde la LAN hacia internet. Para permitir el tráfico ICMP de salida desde la LAN hacia internet, es necesario crear las reglas que nos permitan dicha conexión, a través de la cadena <code class="language-plaintext highlighter-rouge">forward</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 icmp <span class="nb">type </span>echo-request counter accept
<span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 icmp <span class="nb">type </span>echo-reply counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/20.png" alt="20"></p>

<p>Para probar que funciona, vamos a realizar un ping desde la máquina <code class="language-plaintext highlighter-rouge">lan</code> hacia el exterior:</p>

<p><img src="/assets/images/iptables/ej2/21.png" alt="21"></p>

<h3 id="forward-tráfico-dns-saliente-desde-lan">FORWARD: tráfico DNS saliente desde LAN</h3>

<p>Vamos a permitir el tráfico DNS saliente desde la LAN. Para permitir el tráfico DNS saliente desde la LAN, es necesario crear las reglas que nos permitan dicha conexión, a través de la cadena <code class="language-plaintext highlighter-rouge">forward</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 udp dport 53 ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 udp sport 53 ct state established counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/22.png" alt="22"></p>

<p>Probamos que funciona realizando una consulta DNS desde la máquina:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dig @1.1.1.1 www.example.org
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/23.png" alt="23"></p>

<h3 id="forward-tráfico-httphttps-saliente-desde-lan">FORWARD: tráfico HTTP/HTTPS saliente desde LAN</h3>

<p>Ahora vamos a permitir el tráfico HTTP/HTTPS saliente desde la LAN. Para permitir el tráfico HTTP/HTTPS saliente desde la LAN, es necesario crear las reglas que nos permitan dicha conexión, a través de la cadena <code class="language-plaintext highlighter-rouge">forward</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip protocol tcp ip saddr 192.168.100.0/24 tcp dport <span class="o">{</span> 80,443 <span class="o">}</span> ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip protocol tcp ip daddr 192.168.100.0/24 tcp sport <span class="o">{</span> 80,443 <span class="o">}</span> ct state established counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/24.png" alt="24"></p>

<p>Primero, vamos a comprobar que funciona http:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl portquiz.net:80
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/25.png" alt="25"></p>

<p>Y ahora le toca el turno a https:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl portquiz.net:443
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/26.png" alt="26"></p>

<h3 id="forward-tráfico-http-entrante-hacia-lan">FORWARD: tráfico HTTP entrante hacia LAN</h3>

<p>Le toca el turno al tráfico HTTP entrante hacia la LAN. Para permitir el tráfico HTTP entrante hacia la LAN, es necesario crear las reglas que nos permitan dicha conexión, a través de la cadena <code class="language-plaintext highlighter-rouge">forward</code>. Para ello, vamos a crear las siguientes reglas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 tcp dport 80 ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 tcp sport 80 ct state established counter accept
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/27.png" alt="27"></p>

<h3 id="aplicamos-una-regla-dnat">Aplicamos una regla DNAT</h3>

<p>Ahora vamos a aplicar una regla DNAT para que cuando se acceda al puerto 80 de la máquina <code class="language-plaintext highlighter-rouge">router-fw</code>, se redirija al puerto 80 de la máquina <code class="language-plaintext highlighter-rouge">lan</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet nat prerouting iifname <span class="s2">"ens3"</span> tcp dport 80 counter dnat ip to 192.168.100.10
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/28.png" alt="28"></p>

<p>Y ahora, desde nuestra máquina, vamos aprobar que funciona:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>telnet 172.22.200.80 80
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/29.png" alt="29"></p>

<p>Y desde nuestro navegador, podemos ver que podemos acceder al servidor web de la máquina <code class="language-plaintext highlighter-rouge">lan</code>:</p>

<p><img src="/assets/images/iptables/ej2/30.png" alt="30"></p>

<h3 id="hacer-persistente-las-reglas">Hacer persistente las reglas</h3>

<p>Con todo lo anterior, ya tenemos las reglas necesarias para que la máquina <code class="language-plaintext highlighter-rouge">router-fw</code> funcione como cortafuegos. Ahora vamos a hacer persistente las reglas, para que se mantengan tras reiniciar la máquina. Para ello, vamos a guardar las reglas en un fichero de configuración y vamos a configurar el servicio <code class="language-plaintext highlighter-rouge">nftables</code> para que se inicie al arrancar el sistema:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nft list ruleset <span class="o">&gt;</span> /etc/nftables.conf
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>nftables
<span class="nb">sudo </span>systemctl start nftables
</code></pre></div></div>

<p><img src="/assets/images/iptables/ej2/31.png" alt="31"></p>

<h2 id="reglas-necesarias-para-las-siguientes-operaciones">Reglas necesarias para las siguientes operaciones</h2>

<ol>
  <li>
    <p>Permitir poder hacer conexiones ssh al exterior desde la máquina cortafuegos.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"ens3"</span> tcp dport 22 ct state new,established counter accept
 <span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"ens3"</span> tcp sport 22 ct state established counter accept
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/32.png" alt="32"></p>

    <p>Y comrpobamos que funciona conectándonos a nuestro host:</p>

    <p><img src="/assets/images/iptables/ej2/33.png" alt="33"></p>
  </li>
  <li>
    <p>Permitir hacer consultas DNS desde la máquina cortafuegos sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter output ip daddr 192.168.202.2 udp dport 53 ct state new,established counter accept
 <span class="nb">sudo </span>nft add rule inet filter input ip saddr 192.168.202.2 udp sport 53 ct state established counter accept
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/34.png" alt="34"></p>

    <p>Y probamos que las consultas DNS al servidor 192.168.202.2 funcionan, pero no a otros servidores:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> dig @192.168.202.2 www.example.org
 dig @1.1.1.1 www.example.org
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/35.png" alt="35"></p>

    <p><img src="/assets/images/iptables/ej2/36.png" alt="36"></p>
  </li>
  <li>
    <p>Permitir que la máquina cortafuegos pueda navegar por internet.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"ens3"</span> ip protocol tcp tcp dport <span class="o">{</span> 80,443 <span class="o">}</span> ct state new,established counter accept
 <span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"ens3"</span> ip protocol tcp tcp sport <span class="o">{</span> 80,443 <span class="o">}</span> ct state established counter accept
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/37.png" alt="37"></p>

    <p>Y comprobamos que funciona tanto http como https:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> curl portquiz.net:80
 curl portquiz.net:443
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/38.png" alt="38"></p>

    <p><img src="/assets/images/iptables/ej2/39.png" alt="39"></p>
  </li>
  <li>
    <p>Los equipos de la red local deben poder tener conexión al exterior.</p>

    <p>Realizado con anterioridad durante la configuracion de SNAT y las reglas de forward para el tráfico ICMP saliente, que son las siguientes:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet nat postrouting oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 counter masquerade
 <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 icmp <span class="nb">type </span>echo-request counter accept
 <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 icmp <span class="nb">type </span>echo-reply counter accept
</code></pre></div>    </div>

    <p>Probamos que funciona haciendo pong a google:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> ping 8.8.8.8
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/40.png" alt="40"></p>
  </li>
  <li>
    <p>Permitimos el ssh desde el cortafuego a la LAN</p>

    <p>Realizado durante la preparación del escenario. Las reglas son las siguientes:
 ```bash    sudo nft add rule inet filter output oifname “ens4” ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
 sudo nft add rule inet filter input iifname “ens4” ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept</p>
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>
 Lo comprobamos conectándonos a nuestro host:

 ```bash
 ssh maria@172.29.0.62
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/41.png" alt="41"></p>
  </li>
  <li>
    <p>Permitimos hacer ping desde la LAN a la máquina cortafuegos.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter input iifname <span class="s2">"ens4"</span> icmp <span class="nb">type </span>echo-request counter accept
 <span class="nb">sudo </span>nft add rule inet filter output oifname <span class="s2">"ens4"</span> icmp <span class="nb">type </span>echo-reply counter accept
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/42.png" alt="42"></p>

    <p>Y comprobamos que funciona haciendo ping a la máquina <code class="language-plaintext highlighter-rouge">router-fw</code>:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> ping 192.168.100.2
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/43.png" alt="43"></p>
  </li>
  <li>
    <p>Permite realizar conexiones ssh desde los equipos de la LAN</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
 <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/44.png" alt="44"></p>

    <p>Probamos que funciona conectándonos a nuestra máquina host:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> ssh maria@172.29.0.62
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/45.png" alt="45"></p>
  </li>
  <li>
    <p>Instala un servidor de correos en la máquina de la LAN. Permite el acceso desde el exterior y desde el cortafuego al servidor de correos. Para probarlo puedes ejecutar un telnet al puerto 25 tcp.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 tcp dport 25 counter accept
 <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 tcp sport 25 counter accept
 <span class="nb">sudo </span>nft add rule inet nat prerouting iifname <span class="s2">"ens3"</span> tcp dport 25 counter dnat ip to 192.168.100.10
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/46.png" alt="46"></p>

    <p>Probamos que funciona correctamente desde mi máquina host:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> telnet 172.22.200.224 25
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/47.png" alt="47"></p>

    <p>Permitiremos el acceso desde el cortafuegos al servidor de correos.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter output ip daddr 192.168.100.10 tcp dport 25 counter accept
 <span class="nb">sudo </span>nft add rule inet filter input ip saddr 192.168.100.10 tcp sport 25 counter accept
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/48.png" alt="48"></p>

    <p>Y comprobamos que funciona correctamente:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> telnet 192.168.100.10 25
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/49.png" alt="49"></p>
  </li>
  <li>
    <p>Permite poder hacer conexiones ssh desde exterior a la LAN</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip daddr 192.168.100.0/24 tcp dport 22 ct state new,established counter accept
 <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 tcp sport 22 ct state established counter accept
 <span class="nb">sudo </span>nft add rule inet nat prerouting iifname <span class="s2">"ens3"</span> tcp dport 22 counter dnat ip to 192.168.100.10
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/50.png" alt="50"></p>

    <p>Y comprobamos que funciona correctamente conectándonos a la máquina LAN:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> ssh debian@172.22.200.224
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/51.png" alt="51"></p>
  </li>
  <li>
    <p>Modifica la regla anterior, para que al acceder desde el exterior por ssh tengamos que conectar al puerto 2222, aunque el servidor ssh este configurado para acceder por el puerto 22.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet nat prerouting iifname <span class="s2">"ens3"</span> tcp dport 2222 counter dnat ip to 192.168.100.10:22
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/52.png" alt="52"></p>

    <p>Y comprobamos que funciona correctamente:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-p</span> 2222 debian@172.22.200.224
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/53.png" alt="53"></p>
  </li>
  <li>
    <p>Permite hacer consultas DNS desde la LAN sólo al servidor 192.168.202.2. Comprueba que no puedes hacer un dig @1.1.1.1.</p>

    <ul>
      <li>
        <p>Primero vamos a consultar que handle tiene la regla que nos permite realizar las cosultas DNS a cualquier servidor:</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">sudo </span>nft list <span class="nt">-a</span> ruleset | <span class="nb">grep </span>53
</code></pre></div>        </div>
      </li>
    </ul>

    <p><img src="/assets/images/iptables/ej2/54.png" alt="54"></p>

    <ul>
      <li>
        <p>Eliminamos las reglas que nos permiten realizar las consultas DNS a cualquier servidor:</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">sudo </span>nft delete rule inet filter forward handle 42
  <span class="nb">sudo </span>nft delete rule inet filter forward handle 43
</code></pre></div>        </div>

        <p><img src="/assets/images/iptables/ej2/55.png" alt="55"></p>
      </li>
      <li>
        <p>Añadimos las reglas que nos permiten realizar las consultas DNS sólo al servidor 192.168.202.2:</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip saddr 192.168.100.0/24 ip daddr 192.168.202.2 udp dport 53 ct state new,established counter accept
  <span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip saddr 192.168.202.2 ip daddr 192.168.100.0/24 udp sport 53 ct state established counter accept
</code></pre></div>        </div>

        <p><img src="/assets/images/iptables/ej2/56.png" alt="56"></p>
      </li>
      <li>
        <p>Probamos las consultas DNS desde la máquina LAN:</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  dig @192.168.202.2 www.example.org
</code></pre></div>        </div>

        <p><img src="/assets/images/iptables/ej2/57.png" alt="57"></p>

        <p>Si ahora probamos a realizar una consulta DNS a otro servidor, veremos que no funciona:</p>

        <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  dig @1.1.1.1 www.example.org
</code></pre></div>        </div>

        <p><img src="/assets/images/iptables/ej2/58.png" alt="58"></p>

        <p>Recordemos, que anteriormente teniamos las reglas que nos permitían realizar las consultas DNS a cualquier servidor.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Permite que los equipos de la LAN puedan navegar por internet.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens4"</span> oifname <span class="s2">"ens3"</span> ip protocol tcp ip saddr 192.168.100.0/24 tcp dport <span class="o">{</span> 80,443 <span class="o">}</span> ct state new,established counter accept
<span class="nb">sudo </span>nft add rule inet filter forward iifname <span class="s2">"ens3"</span> oifname <span class="s2">"ens4"</span> ip protocol tcp
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/59.png" alt="59"></p>

    <p>Comprobamos que funciona correctamente:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>curl <span class="nt">-I</span> www.example.org
</code></pre></div>    </div>

    <p><img src="/assets/images/iptables/ej2/60.png" alt="60"></p>
  </li>
</ol>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/seguridad/2023/02/01/cortafuegos-1.html" title="Cortafuegos I: De nodo con iptables">Cortafuegos I: De nodo con iptables...</a><a class="next" href="/hlc+sri/2023/02/03/kubernetes-pods.html" title="Taller Kubernetes: Trabajando con Pods">Taller Kubernetes: Trabajando con Pods</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/iaw/2023/01/27/docker-imagen.html" title="Taller Kubernetes: Trabajando con Pods">Taller Docker - Creación de imágenes Docker</a></li>
<li><a class="post-link" href="/iaw/2023/02/09/docker-bookmedik.html" title="Taller Kubernetes: Trabajando con Pods">Implantación de aplicaciones web PHP en docker</a></li>
<li><a class="post-link" href="/iaw/2023/02/19/jenkins1.html" title="Taller Kubernetes: Trabajando con Pods">Taller: Corrector ortográfico de documentos markdown (test)</a></li>
<li><a class="post-link" href="/iaw/2022/12/17/wsgi.html" title="Taller Kubernetes: Trabajando con Pods">Desplegando aplicaciones flask con apache2 + mod_wsgi </a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">MENÚ 📝</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
