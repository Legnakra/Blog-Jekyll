<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Copias de Seguridad y Restauración | sysmaria</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="Copias de Seguridad y Restauración">
<meta property="og:locale" content="en_US">
<meta name="description" content="Introducción">
<meta property="og:description" content="Introducción">
<link rel="canonical" href="/asgdb/2023/02/07/copia-seguridad.html">
<meta property="og:url" content="/asgdb/2023/02/07/copia-seguridad.html">
<meta property="og:site_name" content="sysmaria">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-07T16:45:16+01:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Copias de Seguridad y Restauración">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-07T16:45:16+01:00","datePublished":"2023-02-07T16:45:16+01:00","description":"Introducción","headline":"Copias de Seguridad y Restauración","mainEntityOfPage":{"@type":"WebPage","@id":"/asgdb/2023/02/07/copia-seguridad.html"},"url":"/asgdb/2023/02/07/copia-seguridad.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="sysmaria">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="sysmaria" src="" onerror="this.style.display='none'">
  sysmaria
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/categories.html">CATEGORIAS</a>




</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/assets/images/banners/pack.png)"></div>
        <img class="img-placeholder" src="/assets/images/banners/pack.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Copias de Seguridad y Restauración</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2023-02-07T16:45:16+01:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 7, 2023
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 35 mins</span>
  </p></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="introducción">Introducción</h2>

<p>En este post vamos a ver como hacer copias de seguridad y restauraciones de bases de datos, tanto en Orable, Postgres, MySQL y MongoDB.</p>

<p>Cuando hablamos de copias de seguridad, nos referimos a la copia de los datos de una base de datos, para poder restaurarlos en caso de que se produzca algún fallo en la base de datos, es decir, una recuperación de los datos ante cualquier situación de desastres.</p>

<p>Las copias de seguridad las podemos realizar de dos formas:</p>

<ul>
  <li>
    <p>En frio: Se realiza cuando la base de datos está apagada, y se realiza una copia de los ficheros de datos y de control de la base de datos. El inconveniente de este tipo de copias de seguridad, es que no se puede hacer uso del servicio mientras se realiza la copia de seguridad.</p>
  </li>
  <li>
    <p>En caliente: Se realiza cuando la base de datos está en funcionamiento, y se realiza una copia de los ficheros de datos y de control de la base de datos.</p>
  </li>
</ul>

<h2 id="ejercicios-prácticos">Ejercicios prácticos</h2>

<p><img src="/assets/images/interconexion/oracle.png" alt="oracle"></p>

<h3 id="ejercicio-1">Ejercicio 1</h3>

<p><strong>Realiza una copia de seguridad lógica de tu base de datos completa, teniendo en cuenta los siguientes requisitos:</strong></p>
<ul>
  <li>La copia debe estar encriptada y comprimida.</li>
  <li>Debe realizarse en un conjunto de ficheros con un tamaño máximo de 60 MB.</li>
  <li>Programa la operación para que se repita cada día a una hora determinada.</li>
</ul>

<p>Para realizar la copia de seguridad lógica, vamos a utilizar la herramienta RMAN, que es la herramienta de copia de seguridad y restauración de Oracle.</p>

<p>Para ello, primero vamos a crear un directorio para almacenar los backups, y vamos a darle permisos al usuario oracle para que pueda escribir en el directorio.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /opt/oracle/backup
<span class="nb">chown </span>oracle:oinstall /opt/oracle/backup
</code></pre></div></div>

<p><img src="/assets/images/interconexion/1-1.png" alt="1-1"></p>

<p>Nos conectamos a la base de datos y creamos un directorio en el que se almacenarán los archivos de exportación, al que le asignaremos los permisos necesarios para que el usuario scott pueda acceder a él.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">DIRECTORY</span> <span class="n">EXPORT_DIR</span> <span class="k">AS</span> <span class="s1">'/opt/oracle/backup'</span><span class="p">;</span>
<span class="k">GRANT</span> <span class="k">READ</span><span class="p">,</span> <span class="k">WRITE</span> <span class="k">ON</span> <span class="n">DIRECTORY</span> <span class="n">EXPORT_DIR</span> <span class="k">TO</span> <span class="n">scott</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/interconexion/1-2.png" alt="1-2"></p>

<p>Le adjudicamos también permisos para que pueda exportar los datos.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="n">DATAPUMP_EXP_FULL_DATABASE</span> <span class="k">TO</span> <span class="n">scott</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/interconexion/1-3.png" alt="1-3"></p>

<p>Ahora vamos a crear un script que realice la copia de seguridad lógica de la base de datos.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expdp scott/tiger <span class="nv">DIRECTORY</span><span class="o">=</span>EXPORT_DIR <span class="nv">SCHEMAS</span><span class="o">=</span>scott <span class="nv">DUMPFILE</span><span class="o">=</span>backup<span class="sb">`</span><span class="nb">date</span> +%Y%m%d<span class="sb">`</span>.dmp <span class="nv">LOGFILE</span><span class="o">=</span>backup<span class="sb">`</span><span class="nb">date</span> +%Y%m%d<span class="sb">`</span>.log
</code></pre></div></div>

<p><img src="/assets/images/interconexion/1-4.png" alt="1-4"></p>

<h3 id="ejercicio-2">Ejercicio 2</h3>

<p><strong>Restaura la copia de seguridad lógica creada en el punto anterior.</strong></p>

<h3 id="ejercicio-3">Ejercicio 3</h3>

<p><strong>Pon tu base de datos en modo ArchiveLog y realiza con RMAN una copia de seguridad física en caliente.</strong></p>

<h3 id="ejercicio-4">Ejercicio 4</h3>

<p><strong>Borra un fichero de datos de un tablespace e intenta recuperar la instancia de la base de datos a partir de la copia de seguridad creada en el punto anterior.</strong></p>

<h3 id="ejercicio-5">Ejercicio 5</h3>

<p><strong>Borra un fichero de control e intenta recuperar la base de datos a partir de la copia de seguridad creada en el punto anterior.</strong></p>

<p><img src="/assets/images/interconexion/postgresql.png" alt="postgres"></p>

<h3 id="ejercicio-6">Ejercicio 6</h3>

<p><strong>Documenta el empleo de las herramientas de copia de seguridad y restauración de Postgres.</strong></p>

<p>En Postgres, podemos realizar dos tipos de backups:</p>

<p>El primero del que vamos a hablar es el <strong>bakcup lógico</strong>. Estos utilizan el procedimiento <strong>SQL Dump</strong>, Que consiste en recorrer de forma ordenada los objetos de ka base de datos y realizar el volcado de las sentencias SQL necesarias para su recreación. Un factor a favor de este tipo de backups es que se restaurar sobre cualquier instancia, es decir, no es necesario que el sistema operativo sea el mismo, ni la arquitectura o la versión de PostgresSQL.</p>

<p>Los ficheros son legibles, por lo que se pueden editar y modificar, cosa que puede ser una ventaja o una desventaja, dependiendo de lo que se quiera hacer. Tampoco será necesario parar la instancia, dado que el servicio no se verá interrumpido.</p>

<p>Hemos hablado de las ventajas, pero no siempre todo es así. La principal de ellas es que no se permite la recuperación de la misma hasta un punto determinado en el tiempo, sino que se realiza hasta el último punto de backup. Esto puede ser un problema, ya que si se ha realizado un backup cada hora, y se ha producido un fallo en la base de datos, se perderán las últimas 23 horas de trabajo.</p>

<p>Para realizar backups lógicos, podemos utilizar dos herramientas:</p>

<ul>
  <li>
    <p><em>pg_dumpall</em>: Esta herramienta nos permite hacer backups de un cluster completo, es decir, de todas las bases de datos que se encuentren en el cluster. Por lo que este tipo no es un backup de una base de datos en concreto, sino de todas las que se encuentren en el cluster. La recuperación tampoco sería selectiva, sino que se restauraría todo el cluster. Y como el fichero es un script SQL, podemos utilizar la consola de comandos de Postgres para ejecutarlo.</p>

    <p>Es una utilidad para escribir (“volcar”) todas las bases de datos PostgreSQL de un clúster en un archivo de script. El archivo de script contiene comandos SQL que se pueden usar como entrada para psql para restaurar las bases de datos. Lo hace llamando a pg_dump para cada base de datos en el clúster. pg_dumpall también vuelca objetos globales que son comunes a todas las bases de datos, a saber, roles de base de datos, espacios de tablas y concesiones de privilegios para parámetros de configuración. (pg_dump no guarda estos objetos).</p>

    <p>Dado que pg_dumpall lee tablas de todas las bases de datos, lo más probable es que tenga que conectarse como superusuario de la base de datos para producir un volcado completo. También necesitará privilegios de superusuario para ejecutar el script guardado para poder agregar roles y crear bases de datos.</p>

    <p>El script SQL se escribirá en la salida estándar. <em>pg_dumpall</em> necesita conectarse varias veces al servidor PostgreSQL (una vez por base de datos). Si utiliza la autenticación de contraseña, le pedirá una contraseña cada vez. Es conveniente tener un archivo ~/.pgpass en tales casos. Si no se especifica ningún nombre de archivo, pg_dumpall escribirá en la salida estándar.</p>

    <p>Algunas de las opciones que podemos utilizar son:</p>

    <table>
      <thead>
        <tr>
          <th>Opción</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>-a, –data-only</td>
          <td>No volcar los esquemas, solo los datos.</td>
        </tr>
        <tr>
          <td>-c, –clean</td>
          <td>Agregar comandos para eliminar objetos antes de crearlos.</td>
        </tr>
        <tr>
          <td>-C, –create</td>
          <td>Agregar comandos para crear la base de datos y los roles de base de datos.</td>
        </tr>
        <tr>
          <td>-d, –dbname=DATABASE</td>
          <td>Nombre de la base de datos a volcar.</td>
        </tr>
        <tr>
          <td>-f, –file=FILENAME</td>
          <td>Escribir el volcado a un archivo en lugar de la salida estándar.</td>
        </tr>
        <tr>
          <td>-h, –host=HOSTNAME</td>
          <td>Nombre del host del servidor de base de datos.</td>
        </tr>
        <tr>
          <td>-n, –schema=SCHEMA</td>
          <td>Esquema a volcar.</td>
        </tr>
        <tr>
          <td>-N, –exclude-schema=SCHEMA</td>
          <td>Esquema a excluir.</td>
        </tr>
        <tr>
          <td>-o, –oids</td>
          <td>Incluir OID de objetos en el volcado.</td>
        </tr>
        <tr>
          <td>-O, –no-owner</td>
          <td>No incluir el comando ALTER OWNER en el volcado.</td>
        </tr>
        <tr>
          <td>-p, –port=PORT</td>
          <td>Número de puerto del servidor de base de datos.</td>
        </tr>
        <tr>
          <td>-s, –schema-only</td>
          <td>No volcar los datos, solo los esquemas.</td>
        </tr>
        <tr>
          <td>-S, –superuser=NAME</td>
          <td>Nombre del superusuario de la base de datos.</td>
        </tr>
        <tr>
          <td>-t, –table=TABLE</td>
          <td>Tabla a volcar.</td>
        </tr>
        <tr>
          <td>-T, –exclude-table=TABLE</td>
          <td>Tabla a excluir.</td>
        </tr>
        <tr>
          <td>-U, –username=NAME</td>
          <td>Nombre de usuario para la conexión.</td>
        </tr>
        <tr>
          <td>-v, –verbose</td>
          <td>Mostrar información de progreso.</td>
        </tr>
        <tr>
          <td>-x, –no-privileges</td>
          <td>No incluir los comandos GRANT/REVOKE en el volcado.</td>
        </tr>
        <tr>
          <td>-Z, –compress=0-9</td>
          <td>Comprimir el volcado con gzip.</td>
        </tr>
        <tr>
          <td>-?, –help</td>
          <td>Mostrar ayuda para esta opción.</td>
        </tr>
        <tr>
          <td>–version</td>
          <td>Mostrar información de versión.</td>
        </tr>
      </tbody>
    </table>

    <p>Para volcar todas las bases de datos:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  pg_dumpall <span class="o">&gt;</span> backup.sql
</code></pre></div>    </div>
    <p>Para restaurar la(s) base(s) de datos desde este archivo, puede usar:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  psql <span class="nt">-f</span> db.out postgres
</code></pre></div>    </div>

    <p>No es importante a qué base de datos se conecte aquí, ya que el archivo de script creado por pg_dumpall contendrá los comandos apropiados para crear y conectarse a las bases de datos guardadas. Una excepción es que si especificó –clean, debe conectarse inicialmente a la base de datos de postgres; la secuencia de comandos intentará eliminar otras bases de datos inmediatamente, y eso fallará para la base de datos a la que está conectado.</p>
  </li>
  <li>
    <p><em>pg_dump</em>: Esta herramienta extrae una base de datos PostgreSQL en un archivo de script u otro archivo de almacenamiento. Su sintaxis es:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  pg_dump <span class="o">[</span>opciones de conexión][OPCIONES] NOMBRE_BASE_DE_DATOS
</code></pre></div>    </div>

    <p>Es una utilidad para realizar copias de seguridad de una base de datos PostgreSQL. Realiza copias de seguridad coherentes incluso si la base de datos se utiliza al mismo tiempo. pg_dump no bloquea el acceso de otros usuarios a la base de datos (lectores o escritores).</p>

    <p>Los volcados se pueden generar en formato de script o archivo de archivo. Los volcados de secuencias de comandos son archivos de texto sin formato que contienen los comandos SQL necesarios para reconstruir la base de datos al estado en el que se encontraba en el momento en que se guardó. Para restaurar desde un script de este tipo, lo introducimos en psql. Los archivos de script se pueden usar para reconstruir la base de datos incluso en otras máquinas y otras arquitecturas; con algunas modificaciones, incluso en otros productos de bases de datos SQL.</p>

    <p>Los formatos de archivo de almacenamiento alternativos deben usarse con <em>pg_restore</em> para reconstruir la base de datos. Permiten que <em>pg_restore</em> sea selectivo sobre lo que se restaura, o incluso reordenar los elementos antes de restaurarlos. Los formatos de archivo de almacenamiento están diseñados para ser portátiles entre arquitecturas.</p>

    <p>Cuando se usa con uno de los formatos de archivo de almacenamiento y se combina con <em>pg_restore</em>, <em>pg_dump</em> proporciona un mecanismo flexible de archivo y transferencia. <em>pg_dump</em> se puede usar para hacer una copia de seguridad de una base de datos completa, luego pg_restore se puede usar para examinar el archivo y/o seleccionar qué partes de la base de datos se restaurarán. Los formatos de archivo de salida más flexibles son el formato “personalizado” (-Fc) y el formato de “directorio” (-Fd). Permiten la selección y el reordenamiento de todos los elementos archivados, admiten la restauración paralela y están comprimidos de forma predeterminada. El formato de “directorio” es el único formato que admite volcados paralelos.</p>

    <p>Las opciones de conexión son las mismas que para <em>psql</em>. Las opciones de volcado son:</p>

    <table>
      <thead>
        <tr>
          <th>Opción</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>-a, –data-only</td>
          <td>No volcar los esquemas, solo los datos.</td>
        </tr>
        <tr>
          <td>-b, –blobs</td>
          <td>Incluir datos de tipo BLOB en el volcado.</td>
        </tr>
        <tr>
          <td>-B, –no-blobs</td>
          <td>No incluir datos de tipo BLOB en el volcado.</td>
        </tr>
        <tr>
          <td>-c, –clean</td>
          <td>Agregar comandos para eliminar objetos antes de crearlos.</td>
        </tr>
        <tr>
          <td>-C, –create</td>
          <td>Agregar comandos para crear la base de datos y los roles de base de datos.</td>
        </tr>
        <tr>
          <td>-E, –encoding=ENCODING</td>
          <td>Codificación de caracteres para el volcado.</td>
        </tr>
        <tr>
          <td>-f, –file=file</td>
          <td>Escribir el volcado a un archivo en lugar de la salida estándar.</td>
        </tr>
        <tr>
          <td>-F</td>
          <td>Formato de archivo de salida. Los valores válidos son: c (por defecto), t, p, d, o, a, h, custom, directory.</td>
        </tr>
        <tr>
          <td>-j njobs, –jobs=njobs</td>
          <td>Número de volcados paralelos a ejecutar.</td>
        </tr>
        <tr>
          <td>-n, –schema=SCHEMA</td>
          <td>Esquema a volcar.</td>
        </tr>
        <tr>
          <td>-N, –exclude-schema=SCHEMA</td>
          <td>Esquema a excluir.</td>
        </tr>
        <tr>
          <td>-O, –no-owner</td>
          <td>No incluir el comando ALTER OWNER en el volcado.</td>
        </tr>
        <tr>
          <td>-s, –schema-only</td>
          <td>No volcar los datos, solo los esquemas.</td>
        </tr>
        <tr>
          <td>-S, –superuser=NAME</td>
          <td>Nombre del superusuario de la base de datos.</td>
        </tr>
        <tr>
          <td>-t, –table=TABLE</td>
          <td>Tabla a volcar.</td>
        </tr>
        <tr>
          <td>-T, –exclude-table=TABLE</td>
          <td>Tabla a excluir.</td>
        </tr>
        <tr>
          <td>-v, –verbose</td>
          <td>Mostrar información de progreso.</td>
        </tr>
        <tr>
          <td>-x, –no-privileges</td>
          <td>No incluir los comandos GRANT/REVOKE en el volcado.</td>
        </tr>
        <tr>
          <td>-Z, –compress=0-9</td>
          <td>Comprimir el volcado con gzip.</td>
        </tr>
        <tr>
          <td>-?, –help</td>
          <td>Mostrar ayuda para esta opción.</td>
        </tr>
      </tbody>
    </table>

    <p>Para volcar una base de datos llamada mydb en un archivo de script SQL:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump mydb <span class="o">&gt;</span> db.sql
</code></pre></div>    </div>

    <p>Para volver a cargar un script de este tipo en una base de datos (recién creada) llamada newdb:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>psql <span class="nt">-d</span> newdb <span class="nt">-f</span> db.sql
</code></pre></div>    </div>

    <p>Para volcar una base de datos en un archivo de almacenamiento de formato personalizado:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-Fc</span> mydb <span class="o">&gt;</span> db.dump
</code></pre></div>    </div>

    <p>Para volcar una base de datos en un archivo con formato de directorio:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-Fd</span> mydb <span class="nt">-f</span> dumpdir
</code></pre></div>    </div>

    <p>Para volcar una base de datos en un archivo de formato de directorio en paralelo con 5 trabajos de trabajo:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-Fd</span> mydb <span class="nt">-j</span> 5 <span class="nt">-f</span> dumpdir
</code></pre></div>    </div>

    <p>Para recargar un archivo comprimido en una base de datos (recién creada) llamada newdb:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_restore <span class="nt">-d</span> newdb db.dump
</code></pre></div>    </div>

    <p>Para volver a cargar un archivo comprimido en la misma base de datos de la que se descargó, descartando el contenido actual de esa base de datos:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_restore <span class="nt">-d</span> postgres <span class="nt">--clean</span> <span class="nt">--create</span> db.dump
</code></pre></div>    </div>

    <p>Para volcar una sola tabla llamada mytab:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-t</span> mytab mydb <span class="o">&gt;</span> db.sql
</code></pre></div>    </div>

    <p>Para volcar todas las tablas cuyos nombres comienzan con emp en el esquema de Detroit, excepto la tabla llamada employee_log:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-t</span> <span class="s1">'detroit.emp*'</span> <span class="nt">-T</span> detroit.employee_log mydb <span class="o">&gt;</span> db.sql
</code></pre></div>    </div>

    <p>Para volcar todos los esquemas cuyos nombres comiencen con este u oeste y terminen en gsm, excluyendo cualquier esquema cuyos nombres contengan la palabra prueba:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-n</span> <span class="s1">'east*gsm'</span> <span class="nt">-n</span> <span class="s1">'west*gsm'</span> <span class="nt">-N</span> <span class="s1">'*test*'</span> mydb <span class="o">&gt;</span> db.sql
</code></pre></div>    </div>

    <p>Lo mismo, usando la notación de expresiones regulares para consolidar los interruptores:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-n</span> <span class="s1">'(east|west)*gsm'</span> <span class="nt">-N</span> <span class="s1">'*test*'</span> mydb <span class="o">&gt;</span> db.sql
</code></pre></div>    </div>

    <p>Para volcar todos los objetos de la base de datos excepto las tablas cuyos nombres comienzan con ts_:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-T</span> <span class="s1">'ts_*'</span> mydb <span class="o">&gt;</span> db.sql
</code></pre></div>    </div>
    <p>Para especificar un nombre en mayúsculas o en mayúsculas y minúsculas en -t y los modificadores relacionados, debe poner el nombre entre comillas dobles; de lo contrario, se doblará en minúsculas (ver patrones a continuación). Pero las comillas dobles son especiales para el shell, por lo que a su vez deben estar entre comillas. Por lo tanto, para volcar una sola tabla con un nombre de mayúsculas y minúsculas, necesita algo como</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump <span class="nt">-t</span> <span class="s2">"</span><span class="se">\"</span><span class="s2">MixedCaseName</span><span class="se">\"</span><span class="s2">"</span> mydb <span class="o">&gt;</span> mytab.sql
</code></pre></div>    </div>
  </li>
</ul>

<p>El segundo tipo es el <strong>backup físico</strong>. La principal carcterística de este tipo de backup es que consiste en copiar los ficheros que pertenecen al cluster de PostgreSQL. Por lo tanto, si se produce un fallo en el sistema, se puede restaurar el cluster a partir de los ficheros de backup. Este tipo de backup es el más rápido y el más sencillo de realizar. Para realizar un backup físico de un cluster de PostgreSQL, se debe copiar el directorio de datos de PostgreSQL, que por defecto se encuentra en /var/lib/pgsql/data.</p>

<p>Los ficheros, al contrario que en los de backup lógico, no se encuentran en un formato legible por el usuario. Por lo tanto, no será posible restaurar la instancia en otro sistema operativo, arquitectura o versión de PostgreSQL. Dependiendo del método de backup que se utilice, la posibilidad de hacer un backup físico puede variar. También cabe destacar que no permitenn backups ni recuperaciones selectivas.</p>

<p>Existen dos técnicas para realizar un backup físico:</p>

<ul>
  <li>
    <p><em>Filesystem</em>: consiste en copiar el directorio de datos de PostgreSQL. Es la técnica más sencilla y rápida de realizar. Sin embargo, para poder realizar este método, el servicio depe estar detenido. Pero de todas las técnicas que hemos visto, es la única que requiere que el servicio se pare para garantizar la copia consistente de los ficheros físicos.</p>

    <p>Uno de sus inconvenientes es que necesitamos tener constancia de la forma en la que está distribuido el disco, es decir, saber las rutas físicas de los tablespaces. Así que lo primero que debemos hacer es consultar la ruta de los tablespaces con el comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>psql <span class="nt">-c</span> <span class="s2">"SELECT spcname, pg_tablespace_location(oid) FROM pg_tablespace;"</span>
</code></pre></div>    </div>

    <p>Y una vez sabidas las rutas, podríamos realizar el backup. También debemos tener en cuenta es que este método no permite las recuperaciones hasta un punto en el tiempo.</p>

    <p>Podemos emplear dos métdos:</p>

    <ul>
      <li>
        <p><em>scp/cp</em>: copiar el directorio de datos de PostgreSQL a un directorio de backup en otro servidor. Este método es el más sencillo de realizar, pero requiere que el servicio de PostgreSQL esté detenido. No debemos olvidar que, tras realizar la copia, debemos iniciar el servicio de PostgreSQL. Este método estaría totalmente descartado para bases de datos que requieren un alto nivel de disponibilidad o para aquellas que tengan un peso de datos muy elevado.</p>
      </li>
      <li>
        <p><em>rsync</em>: este método mejora el anterior, ya que no requiere que el servicio de PostgreSQL esté detenido. Para realizar el backup, se ejecuta el comando rsync con el parámetro -a, que realiza una copia recursiva y conserva los permisos, propietarios y fechas de los ficheros. Además, se añade el parámetro -z, que comprime los ficheros durante la copia. Por último, se añade el parámetro -v, que muestra el progreso de la copia. El comando quedaría de la siguiente forma:</p>
      </li>
    </ul>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>rsync <span class="nt">-avz</span> /var/lib/pgsql/data/ backupserver:/var/lib/pgsql/backup/
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>Archivado Continuado</em>: esta es la única técnica que permite que se pueda recuperar hasta un punto en el tiempo. Para realizar este tipo de backup, se debe configurar el parámetro archive_mode en on. Este parámetro permite que se creen ficheros de backup cada vez que se realiza un checkpoint. Por defecto, se crean en el directorio pg_xlog, que se encuentra en el directorio de datos de PostgreSQL.</p>

    <p>Para realizar una prueba de las herramientas de copia de seguridad, vamos a realizar la copia con <em>pg_dump</em> de la base de datos <em>SCOTT</em>. Para ello, nos logueamos en la base de datos <em>SCOTT</em> y ejecutamos el siguiente comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">mkdir</span> /etc/postgresql-backups
</code></pre></div>    </div>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>pg_dump scott <span class="o">&gt;</span> /etc/postgresql-backups/scott<span class="sb">`</span><span class="nb">date</span> +<span class="s2">"%Y%m%d_%H%M%S"</span><span class="sb">`</span>.sql
</code></pre></div>    </div>

    <p><img src="/assets/images/asgdb/backup/6-1.png" alt="6-1"></p>

    <p><img src="/assets/images/asgdb/backup/6-2.png" alt="6-2"></p>

    <p>Una vez finalizada la copia, podemos comprobar que se ha creado el fichero <em>scott.sql</em> en el directorio de trabajo. Para restaurar la base de datos, debemos crear una nueva base de datos con el mismo nombre.</p>

    <p><img src="/assets/images/asgdb/backup/6-3.png" alt="6-3"></p>

    <p>Como podemos ver, la base de datos <em>BACKUP</em> no existe. Por lo tanto, la creamos, y verificamos que está completamente vacía:</p>

    <p><img src="/assets/images/asgdb/backup/6-4.png" alt="6-4"></p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>psql <span class="nt">-f</span> /etc/postgresql-backup/scott.sql backup
</code></pre></div>    </div>

    <p><img src="/assets/images/asgdb/backup/6-5.png" alt="6-5"></p>

    <p>Una vez finalizada la restauración, podemos comprobar que la base de datos <em>SCOTT</em> se ha restaurado correctamente.</p>

    <p><img src="/assets/images/asgdb/backup/6-6.png" alt="6-6"></p>

    <p><img src="/assets/images/asgdb/backup/6-7.png" alt="6-7"></p>
  </li>
</ul>

<p><img src="/assets/images/banners/mysql.png" alt="mysql"></p>

<h3 id="ejercicio-7">Ejercicio 7</h3>

<p><strong>Documenta el empleo de las herramientas de copia de seguridad y restauración de MySQL.</strong></p>

<p>Existen varias formas de realizar una copia de seguridad de una base de datos MySQL o MarriaDB,auque el más común y recomendado es el uso de mysqldump. Como podéis ver en la entrada de <a href="https://sysmaria.netlify.app/asgdb/2023/02/07/movimientos.html#h-ejercicio-4">movimientos de datos</a>, hicimos uso de mysqldump para realizar los movimientos de datos entre bases de datos. Puede ser tanto una exportación <strong>parcial</strong> como una <strong>total</strong>.</p>

<p>Gracias a su multitud de parámetros, que lo hacen muy configurable:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Parámetro</th>
      <th style="text-align: left">Descripción</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">–bind-address</td>
      <td style="text-align: left">Dirección IP del servidor MySQL</td>
    </tr>
    <tr>
      <td style="text-align: left">–compress</td>
      <td style="text-align: left">Comprime el fichero de salida</td>
    </tr>
    <tr>
      <td style="text-align: left">–login-path</td>
      <td style="text-align: left">Nombre del fichero de configuración de MySQL</td>
    </tr>
    <tr>
      <td style="text-align: left">–pipe, -W</td>
      <td style="text-align: left">Conexión con el servidor usando el nombre de pipe</td>
    </tr>
    <tr>
      <td style="text-align: left">–port</td>
      <td style="text-align: left">Puerto de conexión con el servidor MySQL</td>
    </tr>
    <tr>
      <td style="text-align: left">–no-create-db</td>
      <td style="text-align: left">No crea la base de datos</td>
    </tr>
    <tr>
      <td style="text-align: left">–no-create-info</td>
      <td style="text-align: left">No crea la información de las tablas</td>
    </tr>
  </tbody>
</table>

<p>En su documentación <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html#option_mysqldump_compress">oficial</a> podemos encontrar más información sobre los parámetros que podemos usar.</p>

<p>Vale pero, ¿qué tipos de backups podemos realizar con mysqldump?:</p>

<ul>
  <li>
    <p><strong>Backup total</strong>: Esta opción es muy oportuna en el caso de tener un servidor con varias bases de datos pero solo queremos realizar la copia de seguridad de una de ellas. Para ello, deberemos hacer la ecportación completa de todos los datos de la base de datos, incluyendo datos, triggers, procedimientos, vistas, estructura… Con el siguiente comando realizaríamos un backup total de la base de datos, siendo el nombre del fichero resultante el nombre de la base de datos y la fecha de la copia de seguridad:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--events</span> <span class="nt">--routines</span> <span class="nt">--triggers</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">-p</span> your_db_name <span class="o">&gt;</span> db_backup_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div>    </div>

    <p><img src="/assets/images/asgdb/backup/esquema.png" alt="esquema"></p>

    <p>Para darle pas seguridad a la copia de seguridad, podemos incluir después del nombre de la base de datos la opción <code class="language-plaintext highlighter-rouge">-c | --compress</code> para comprimir el fichero de salida.</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>mysqldump <span class="nt">--opt</span> <span class="nt">--events</span> <span class="nt">--routines</span> <span class="nt">--triggers</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">--password</span><span class="o">=</span>your_password your_db_name | <span class="nb">gzip</span> <span class="nt">-c</span> <span class="o">&gt;</span> db_backup_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql.gz
</code></pre></div>    </div>

    <p>En caso de que solo querramos exportar la estructura de la base de datos, podemos usar el siguiente comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--no-data</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">-p</span> your_db_name <span class="o">&gt;</span> db_structure_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div>    </div>

    <p>Pero en el caso de que solo querramos el contenido de datos que contienen las tablas,es decir, solo los datos que se han generado con las sentencias <code class="language-plaintext highlighter-rouge">insert</code>, podemos usar el siguiente comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--no-create-info</span> <span class="nt">--skip-triggers</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">-p</span> your_db_name <span class="o">&gt;</span> db_data_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Backup parcial</strong>: Esta opción, como su nombre indica, se realiza si solo nos interesa hacer una copia de un conjunto de tablas y lo podemos hacer de dos maneras: o especificamos una por una las tablas de las que queremos realizar la copia de seguridad, o realizamos una copia completa usando el parámetro <code class="language-plaintext highlighter-rouge">--ignore-table</code> para que, como suguiere el parámetro, se realiza la copia completa ignorando las tablas mencionadas.</p>

    <p>Si lo que queremos es realizar soloun subconjunto de tablas, podríamos emplear el siguiente comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">-p</span> your_db_name table1 table2 table3 <span class="o">&gt;</span> db_tables_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div>    </div>

    <p>Si lo que queremos es realizar una copia de seguridad de todas las tablas excepto de unas cuantas, podríamos emplear el siguiente comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>   <span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">-p</span> <span class="nt">--ignore-table</span><span class="o">=</span>table1 <span class="nt">--ignore-table</span><span class="o">=</span>table2 <span class="nt">--ignore-table</span><span class="o">=</span>table3 your_db_name <span class="o">&gt;</span> db_tables_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div>    </div>

    <p>Este último caso es muy útil cuando las tablas que nos interesan son más de las que no nos interesan.</p>
  </li>
  <li>
    <p><strong>Backup remoto</strong>: Como su nombre indica, lo podemos realizar accediendo al servidor MySQL desde otro servidor. Para ello, deberemos tener instalado el cliente MySQL en el servidor desde el que queremos realizar la copia de seguridad.</p>

    <p>Para realizar la copia de seguridad, deberemos usar el siguiente comando:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">-h</span> mysql.example.com <span class="nt">-P</span> 3306 <span class="nt">--compress</span> <span class="nt">--events</span> <span class="nt">--routines</span> <span class="nt">--triggers</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> your_username <span class="nt">-p</span> your_db_name <span class="o">&gt;</span> db_backup_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql 
</code></pre></div>    </div>

    <p>Otra forma sería conectándonos al servidor a traves de ssh:</p>

    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span>ssh ssh_username@server <span class="s2">"mysqldump -v --opt --events --routines --triggers --default-character-set=utf8 -u your_username --password=your_password your_db_name | gzip -c"</span> <span class="o">&gt;</span> db_backup_your_db_name_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql.gz
</code></pre></div>    </div>
  </li>
</ul>

<p>Para realizar una prueba de restauración, vamos a utilizar la base de datos de scott que tenemos en nuestro servidor MySQL. Para ello, vamos a crear una base de datos de prueba y vamos a importar la base de datos de scott en ella.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysql <span class="nt">-u</span> root <span class="nt">-p</span>
mysql&gt; create database scott_full<span class="p">;</span>
mysql&gt; create database scott_partial<span class="p">;</span>
mysql&gt; create database scott_structure<span class="p">;</span>
mysql&gt; <span class="nb">exit</span>
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/7-1.png" alt="7-1"></p>

<p>Ahora vamos a realizar la copia de seguridad de la base de datos de scott completa.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--events</span> <span class="nt">--routines</span> <span class="nt">--triggers</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> root <span class="nt">-p</span> scott <span class="o">&gt;</span> full_scott_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/7-2.png" alt="7-2"></p>

<p>Ahora vamos a realizar la copia de seguridad de la base de datos de scott, pero solo de las tabla emp:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> root <span class="nt">-p</span> scott emp <span class="o">&gt;</span> emp_backup_scott_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/7-3.png" alt="7-3"></p>

<p>Y ahora vamos a realizar la copia de seguridad de la estructura de la base de datos de scott:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysqldump <span class="nt">-v</span> <span class="nt">--opt</span> <span class="nt">--no-data</span> <span class="nt">--default-character-set</span><span class="o">=</span>utf8 <span class="nt">-u</span> root <span class="nt">-p</span> scott <span class="o">&gt;</span> structure_scott_<span class="sb">`</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="sb">`</span>.sql
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/7-4.png" alt="7-4"></p>

<p>Como podemos ver, los 3 ficheros se han creado correctamente. Ahora, para comprobar que las copias de seguridad se han realizado correctamente, vamos a restaurar las copias de seguridad en su correspondiente base de datos para las pruebas pertinentes.</p>

<p><img src="/assets/images/asgdb/backup/7-5.png" alt="7-5"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Restauramos la copia de seguridad completa</span>
<span class="nv">$ </span>mysql <span class="nt">-u</span> root <span class="nt">-p</span> scott_full &lt; full_scott_20230305_231358.sql

<span class="c"># Restauramos la copia de seguridad de la tabla emp</span>
<span class="nv">$ </span>mysql <span class="nt">-u</span> root <span class="nt">-p</span> scott_partial &lt; emp_backup_scott_20230305_231222.sql

<span class="c"># Restauramos la copia de seguridad de la estructura de la base de datos</span>
<span class="nv">$ </span>mysql <span class="nt">-u</span> root <span class="nt">-p</span> scott_structure &lt; structure_scott_0230305_231343.sql
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/7-6.png" alt="7-6"></p>

<p>Y como podemos ver en la siguiente imagen, se han restaurado correctamente las copias de seguridad.</p>

<ul>
  <li>
    <p>Mostramos que las bases de datos se encuentran creadas.</p>

    <p><img src="/assets/images/asgdb/backup/7-7.png" alt="7-7"></p>
  </li>
  <li>
    <p>Scott_full</p>

    <p><img src="/assets/images/asgdb/backup/7-8.png" alt="7-8"></p>
  </li>
  <li>
    <p>Scott_partial</p>

    <p><img src="/assets/images/asgdb/backup/7-9.png" alt="7-9"></p>
  </li>
  <li>
    <p>Scott_structure</p>

    <p><img src="/assets/images/asgdb/backup/7-10.png" alt="7-10"></p>
  </li>
</ul>

<p><img src="/assets/images/banners/mongo.png" alt="mongo"></p>

<h3 id="ejercicio-8">Ejercicio 8</h3>

<p><strong>Documenta el empleo de las herramientas de copia de seguridad y restauración de MongoDB.</strong></p>

<p>Para realizar copias de seguridad de MongoDB, podemos usar la herramienta <code class="language-plaintext highlighter-rouge">mongodump</code> que nos permite realizar copias de seguridad de la base de datos completa o de una colección en concreto.</p>

<p>EL primer paso es crear un directorio donde se almacenarán las copias de seguridad que realizaremos de las bases de datos. Si estamos gestionando varias bases de datos, deberemos crear un directorio para cada una de ellas, para de esta forma poder diferenciar las copias de seguridad de cada una de ellas.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nt">-p</span> /var/backups/mongodb
</code></pre></div></div>

<p>Lo idóneo será que el nombre del fichero de la copia de seguridad sea el nombre de la base de datos que estamos copiando, junto con la fecha en la que se ha realizado la copia de seguridad.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mongodump <span class="nt">-h</span> ip_base_server <span class="nt">-d</span> your_db_name <span class="nt">-o</span> /var/backups/mongodb/your_db_name_<span class="sb">`</span><span class="nb">date</span> +<span class="s2">"%Y%m%d_%H%M%S"</span><span class="sb">`</span>
</code></pre></div></div>
<p><img src="/assets/images/asgdb/backup/8-1.png" alt="8-1"></p>

<p>Para que la copia de seguridad se realice de forma automática, lo realizaremos mediante un script que se ejecutará cada cierto tiempo, que progararemos en el crontab del sistema. Por ello, lo primero que haremos será crear el script que se encargará de realizar la copia de seguridad y le damos permisos de ejecución.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nano /opt/scripts/mongodb_backup.sh
<span class="nb">sudo chmod</span> +x /opt/scripts/mongodb_backup.sh
</code></pre></div></div>

<p>Si lo que queremos es un scritp que nos permita elegir el directorio de destino de la copia de seguridad, podemos usar el siguiente script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c">#Autori: María Jesús Alloza Rodríguez</span>
<span class="c">#Versión: 1.0</span>
<span class="c">#Descripción: Script para realizar copias de seguridad de MongoDB</span>
<span class="c">#Fecha de creación: 02/03/2023</span>

<span class="nb">echo</span> <span class="s2">"Starting MongoDB Backup"</span>
<span class="nb">echo</span> <span class="s2">"------------------------"</span>

<span class="c">##Función para elegir el directorio de destino de la copia de seguridad</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"Introduce el directorio de destino de la copia de seguridad: "</span> DEST

<span class="c">#Variable </span>
<span class="nv">DESTINO</span><span class="o">=</span><span class="s2">"/var/backups/mongodb/"</span><span class="nv">$DEST</span>

<span class="c">#Comprobación de que el directorio de destino existe</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> <span class="nv">$DESTINO</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"El directorio </span><span class="nv">$DESTINO</span><span class="s2"> existe"</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"El directorio </span><span class="nv">$DESTINO</span><span class="s2"> no existe"</span>
    <span class="nb">echo</span> <span class="s2">"Creando directorio </span><span class="nv">$DESTINO</span><span class="s2">"</span>
    <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$DESTINO</span>
<span class="k">fi</span>

<span class="c">#Elección de la base de datos a copiar</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"Introduce el nombre de la base de datos a copiar: "</span> DB

<span class="c">#Comprobación de que la base de datos existe</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> /var/lib/mongodb/<span class="nv">$DB</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"La base de datos </span><span class="nv">$DB</span><span class="s2"> existe"</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"La base de datos </span><span class="nv">$DB</span><span class="s2"> no existe"</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c">#Realización de la copia de seguridad</span>
<span class="nb">echo</span> <span class="s2">"Realizando copia de seguridad de la base de datos </span><span class="nv">$DB</span><span class="s2">"</span>
mongodump <span class="nt">-h</span> localhost <span class="nt">-d</span> <span class="nv">$DB</span> <span class="nt">-o</span> <span class="nv">$DESTINO</span>/<span class="nv">$DB_</span><span class="sb">`</span><span class="nb">date</span> +<span class="s2">"%Y%m%d_%H%M%S"</span>.json<span class="sb">`</span>

<span class="nb">echo</span> <span class="s2">"Copia de seguridad realizada con éxito"</span>
<span class="nb">echo</span> <span class="s2">"--------------------------------------"</span>
</code></pre></div></div>

<p>Visto este script, vamos a realizar uno, que realice una copia de seguridad de la base de datos asir cada día a las 00:00 horas.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /opt/scripts/asir_backup.sh
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c">#Autora: María Jesús Alloza Rodríguez</span>
<span class="c">#Versión: 1.0</span>
<span class="c">#Descripción: Script para realizar copias de seguridad de la base de datos Asir</span>

<span class="nb">echo</span> <span class="s2">"Starting MongoDB Backup"</span>
<span class="nb">echo</span> <span class="s2">"------------------------"</span>

mongodump <span class="nt">-h</span> localhost <span class="nt">-d</span> asir <span class="nt">-o</span> /var/backups/mongodb/asir_<span class="sb">`</span><span class="nb">date</span> +<span class="s2">"%Y%m%d_%H%M%S"</span><span class="sb">`</span>
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/8-2.png" alt="8-2"></p>

<p>Una vez creado el script, lo programamos en el crontab del sistema para que se ejecute cada día a las 00:00 horas.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>crontab <span class="nt">-e</span>
0 0 <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> /opt/scripts/asir_backup.sh
</code></pre></div></div>

<p>Para restaurar una copia de seguridad de MongoDB, podemos usar la herramienta <code class="language-plaintext highlighter-rouge">mongorestore</code> que nos permite restaurar una base de datos completa o una colección en concreto.</p>

<p>Para restaurar una base de datos completa, lo que haremos será ejecutar el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mongorestore <span class="nt">--db</span> asir_copia <span class="nt">--verbose</span> /var/backups/mongodb/asir_20230305_234235/asir/
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/8-3.png" alt="8-3"></p>

<p>Como podemos observar, la base de datos asir_copia se ha restaurado correctamente.</p>

<p><img src="/assets/images/asgdb/backup/8-4.png" alt="8-4"></p>

<p>Para restaurar una colección en concreto, lo que haremos será ejecutar el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mongorestore <span class="nt">--db</span> asir_collection <span class="nt">--collection</span> Primero /var/backups/mongodb/asir_20230305_234235/asir/Primero.bson 
</code></pre></div></div>

<p><img src="/assets/images/asgdb/backup/8-5.png" alt="8-5"></p>

<p>Como podemos observar, la colección Primero de la base de datos asir_collection se ha restaurado correctamente, pero no se ha restaurado la colección Segundo.</p>

<p><img src="/assets/images/asgdb/backup/8-6.png" alt="8-6"></p>

<p>Como podemos ver en esta imagen final, ambas bases de datos, asir_copia y asir_collection, se han restaurado correctamente.</p>

<p>Pero si lo que queremos es realizar una restauración de una copia de seguridad en concreta de una base de datos concreta (en este caso la base de datos asir), podemos usar el siguiente script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c">#Autora: María Jesús Alloza Rodríguez</span>
<span class="c">#Versión: 1.0</span>
<span class="c">#Descripción: Script para realizar copias de seguridad de la base de datos Asir</span>

<span class="nb">echo</span> <span class="s2">"Las copias de seguridad de la base de datos asir son: "</span>
<span class="nb">echo</span> <span class="s2">"----------------------------------------------------"</span>

<span class="nv">DIRECTORIO</span><span class="o">=</span><span class="s2">"/var/backups/mongodb/asir"</span>

<span class="c">#Listado de las copias de seguridad de la base de datos asir</span>
<span class="nb">ls</span> <span class="nv">$DIRECTORIO</span>

<span class="nb">echo</span> <span class="s2">"----------------------------------------------------"</span>

<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"Introduce el nombre de la copia de seguridad que quieres restaurar: "</span> COPIA

mongoimport <span class="nt">-u</span> admin <span class="nt">--db</span> asir <span class="nt">--file</span> <span class="nv">$DIRECTORIO$COPIA</span>

<span class="nb">echo</span> <span class="s2">"Restauración realizada con éxito"</span>
</code></pre></div></div>

<h2 id="bibliografía">Bibliografía</h2>

<ul>
  <li>
    <p><a href="https://www.ajpdsoft.com/modules.php?name=News&file=print&sid=560#copiaseguridadlogicaoracle">Copias de seguridad en Oracle, copia export, copia física RMAN</a></p>
  </li>
  <li>
    <p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html#option_mysqldump_compress">MySQL DUMP</a></p>
  </li>
  <li>
    <p><a href="https://www.postgresql.org/docs/9.1/app-pgdump.html">Pg_dump</a></p>
  </li>
  <li>
    <p><a href="https://www.postgresql.org/docs/9.1/backup.html">PostgreSQL Backup and Recovery</a></p>
  </li>
  <li>
    <p><a href="https://www.postgresql.org/docs/9.1/app-pgdumpall.html">Pg_dumpall</a></p>
  </li>
  <li>
    <p><a href="https://dbasinapuros.com/tecnicas-y-herramientas-de-backup-y-recovery-en-postgresql/">Copias de seguridad y restauración de PostgreSQL</a></p>
  </li>
  <li>
    <p><a href="https://josejuansanchez.org/bd/unidad-13-teoria/index.html">Gestión de la seguridad de los datos.</a></p>
  </li>
  <li>
    <p><a href="https://www.mongodb.com/docs/manual/tutorial/backup-and-restore-tools/">Backup y Restore de MongoDB</a></p>
  </li>
  <li>
    <p><a href="https://www.digitalocean.com/community/tutorials/how-to-back-up-restore-and-migrate-a-mongodb-database-on-ubuntu-20-04-es">Backup y Restore de MongoDB</a></p>
  </li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/asgdb/2023/02/07/movimientos.html" title="Movimiento de Datos">Movimiento de Datos</a><a class="next" href="/hlc+sri/2023/02/08/kubernetes-parametrizados.html" title="Taller Kubernetes: Despliegues parametrizados">Taller Kubernetes: Despliegues parametrizados</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/iaw/2023/01/09/java-cms.html" title="Taller Kubernetes: Despliegues parametrizados">Despliegue de aplicaciones Java</a></li>
<li><a class="post-link" href="/iaw/2022/11/27/https.html" title="Taller Kubernetes: Despliegues parametrizados">Configuración de HTTPS en nuestro VPS</a></li>
<li><a class="post-link" href="/hlc+sri/2023/02/01/kubernetes-instalacion.html" title="Taller Kubernetes: Despliegues parametrizados">Kubernetes: Instalación y configuración de minikube y kubectl</a></li>
<li><a class="post-link" href="/aso/2023/01/22/ldap1.html" title="Taller Kubernetes: Despliegues parametrizados">Escenario - Configuración de LDAP en Alfa</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">MENÚ 📝</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
